<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JVM基础篇 | geqian's Blog🍭</title><meta name="keywords" content="JVM"><meta name="author" content="geqian's Blog🍭"><meta name="copyright" content="geqian's Blog🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="黑马程序员JVM三部曲上篇-基础篇（初始化JVM、字节码文件详解、运行时数据区、垃圾回收）">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM基础篇">
<meta property="og:url" content="https://itgeqian.github.io/posts/8.html">
<meta property="og:site_name" content="geqian&#39;s Blog🍭">
<meta property="og:description" content="黑马程序员JVM三部曲上篇-基础篇（初始化JVM、字节码文件详解、运行时数据区、垃圾回收）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp">
<meta property="article:published_time" content="2025-06-15T01:19:03.000Z">
<meta property="article:modified_time" content="2025-06-18T09:12:00.000Z">
<meta property="article:author" content="geqian&#39;s Blog🍭">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://itgeqian.github.io/posts/8"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM基础篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-18 17:12:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><script src="https://cdn.jsdelivr.net/npm/echarts@6/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="geqian's Blog🍭" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.png" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">geqian's Blog🍭</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">JVM基础篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2025-06-15T01:19:03.000Z" title="发表于 2025-06-15 09:19:03">2025-06-15</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-18T09:12:00.000Z" title="更新于 2025-06-18 17:12:00">2025-06-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2.8w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>92分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM基础篇"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础篇">基础篇</h1>
<h2 id="1、初始JVM">1、初始JVM</h2>
<h3 id="1-1-什么是JVM">1.1 什么是JVM</h3>
<p>JVM 全称是 Java Virtual Machine，中文译名 Java虚拟机。JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。</p>
<p>Java源代码执行流程如下：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-5-1024x282.png" alt="img"></p>
<p>分为三个步骤：</p>
<ul>
<li>1、编写Java源代码文件。</li>
<li>2、使用Java编译器（javac命令）将源代码编译成Java字节码文件。</li>
<li>3、使用Java虚拟机加载并运行Java字节码文件，此时会启动一个新的进程。</li>
</ul>
<h3 id="1-2-JVM的功能">1.2 JVM的功能</h3>
<ul>
<li>1 - 解释和运行</li>
<li>2 - 内存管理</li>
<li>3 - 即时编译</li>
</ul>
<h4 id="1-2-1-解释和运行">1.2.1 解释和运行</h4>
<p>对字节码文件中的指令，实时的解释成机器码，让计算机执行。</p>
<p>字节码文件中包含了字节码指令，计算器无法直接执行，Java虚拟机会将字节码文件中的字节码指令实时地解释成机器码，机器码是计算机可以运行的指令。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-6-1024x388.png" alt="img"></p>
<h4 id="1-2-2-内存管理">1.2.2 内存管理</h4>
<ul>
<li>自动为对象、方法等分配内存</li>
<li>自动的垃圾回收机制，回收不再使用的对象</li>
</ul>
<p>Java虚拟机会帮助程序员为对象分配内存，同时将不用的对象使用垃圾回收器回收掉，这是对比C和C++这些语言的一个优势。在C/C++语言中，对象的回收需要程序员手动去编写代码完成，如果遗漏了这段删除对象的代码，这个对象就会永远占用内存空间，不会再回收。所以JVM的这个功能降低了程序员编写代码的难度。</p>
<h4 id="1-2-3-即时编译">1.2.3 即时编译</h4>
<p>对热点代码进行优化，提升执行效率。即时编译可以说是提升Java程序性能最核心的手段。</p>
<p><strong>Java性能低的主要原因和跨平台特性</strong></p>
<p>Java语言如果不做任何的优化，性能其实是不如C和C++语言的。主要原因是：</p>
<p>在程序运行过程中，Java虚拟机需要将字节码指令实时地解释成计算机能识别的机器码，这个过程在运行时可能会反复地执行，所以效率较低。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-7-1024x235.png" alt="img"></p>
<p>C和C++语言在执行过程中，只需要将源代码编译成可执行文件，就包含了计算机能识别的机器码，无需在运行过程中再实时地解释，所以性能较高。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-8-1024x292.png" alt="img"></p>
<p>Java为什么要选择一条执行效率比较低的方式呢？主要是为了实现跨平台的特性。Java的字节码指令，如果希望在不同平台（操作系统+硬件架构），比如在windows或者linux上运行。可以使用同一份字节码指令，交给windows和linux上的Java虚拟机进行解释，这样就可以获得不同平台上的机器码了。这样就实现了Write Once，Run Anywhere 编写一次，到处运行 的目标。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-9-1024x386.png" alt="img"></p>
<p>但是C/C++语言，如果要让程序在不同平台上运行，就需要将一份源代码在不同平台上分别进行编译，相对来说比较麻烦。</p>
<h3 id="1-3常见的JVM"><strong>1.3常见的JVM</strong></h3>
<p>平时我们最常用的，就是Hotspot虚拟机。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作者</th>
<th>支持版本</th>
<th>社区活跃度（github star）</th>
<th>特性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>HotSpot (Oracle JDK版)</td>
<td>Oracle</td>
<td>所有版本</td>
<td>高(闭源)</td>
<td>使用最广泛，稳定可靠，社区活跃JIT支持Oracle JDK默认虚拟机</td>
<td>默认</td>
</tr>
<tr>
<td>HotSpot (Open JDK版)</td>
<td>Oracle</td>
<td>所有版本</td>
<td>中(16.1k)</td>
<td>同上开源，Open JDK默认虚拟机</td>
<td>默认对JDK有二次开发需求</td>
</tr>
<tr>
<td>GraalVM</td>
<td>Oracle</td>
<td>11, 17,19企业版支持8</td>
<td>高（18.7k）</td>
<td>多语言支持高性能、JIT、AOT支持</td>
<td>微服务、云原生架构需要多语言混合编程</td>
</tr>
<tr>
<td>Dragonwell JDK龙井</td>
<td>Alibaba</td>
<td>标准版 8,11,17扩展版11,17</td>
<td>低(3.9k)</td>
<td>基于OpenJDK的增强高性能、bug修复、安全性提升JWarmup、ElasticHeap、Wisp特性支持</td>
<td>电商、物流、金融领域对性能要求比较高</td>
</tr>
<tr>
<td>Eclipse OpenJ9 (原 IBM J9)</td>
<td>IBM</td>
<td>8,11,17,19,20</td>
<td>低(3.1k)</td>
<td>高性能、可扩展JIT、AOT特性支持</td>
<td>微服务、云原生架构</td>
</tr>
</tbody>
</table>
<h2 id="2-字节码文件详解">2.字节码文件详解</h2>
<h3 id="2-1-Java虚拟机的组成">2.1 Java虚拟机的组成</h3>
<p>Java虚拟机主要分为以下几个组成部分：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-31-1024x498.png" alt="img"></p>
<ul>
<li>类加载子系统：核心组件类加载器，负责将字节码文件中的内容加载到内存中。</li>
<li>运行时数据区：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在这块区域中。</li>
<li>执行引擎：包含了即时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用即时编译器优化性能，使用垃圾回收器回收不再使用的对象。</li>
<li>本地接口：调用本地使用C/C++编译好的方法，本地方法在Java中声明时，都会带上native关键字，如下图所示。</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-32.png" alt="img"></p>
<h3 id="2-2字节码文件的组成">2.2字节码文件的组成</h3>
<h4 id="以正确的姿势打开文件">以正确的姿势打开文件</h4>
<p>字节码文件中保存了源代码编译之后的内容，以二进制方式存储，无法用记事本直接打开阅读。</p>
<p>可以通过NotePad++使用十六进制插件查看class文件：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-33.png" alt="img"></p>
<p>无法解读出文件里包含的内容，推荐使用 jclasslib工具查看字节码文件。 Github地址： <a target="_blank" rel="noopener" href="https://github.com/ingokegel/jclasslib">https://github.com/ingokegel/jclasslib</a></p>
<p>字节码文件总共可以分为以下几个部分：</p>
<ul>
<li><strong>基础信息</strong>：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息</li>
<li><strong>常量池</strong>**：** 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用</li>
<li><strong>字段：</strong> 当前类或接口声明的字段信息</li>
<li><strong>方法：</strong> 当前类或接口声明的方法信息，核心内容为方法的字节码指令</li>
<li><strong>属性：</strong> 类的属性，比如源码的文件名、内部类的列表等</li>
</ul>
<h4 id="1-基本信息">1.基本信息</h4>
<p>基本信息包含了jclasslib中能看到的两块内容：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-34.png" alt="img"></p>
<h5 id="Magic魔数">Magic魔数</h5>
<p>每个Java字节码文件的前四个字节是固定的，用16进制表示就是0xcafebabe。文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改不影响文件的内容。软件会使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。</p>
<p>比如常见的文件格式校验方式如下：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-35.png" alt="img"></p>
<p>Java字节码文件中，将文件头称为magic魔数。Java虚拟机会校验字节码文件的前四个字节是不是0xcafebabe，如果不是，该字节码文件就无法正常使用，Java虚拟机会抛出对应的错误。</p>
<h5 id="主副版本号">主副版本号</h5>
<p>主副版本号指的是编译字节码文件时使用的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。</p>
<p>1.2之后大版本号计算方法就是 : 主版本号 – 44，比如主版本号52就是JDK8。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-36.png" alt="img"></p>
<p>版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。</p>
<p>报下面错误是兼容性出现问题。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-37.png" alt="img"></p>
<p>方法1：升级IDEA编译的Jdk版本。（容易引发其它的兼容性问题）</p>
<p>方法2：改变依赖的版本，替换包名，降低版本。（工作中推荐选用该方法）</p>
<h4 id="其他基础信息">其他基础信息</h4>
<p>其他基础信息包括访问标识、类和接口索引，如下：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-38-1024x488.png" alt="img"></p>
<h4 id="2-常量池：-保存了字符串常量，类或接口名，字段名主要在字节码指令中使用。">2.**常量池：**保存了字符串常量，类或接口名，字段名主要在字节码指令中使用。</h4>
<p>常量池中的数据都有一个编号，编号从1开始。比如“我爱北京天安门”这个字符串，在常量池中的编号就是7。在字段或者字节码指令中通过编号7可以快速的找到这个字符串。</p>
<p>字节码指令中通过编号引用到常量池的过程称之为符号引用。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-39.png" alt="img"></p>
<h4 id="3-字段：-当前类或接口声明的字段信息。">3.**字段：**当前类或接口声明的字段信息。</h4>
<p>如下图中，定义了两个字段a1和a2，这两个字段就会出现在字段这部分内容中。同时还包含字段的名字、描述符（字段的类型）、访问标识（public/private static final等）。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-40.png" alt="img"></p>
<h4 id="4-方法：-当前类或接口声明的方法信息字节码指令。">4.**方法：**当前类或接口声明的方法信息字节码指令。</h4>
<p>字节码中的方法区域是存放<strong>字节码指令</strong>的核心位置，字节码指令的内容存放在方法的Code属性中。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-41-1024x375.png" alt="img"></p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int i</span> = 0;</span><br><span class="line"><span class="attribute">int j</span> = i + 1;</span><br></pre></td></tr></table></figure>
<p>这段代码编译成字节码指令之后是如下内容：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-42.png" alt="img"></p>
<p>我们需要先理解两块内存区域：操作数栈和局部变量表。</p>
<p><strong>操作数栈</strong>是用来存放临时数据的内容，是一个栈式的结构，先进后出。</p>
<p><strong>局部变量****表</strong>是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。</p>
<p>1、iconst_0，将常量0放入操作数栈。此时栈上只有0</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-43-1024x420.png" alt="img"></p>
<p>2、istore_1会从操作数栈中，将栈顶的元素弹出来，此时0会被弹出，放入局部变量表的1号位置。局部变量表中的1号位置，在编译时就已经确定是局部变量i使用的位置。完成了对局部变量i的赋值操作。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-44-1024x440.png" alt="img"></p>
<p>3、iload_1将局部变量表1号位置的数据放入操作数栈中，此时栈中会放入0。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-45-1024x430.png" alt="img"></p>
<p>4、iconst_1会将常量1放入操作数栈中。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-46-1024x431.png" alt="img"></p>
<p>5、iadd会将操作数栈顶部的两个数据相加，现在操作数栈上有两个数0和1，相加之后结果为1放入操作数栈中，此时栈上只有一个数也就是相加的结果1。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-47-1024x428.png" alt="img"></p>
<p>6、istore_2从操作数栈中将1弹出，并放入局部变量表的2号位置，2号位置是j在使用。完成了对局部变量j的赋值操作。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-48-1024x419.png" alt="img"></p>
<p>7.return语句执行，方法结束并返回。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-49-1024x421.png" alt="img"></p>
<h4 id="i-与-i">i++与++i</h4>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-50.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-51.png" alt="img"></p>
<p>问：int i = 0; i = i++; 最终i的值是多少？</p>
<p>答：答案是0，我通过分析字节码指令发现，i++先把0取出来放入临时的操作数栈中，</p>
<p>接下来对i进行加1，i变成了1，最后再将之前保存的临时值0放入i，最后i就变成了0。</p>
<h4 id="5-属性：-类的属性，比如源码的文件名内部类的列表等。">5.**属性：**类的属性，比如源码的文件名内部类的列表等。</h4>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-52.png" alt="img"></p>
<h4 id="字节码文件常见工具使用">字节码文件常见工具使用</h4>
<p>1.javap</p>
<p>javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内容。</p>
<p>直接输入javap查看所有参数。输入<code>javap -v</code> 字节码文件名称 查看具体的字节码信息。如果jar包需要先使用 <code>jar –xvf</code> 命令解压。</p>
<p>2jclasslib插件</p>
<p>3.Arthas</p>
<p>Arthas是一款线上监控诊断产品，通过全局视角实时查看应用的load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查的效率。</p>
<p>使用：</p>
<p>使用<code>java -jar arthas-boot.jar</code> 启动程序。</p>
<p>输入需要Arthas监控的进程id。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-53-1024x534.png" alt="img"></p>
<p>输入命令即可使用。</p>
<p>dashboard -i 2000 -n 3 ：隔2秒，执行3次。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-54.png" alt="img"></p>
<h3 id="2-3类的生命周期加载阶段">2.3类的生命周期加载阶段</h3>
<p>类的生命周期描述了一个类加载、使用、卸载的整个过程。整体可以分为：</p>
<ul>
<li>加载</li>
<li>连接，其中又分为验证、准备、解析三个子阶段</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-55-1024x408.png" alt="img"></p>
<h4 id="2-3-1加载阶段">2.3.1加载阶段</h4>
<p>1.加载(Loading)阶段第一步是类加载器根据类的全限定名通过不同的渠道(（本地文件，通过网络传输的类，动态代理生成）)以二进制流的方式获取字节码信息，程序员可以使用Java代码拓展的不同的渠道。</p>
<p>2.类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中。</p>
<p>3.生成一个InstanceKlass对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-57.png" alt="img"></p>
<p>4.Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象。作用是在Java代码中获取类的信息以及存储静态字段的数据。（JDK8及之后）</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-58.png" alt="img"></p>
<h4 id="2-3-2-连接阶段">2.3.2 连接阶段</h4>
<p>连接阶段分为三个子阶段:</p>
<ul>
<li>验证，验证内容是否满足《Java虚拟机规范》。</li>
<li>准备，给静态变量赋初值。</li>
<li>解析，将常量池中的符号引用替换成指向内存的直接引用。</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-59-1024x451.png" alt="img"></p>
<p><strong>1.验证</strong>：验证内容是否满足Java虚拟机规范。</p>
<p>1.文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-63-1024x289.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-62.png" alt="img"></p>
<p>major是主版本号，&gt;=常量一般是45，对jdk1.8来说最高版本号是52，对jdk8只能支持45-52之间的主版本号。副版本号不能大于0</p>
<p>2、元信息验证，例如类必须有父类（super不能为空）。</p>
<p>3、验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。</p>
<p>4、符号引用验证，例如是否访问了其他类中private的方法等。</p>
<p><strong>2</strong>.<strong>准备</strong>：准备阶段为静态变量（static）分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>初始值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>int</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>long</strong></td>
<td><strong>0L</strong></td>
</tr>
<tr>
<td><strong>short</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>char</strong></td>
<td><strong>‘\u0000’</strong></td>
</tr>
<tr>
<td><strong>byte</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>boolean</strong></td>
<td><strong>false</strong></td>
</tr>
<tr>
<td><strong>double</strong></td>
<td><strong>0.0</strong></td>
</tr>
<tr>
<td><strong>引用****数据类型</strong></td>
<td><strong>null</strong></td>
</tr>
</tbody>
</table>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-64-1024x337.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-65-1024x512.png" alt="img"></p>
<p><strong>3.解析</strong>：将常量池中的符号引用替换成指向内存的直接引用。直接引用不再使用编号，而是使用内存中的地址进行访问具体的数据。</p>
<h4 id="2-3-3初始化阶段">2.3.3初始化阶段</h4>
<p>初始化阶段会执行字节码文件中clinit（class init 类的初始化）方法的字节码指令，包含了静态代码块中的代码，并为静态变量赋值。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-66.png" alt="img"></p>
<ul>
<li>init方法，会在<strong>对象</strong>初始化时执行</li>
<li>main方法，主方法</li>
<li>clinit方法，<strong>类</strong>的初始化阶段执行</li>
</ul>
<hr>
<p>关于init和clint的区别：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>全名</th>
<th>类型</th>
<th>什么时候执行</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;init&gt;</code></td>
<td>实例构造方法</td>
<td>对象方法</td>
<td><code>new</code> 一个对象时（构造器执行）</td>
<td>初始化“对象”</td>
</tr>
<tr>
<td><code>&lt;clinit&gt;</code></td>
<td>类初始化方法</td>
<td>静态方法</td>
<td>第一次使用类时自动执行（仅一次）</td>
<td>初始化“类级别的静态内容”</td>
</tr>
</tbody>
</table>
<p><code>&lt;init&gt;</code> 是实例构造器方法，每次创建对象都会执行；而 <code>&lt;clinit&gt;</code> 是类初始化方法，只在类被第一次加载时执行一次，用来处理静态变量初始化和静态代码块。</p>
<p>1️⃣ <code>&lt;init&gt;</code>：构造方法（非静态）</p>
<ul>
<li>对应 Java 中的构造函数（<code>public Demo2() &#123;&#125;</code>）</li>
<li>每次创建对象（<code>new Demo2()</code>）时执行一次</li>
<li>是 <strong>对象级别</strong> 的初始化方法</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;构造器执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后会生成 <code>&lt;init&gt;</code> 方法。</p>
<p>2️⃣ <code>&lt;clinit&gt;</code>：类初始化方法（静态）</p>
<ul>
<li><strong>不是你写的代码中显式的方法</strong>，而是编译器自动生成的</li>
<li>当类中包含：
<ul>
<li>静态变量赋值（如：<code>public static int i = 10;</code>）</li>
<li>或静态代码块（如：<code>static &#123; System.out.println(&quot;xxx&quot;); &#125;</code>）</li>
<li>编译器会把这些放进一个叫 <code>&lt;clinit&gt;</code> 的方法中</li>
</ul>
</li>
<li><strong>这个方法在类加载时只执行一次</strong></li>
</ul>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，会生成一个 <code>&lt;clinit&gt;</code> 方法，里面包含上面两个静态初始化语句。</p>
<hr>
<p>继续来看clinit方法中的字节码指令：</p>
<p>1、iconst_1，将常量1放入操作数栈。此时栈中只有1这个数。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1136-1024x350.png" alt="img"></p>
<p>2、putstatic指令会将操作数栈上的数弹出来，并放入堆中静态变量的位置，字节码指令中#2指向了常量池中的静态变量value，在解析阶段会被替换成变量的地址。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1137-1024x345.png" alt="img"></p>
<p>3、后两步操作类似，执行value=2，将堆上的value赋值为2。</p>
<p>如果将代码的位置互换：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="type">static</span> &#123;</span><br><span class="line">        value = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1138.png" alt="img"></p>
<p>这样初始化结束之后，最终value的值就变成了1而不是2。</p>
<p>以下几种方式会导致类的初始化：</p>
<ul>
<li>1.访问一个类的静态变量或者静态方法（如果变量时final修饰的并且等号右边是常量不会触发初始化，因为在连接阶段会直接赋常量值）</li>
<li>2.调用Class.forName(String className)</li>
<li>3.new一个该类的对象时。</li>
<li>4.执行Main方法的当前类。</li>
</ul>
<p>添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类</p>
<p><strong>面试题1：</strong></p>
<p>如下代码的输出结果是什么？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">publicclassTest1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        newTest1();</span><br><span class="line">        newTest1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicTest1()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析步骤：</p>
<p><strong>Java 中的执行顺序是：</strong></p>
<ol>
<li><strong>静态代码块</strong>（<code>static&#123;&#125;</code>）——类加载时只执行一次</li>
<li>执行 <code>main()</code> 方法</li>
<li>创建对象时：
<ul>
<li>先执行 <strong>构造代码块</strong>（<code>&#123;&#125;</code>）</li>
<li>再执行 <strong>构造方法</strong>（<code>Test1()</code>）</li>
</ul>
</li>
</ol>
<p>ldc #9是从常量池中将字符串D加载到操作数栈中。</p>
<p>invokevirtual是调用Println方法打印操作数栈上的内容。</p>
<p>1、执行main方法之前，先执行clinit指令。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1139-1024x132.png" alt="img"></p>
<p>指令会输出D</p>
<p>2、执行main方法的字节码指令。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1140.png" alt="img"></p>
<p>指令会输出A</p>
<p>3、创建两个对象，会执行两次对象初始化的指令。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1141.png" alt="img"></p>
<p>这里会输出CB，源代码中输出C这行，被放到了对象初始化的一开始来执行。</p>
<p>所以最后的结果应该是DACBCB</p>
<p>小结：类加载时先执行一次静态代码块，然后每次创建对象时都会先执行构造代码块 <code>&#123;&#125;</code>，再执行构造函数。这种顺序是面试中常考的基础知识点。</p>
<p>注意：构造代码块优于构造方法执行，这就是为什么C在B前面执行了</p>
<h4 id="clinit不会执行的几种情况">clinit不会执行的几种情况</h4>
<p>如下几种情况是不会进行初始化指令执行的：</p>
<p>1.无静态代码块且无静态变量赋值语句。</p>
<p>2.有静态变量的声明，但是<strong>没有赋值语句</strong>。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1142.png" alt="img"></p>
<p>3.<strong>静态变量</strong>的定义<strong>使用final关键字</strong>，这类变量会在准备阶段直接进行初始化。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1144.png" alt="img"></p>
<p>注意：</p>
<p>1.直接访问父类的静态变量，不会触发子类的初始化</p>
<p>2.子类的初始化clinit调用之前，会先调用父类的clinit初始化方法。</p>
<p><strong>面试题2：</strong></p>
<p>如下代码的输出结果是什么？</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new B02();</span><br><span class="line">        System.out.println(B02.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A02</span></span>&#123;</span><br><span class="line">    static <span class="keyword">int</span> a= <span class="number">0</span>;</span><br><span class="line">    static&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B02</span> <span class="title">extends</span> <span class="title">A02</span></span>&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析步骤：</p>
<ul>
<li>1、调用new创建对象，需要初始化B02，优先初始化父类。</li>
<li>2、执行A02的初始化代码，将a赋值为1。</li>
<li>3、B02初始化，将a赋值为2。</li>
</ul>
<p>最终答案为2</p>
<p>变化</p>
<p>将<code>new B02();</code>注释掉会怎么样？</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1145.png" alt="img"></p>
<p>分析步骤：</p>
<ul>
<li>1、访问父类的静态变量，只初始化父类。</li>
<li>2、执行A02的初始化代码，将a赋值为1。</li>
</ul>
<p><strong>访问父类的静态变量，只初始化父类，a是A02的变量，属于父类的变量，所以只初始化了类A02</strong></p>
<p>答案为1</p>
<p><strong>验证题，我们验证后发现如下两个结论：</strong></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1146-1024x541.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1147-1024x450.png" alt="img"></p>
<h4 id="2-3-4类的声明周期总结">2.3.4类的声明周期总结</h4>
<p>1.加载阶段</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1148-1024x569.png" alt="img"></p>
<p>2，3,4连接阶段</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1149-1024x431.png" alt="img"></p>
<p>5初始化阶段</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1150-1024x557.png" alt="img"></p>
<p>6.使用阶段</p>
<p>7.卸载阶段</p>
<h3 id="2-4类加载器的分类">2.4类加载器的分类</h3>
<h4 id="2-4-1什么是类加载器">2.4.1什么是类加载器</h4>
<p>类加载器ClassLoader：是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术，类加载器只参与加载过程中的字节码获取并加载到内存这一部分。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1151-1024x398.png" alt="img"></p>
<p><strong>类加载器的作用？</strong></p>
<p>类加载器负责在类加载过程中的字节码获取并加载到内存中。通过加载字节码数据放入内存转换成byte[]，接下来调用虚拟机底层方法将byte[]转换成方法区和堆中的数据。</p>
<h4 id="2-4-2类加载器的分类">2.4.2类加载器的分类</h4>
<p>类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。</p>
<ul>
<li>虚拟机底层实现：源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如Hotspot使用C++。主要目的是保证Java程序运行中基础类被正确地加载，比如java.lang.String，Java虚拟机需要确保其可靠性。</li>
<li>JDK中默认提供或者自定义：JDK中默认提供了多种处理不同渠道的类加载器，程序员也可以自己根据需求定制，使用Java语言。所有Java中实现的类加载器都需要继承<strong>ClassLoader</strong>这个抽象类。</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1152.png" alt="img"></p>
<p>JDK9之后出现模块化，所以JDK9是分水岭。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1154-1024x546.png" alt="img"></p>
<p>类加载器的详细信息可以通过Arthas的classloader命令查看：</p>
<p><code>classloader</code> - 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1155-1024x398.png" alt="img"></p>
<ul>
<li>BootstrapClassLoader是启动类加载器，numberOfInstances是类加载器的数量只有1个，loadedCountTotal是加载类的数量1861个。</li>
<li>ExtClassLoader是扩展类加载器</li>
<li>AppClassLoader是应用程序类加载器</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1156.png" alt="img"></p>
<h4 id="2-4-3启动类加载器（Bootstrap-ClassLoader）">2.4.3启动类加载器（Bootstrap ClassLoader）</h4>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用<strong>C++编写</strong>的类加载器。</li>
<li>默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，tools.jar，resources.jar等。（rt.jar是最核心的jar包。string，integer，long，日期类。）</li>
</ul>
<p>运行如下代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 启动程序类加载器案例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootstrapClassLoaderDemo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> throwsIOException </span>&#123;</span><br><span class="line">        ClassLoader classLoader = <span class="type">String</span>.<span class="keyword">class</span>.<span class="built_in">getClassLoader</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(classLoader);</span><br><span class="line"></span><br><span class="line">        System.in.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码通过String类获取到它的类加载器并且打印，结果是<code>null</code>。这是因为启动类加载器<strong>在JDK8中是由C++语言来编写的</strong>，在Java代码中去获取既不适合也不安全，所以才返回<code>null</code></p>
<p>在Arthas中可以通过<code>sc -d 类名</code>的方式查看加载这个类的类加载器详细的信息，比如：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1157.png" alt="img"></p>
<p>通过上图可以看到，java.lang.String类的类加载器是空的，Hash值也是null。</p>
<p><strong>如何让启动类加载器去加载用户jar包：</strong></p>
<ul>
<li>1.把要扩展的类打成jar包，放入jre/lib下进行扩展（不推荐，会要求名称符合规范）。</li>
<li>2.使用参数进行扩展。推荐，使用-Xbootclasspath/a:jar包目录/jar包名进行扩展。</li>
</ul>
<p>如下图，在IDEA配置中添加虚拟机参数，就可以加载<code>D:/jvm/jar/classloader-test.jar</code>这个jar包了。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1158.png" alt="img"></p>
<h4 id="2-4-4扩展类加载器和应用程序类加载器（Extension-ClassLoader-和-Application-ClassLoader）">2.4.4扩展类加载器和应用程序类加载器（Extension ClassLoader 和 Application ClassLoader）</h4>
<ul>
<li>扩展类加载器和应用程序类加载器都是JDK提供的，使用Java编写的类加载器。</li>
<li>它们的源码都位于sun.misc.Launcher中，是一个静态内部类。继承自URLClassLoader。具备通过目录或者指定jar包将字节码文件加载到内存中。</li>
</ul>
<p>继承关系图：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1160-1024x292.png" alt="img"></p>
<ul>
<li>ClassLoader类定义了具体的行为模式，简单来说就是先从本地或者网络<strong>获得字节码信息</strong>，然后调用虚拟机底层的方法<strong>创建方法区和堆上的对象</strong>。这样的好处就是让子类只需要去实现如何获取字节码信息这部分代码。</li>
<li>SecureClassLoader提供了证书机制，提升了安全性。</li>
<li>URLClassLoader提供了根据URL获取目录下或者指定jar包进行加载，获取字节码的数据。</li>
<li>扩展类加载器和应用程序类加载器继承自URLClassLoader，获得了上述的三种能力。</li>
</ul>
<p><strong>扩展类加载器</strong></p>
<p>扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。默认加载Java安装目录/jre/lib/ext下的类文件。</p>
<p>通过扩展类加载器去加载用户jar包：</p>
<ul>
<li><strong>放入/jre/lib/ext下进行扩展</strong>。不推荐，尽可能不要去更改JDK安装目录中的内容。</li>
<li><strong>使用参数进行扩展使用参数进行扩展</strong>。推荐，使用-Djava.ext.dirs=jar包目录 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos/linux)追加上原始目录</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1161.png" alt="img"></p>
<p>使用<code>引号</code>将整个地址包裹起来，这样路径中即便是有空格也不需要额外处理。路径中要包含原来ext文件夹，同时在最后加上扩展的路径。</p>
<p><strong>应用程序加载器</strong></p>
<p>应用程序类加载器会加载classpath下的类文件，默认加载的是项目中的类以及通过maven引入的第三方jar包中的类。</p>
<p>如下案例中，打印出<code>Student</code>和<code>FileUtils</code>的类加载器：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 应用程序类加载器案例 */</span>publicclassAppClassLoaderDemo &#123;</span><br><span class="line">    publicstaticvoidmain(String[] args) throwsIOException, InterruptedException &#123;</span><br><span class="line">        //当前项目中创建的Student类Student student = newStudent();</span><br><span class="line">        ClassLoader classLoader = Student.<span class="keyword">class</span>.getClassLoader();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(classLoader);</span><br><span class="line"></span><br><span class="line">        //maven依赖中包含的类ClassLoader classLoader1 = FileUtils.<span class="keyword">class</span>.getClassLoader();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(classLoader1);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">in</span>.<span class="keyword">read</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1162.png" alt="img"></p>
<p>类加载器的加载路径可以通过classloader –c hash值 查看：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1163-1024x399.png" alt="img"></p>
<h3 id="2-5、双亲委派机制">2.5、双亲委派机制</h3>
<p>双亲委派机制指的是：<strong>当一个类加载器接收到加载类的任务时，会自底向上查找是否加载</strong></p>
<p><strong>再由顶向下进行加载</strong>。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1164.png" alt="img"></p>
<p>详细流程：</p>
<p>每个类加载器都有一个父类加载器（Java实现的类加载器，<strong>内部都保存了一个parent的成员变量</strong>，它表示我的父类加载器是谁）。父类加载器的关系如下，启动类加载器没有父类加载器：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1165.png" alt="img"></p>
<p><strong>在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。</strong></p>
<p>自己没干的就让父类干；自己干了的就直接给你</p>
<h4 id="2-5-1案例1：">2.5.1案例1：</h4>
<p>比如com.itheima.my.A假设在启动类加载器的加载目录中，而应用程序类加载器接到了加载类的任务。</p>
<p>1、应用程序类加载器首先判断自己加载过没有，没有加载过就交给父类加载器 - 扩展类加载器。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1166.png" alt="img"></p>
<p>2、扩展类加载器也没加载过，交给他的父类加载器 - 启动类加载器。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1167-1024x462.png" alt="img"></p>
<p>3、启动类加载器发现已经加载过，直接返回。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1168-1024x448.png" alt="img"></p>
<h4 id="2-5-2案例2：">2.5.2案例2：</h4>
<p>B类在扩展类加载器加载路径中，同样应用程序类加载器接到了加载任务，按照案例1中的方式一层一层向上查找，<strong>发现都没有加载过</strong>。那么启动类加载器会首先尝试加载。它发现这类不在它的加载目录中，向下传递给扩展类加载器。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1169-1024x438.png" alt="img"></p>
<p>扩展类加载器发现这个类在它加载路径中，加载成功并返回。（注：<strong>如果所有类加载器都无法加载这个类，最终抛出 ClassNotFoundException</strong>）</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1170-1024x436.png" alt="img"></p>
<p>如果第二次再接收到加载任务，同样地向上查找。扩展类加载器发现已经加载过，就可以返回了。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1171-1024x440.png" alt="img"></p>
<h4 id="2-5-3双亲委派机制的作用">2.5.3双亲委派机制的作用</h4>
<ul>
<li>1.保证类加载的安全性。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。</li>
<li>2.避免重复加载。双亲委派机制可以避免同一个类被多次加载。</li>
</ul>
<h4 id="2-5-4如何指定加载类的类加载器？">2.5.4如何指定加载类的类加载器？</h4>
<p>在Java中如何使用代码的方式去主动加载一个类呢？</p>
<p>方式1：使用Class.forName方法，使用当前类的类加载器去加载指定的类。</p>
<p>方式2：获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载。</p>
<p>例如：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1172.png" alt="img"></p>
<h4 id="2-5-5三个面试题">2.5.5三个面试题</h4>
<p>1、如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？</p>
<p>启动类加载器加载，根据双亲委派机制，它的优先级是最高的</p>
<p>2、String类能覆盖吗，在自己的项目中去创建一个java.lang.String类，会被加载吗？</p>
<p>不能，会返回启动类加载器加载在rt.jar包中的String类。</p>
<p>3、<strong>类的双亲委派机制是什么？</strong>（！）</p>
<ul>
<li>
<p>1.先描述双亲委派机制的流程。</p>
</li>
<li>
<p>2.然后描述类加载器之间的关系。</p>
</li>
<li>
<p>3.双亲委派机制的好处</p>
</li>
<li>
<p>当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载。</p>
</li>
<li>
<p>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器。</p>
</li>
<li>
<p>双亲委派机制的好处有两点：第一是避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。</p>
</li>
</ul>
<h3 id="2-6打破双亲委派机制">2.6打破双亲委派机制</h3>
<p>有三种方式，但本质上只有第一种算是真正的打破了双亲委派机制：</p>
<ul>
<li>自定义类加载器并且重写loadClass方法。Tomcat通过这种方式实现应用之间类隔离，《面试篇》中分享它的做法。</li>
<li>线程上下文类加载器。利用上下文类加载器加载类，比如JDBC和JNDI等。</li>
<li>Osgi框架的类加载器。历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。</li>
</ul>
<h4 id="2-6-1打破类的双亲委派机制-自定义类加载器">2.6.1打破类的双亲委派机制 自定义类加载器</h4>
<p>一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类。如果不打破双亲委派机制，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1173.png" alt="img"></p>
<p>Tomcat使用了自定义类加载器来实现应用之间类的隔离。 每一个应用会有一个独立的类加载器加载对应的类。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1174.png" alt="img"></p>
<p>那么自定义加载器是如何能做到的呢？首先我们需要先了解，双亲委派机制的代码到底在哪里，接下来只需要把这段代码消除即可。</p>
<p>ClassLoader中包含了4个核心方法，双亲委派机制的核心代码就位于loadClass方法中。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String <span class="keyword">name</span>)</span><br><span class="line">类加载的入口，提供了双亲委派机制。内部会调用findClass   重要</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; findClass(String <span class="keyword">name</span>)</span><br><span class="line">由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。    重要</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">Class</span>&lt;?&gt; defineClass(String <span class="keyword">name</span>, byte[] b, <span class="built_in">int</span> off, <span class="built_in">int</span> len)</span><br><span class="line">做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> void resolveClass(<span class="keyword">Class</span>&lt;?&gt; c)</span><br><span class="line">执行类生命周期中的连接阶段</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>
<ol>
<li>自定义类加载器可以重写findClass方法来<strong>自定义获取字节码信息的途径</strong>。</li>
</ol>
</li>
<li>
<ol start="2">
<li>如果想通过自定义类加载器来打破双亲委派机制则需要重写loadClass方法，不再实现双亲委派机制。</li>
</ol>
</li>
</ul>
<p>关于findClass：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1175-1024x403.png" alt="img"></p>
<p>我们接着继续看ClassLoader中4个核心方法</p>
<p>1、入口方法：（采用类加载器.loadclass方法默认不会执行连接和初始化。而使用Class.forNmae（）会执行连接和初始化。）</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1176.png" alt="img"></p>
<p>2、再进入看下：（synchronized保证多线程条件下同一个类不会被多次加载）</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1177.png" alt="img"></p>
<p>如果查找都失败，进入加载阶段，首先会由启动类加载器加载，这段代码在<code>findBootstrapClassOrNull</code>中。如果失败会抛出异常，接下来执行下面这段代码：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1178.png" alt="img"></p>
<p>父类加载器加载失败就会抛出异常，回到子类加载器的这段代码，这样就实现了加载并向下传递。</p>
<p>3、最后根据传入的参数判断是否进入连接阶段：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1179.png" alt="img"></p>
<p>以下代码：<strong>通过自定义类加载器来打破 Java 的双亲委派机制</strong>，实现对同一个类文件的“重复加载”，从而得到两个<strong>互相不等的类对象</strong>（类对象层面不同）。</p>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">packageclassloader</span>.<span class="property">broken</span>;<span class="comment">//package com.itheima.jvm.chapter02.classloader.broken;importorg.apache.commons.io.IOUtils;</span></span><br><span class="line"></span><br><span class="line">importjava.<span class="property">io</span>.<span class="property">File</span>;</span><br><span class="line">importjava.<span class="property">io</span>.<span class="property">FileInputStream</span>;</span><br><span class="line">importjava.<span class="property">io</span>.<span class="property">IOException</span>;</span><br><span class="line">importjava.<span class="property">io</span>.<span class="property">InputStream</span>;</span><br><span class="line">importjava.<span class="property">nio</span>.<span class="property">charset</span>.<span class="property">StandardCharsets</span>;</span><br><span class="line">importjava.<span class="property">security</span>.<span class="property">ProtectionDomain</span>;</span><br><span class="line">importjava.<span class="property">util</span>.<span class="property">regex</span>.<span class="property">Matcher</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 打破双亲委派机制 - 自定义类加载器 */</span><span class="variable">publicclassBreakClassLoader1</span> <span class="title function_">extendsClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">private</span> <span class="title class_">String</span> <span class="variable">basePath</span>;</span><br><span class="line">    <span class="variable">private</span> <span class="variable">final</span> <span class="keyword">static</span> <span class="title class_">String</span> <span class="variable">FILE_EXT</span><span class="operator">=</span> <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置加载目录</span></span><br><span class="line">    <span class="variable">public</span> <span class="variable">void</span> <span class="title function_">setBasePath</span>(<span class="params">String</span> <span class="params">basePath</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">basePath</span> <span class="operator">=</span> <span class="variable">basePath</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用commons io 从指定目录下加载文件</span></span><br><span class="line">    <span class="variable">private</span> <span class="variable">byte</span>[] <span class="title function_">loadClassData</span>(<span class="params">String</span> <span class="params">name</span>)  &#123;</span><br><span class="line">        <span class="title function_">try</span>&#123;</span><br><span class="line">            <span class="title class_">String</span> <span class="variable">tempName</span> <span class="operator">=</span> <span class="variable">name</span>.<span class="property">replaceAll</span>(<span class="string">&quot;<span class="char escape_">\\</span>.&quot;</span>, <span class="title class_">Matcher</span>.<span class="property">quoteReplacement</span>(<span class="title class_">File</span>.<span class="property">separator</span>));</span><br><span class="line">            <span class="title class_">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="title function_">newFileInputStream</span>(<span class="variable">basePath</span> <span class="operator">+</span> <span class="variable">tempName</span> <span class="operator">+</span> <span class="variable">FILE_EXT</span>);</span><br><span class="line">            <span class="title function_">try</span>&#123;</span><br><span class="line">                returnIOUtils.<span class="property">toByteArray</span>(<span class="variable">fis</span>);</span><br><span class="line">            &#125; <span class="title function_">finally</span>&#123;</span><br><span class="line">                <span class="title class_">IOUtils</span>.<span class="property">closeQuietly</span>(<span class="variable">fis</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="title function_">catch</span>(<span class="params">Exception</span> <span class="params">e</span>) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="string">&quot;自定义类加载器加载失败，错误原因：&quot;</span><span class="operator">+</span> <span class="variable">e</span>.<span class="property">getMessage</span>());</span><br><span class="line">            returnnull;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写loadClass方法</span></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    <span class="variable">public</span> <span class="title class_">Class</span><span class="operator">&lt;</span>?<span class="operator">&gt;</span> <span class="title function_">loadClass</span>(<span class="title class_">String</span> <span class="variable">name</span>) <span class="title function_">throwsClassNotFoundException</span> &#123;</span><br><span class="line">        <span class="comment">//如果是java包下，还是走双亲委派机制</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">name</span>.<span class="property">startsWith</span>(<span class="string">&quot;java.&quot;</span>))&#123;</span><br><span class="line">            returnsuper.<span class="property">loadClass</span>(<span class="variable">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从磁盘中指定目录下加载</span></span><br><span class="line">        <span class="variable">byte</span>[] <span class="variable">data</span> <span class="operator">=</span> <span class="title function_">loadClassData</span>(<span class="variable">name</span>);</span><br><span class="line">        <span class="comment">//调用虚拟机底层方法，方法区和堆区创建对象</span></span><br><span class="line">        <span class="title function_">returndefineClass</span>(<span class="variable">name</span>, <span class="variable">data</span>, <span class="number">0</span>, <span class="variable">data</span>.<span class="property">length</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">public</span> <span class="keyword">static</span> <span class="variable">void</span> <span class="title function_">main</span>(<span class="title class_">String</span>[] <span class="variable">args</span>) <span class="variable">throwsClassNotFoundException</span>, <span class="title class_">InstantiationException</span>, <span class="title class_">IllegalAccessException</span>, <span class="title class_">IOException</span> &#123;</span><br><span class="line">        <span class="comment">//第一个自定义类加载器对象</span></span><br><span class="line">        <span class="title class_">BreakClassLoader</span>1 classLoader1 <span class="operator">=</span> <span class="title function_">newBreakClassLoader1</span>();</span><br><span class="line">        classLoader1.<span class="property">setBasePath</span>(<span class="string">&quot;D:<span class="char escape_">\\</span>lib<span class="char escape_">\\</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Class</span><span class="operator">&lt;</span>?<span class="operator">&gt;</span> <span class="variable">clazz1</span> <span class="operator">=</span> classLoader1.<span class="property">loadClass</span>(<span class="string">&quot;com.itheima.my.A&quot;</span>);</span><br><span class="line">         <span class="comment">//第二个自定义类加载器对象</span></span><br><span class="line">        <span class="title class_">BreakClassLoader</span>1 classLoader2 <span class="operator">=</span> <span class="title function_">newBreakClassLoader1</span>();</span><br><span class="line">        classLoader2.<span class="property">setBasePath</span>(<span class="string">&quot;D:<span class="char escape_">\\</span>lib<span class="char escape_">\\</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Class</span><span class="operator">&lt;</span>?<span class="operator">&gt;</span> <span class="variable">clazz2</span> <span class="operator">=</span> classLoader2.<span class="property">loadClass</span>(<span class="string">&quot;com.itheima.my.A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="variable">clazz1</span> <span class="operator">==</span> <span class="variable">clazz2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Thread</span>.<span class="property">currentThread</span>().<span class="property">setContextClassLoader</span>(classLoader1);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="title class_">Thread</span>.<span class="property">currentThread</span>().<span class="property">getContextClassLoader</span>());</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">in</span>.<span class="property">read</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Java 中“类相等”的判断不仅看类名是否相同，还要看是由“哪个类加载器”加载的。同名类如果由不同加载器加载，JVM 会认为它们是两个不同的类。</strong></p>
<h5 id="自定义类加载器父类怎么是AppClassLoader呢？"><strong>自定义类加载器父类怎么是AppClassLoader呢？</strong></h5>
<p>在不手动指定父加载器的情况下，自定义类加载器的父加载器默认是 <strong>应用类加载器（AppClassLoader）</strong>，也就是加载我们项目代码的那个加载器。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1180.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1183-1024x524.png" alt="img"></p>
<p>以Jdk8为例，ClassLoader类中提供了构造方法设置parent的内容：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1181.png" alt="img"></p>
<p>这个构造方法由另外一个构造方法调用，其中父类加载器由getSystemClassLoader方法设置，该方法返回的是AppClassLoader。（<code>ClassLoader</code> 构造器中是如何设置 parent 的？）</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1182.png" alt="img"></p>
<ul>
<li><code>getSystemClassLoader()</code> 会返回当前 JVM 的系统类加载器（也就是 AppClassLoader）；</li>
<li>所以，如果你不显式写 <code>super(xxx)</code>，系统会自动帮你传入 <code>AppClassLoader</code> 作为父加载器。</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1184-1024x372.png" alt="img"></p>
<p><strong>想改变默认父加载器怎么办？</strong></p>
<p>可以用如下方式指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">myLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(ClassLoader.getSystemClassLoader().getParent()); <span class="comment">// 把 parent 指定为 ExtClassLoader</span></span><br></pre></td></tr></table></figure>
<p>或者可以重写子类的构造方法，使用 <code>super(自定义parent)</code> 指定想要的父加载器。</p>
<h5 id="两个自定义类加载器加载相同限定名的类，不会冲突吗？"><strong>两个自定义类加载器加载相同限定名的类，不会冲突吗？</strong></h5>
<p><strong>不会冲突</strong>，在同一个Java虚拟机中，只有<strong>相同类加载器+相同的类限定名才会被认为是同一个类</strong>。</p>
<p>在Arthas中使用sc –d 类名的方式查看具体的情况。</p>
<p>如下代码：</p>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">public</span> <span class="keyword">static</span> <span class="variable">void</span> <span class="title function_">main</span>(<span class="title class_">String</span>[] <span class="variable">args</span>) <span class="variable">throwsClassNotFoundException</span>, <span class="title class_">InstantiationException</span>, <span class="title class_">IllegalAccessException</span>, <span class="title class_">IOException</span> &#123;</span><br><span class="line">        <span class="comment">//第一个自定义类加载器对象</span></span><br><span class="line">        <span class="title class_">BreakClassLoader</span>1 classLoader1 <span class="operator">=</span> <span class="title function_">newBreakClassLoader1</span>();</span><br><span class="line">        classLoader1.<span class="property">setBasePath</span>(<span class="string">&quot;D:<span class="char escape_">\\</span>lib<span class="char escape_">\\</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Class</span><span class="operator">&lt;</span>?<span class="operator">&gt;</span> <span class="variable">clazz1</span> <span class="operator">=</span> classLoader1.<span class="property">loadClass</span>(<span class="string">&quot;com.itheima.my.A&quot;</span>);</span><br><span class="line">         <span class="comment">//第二个自定义类加载器对象</span></span><br><span class="line">        <span class="title class_">BreakClassLoader</span>1 classLoader2 <span class="operator">=</span> <span class="title function_">newBreakClassLoader1</span>();</span><br><span class="line">        classLoader2.<span class="property">setBasePath</span>(<span class="string">&quot;D:<span class="char escape_">\\</span>lib<span class="char escape_">\\</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Class</span><span class="operator">&lt;</span>?<span class="operator">&gt;</span> <span class="variable">clazz2</span> <span class="operator">=</span> classLoader2.<span class="property">loadClass</span>(<span class="string">&quot;com.itheima.my.A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="variable">clazz1</span> <span class="operator">==</span> <span class="variable">clazz2</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>打印的应该是false，因为两个类加载器不同，尽管加载的是同一个类名，最终Class对象也不是相同的。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1185.png" alt="img"></p>
<p>通过Arthas看也会出现两个不同的A类。</p>
<h4 id="补充：关于loadClass和findClass">补充：关于loadClass和findClass</h4>
<p>如果要扩展一个类的加载的渠道，应该是重写findClass方法，而不是loadClass去打破双亲委派机制。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1186-1024x463.png" alt="img"></p>
<p><code>loadClass()</code> 方法是整个类加载流程的“入口”，<strong>包含了双亲委派的逻辑</strong>；<br>
如果你想自己定义怎么加载一个类，<strong>应该重写 <code>findClass()</code>，而不是篡改 <code>loadClass()</code> 的流程</strong>。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1187-1024x768.png" alt="img"></p>
<p><strong><code>findClass(String name)</code>（子类实现）</strong></p>
<p>你只要重写这个方法，就可以定义自己的“加载策略”：比如从本地文件、网络、数据库读取字节码，然后用 <code>defineClass()</code> 转换为 JVM 类对象。</p>
<p>总结：如果你要“扩展加载逻辑”但 <strong>不想破坏双亲委派机制</strong>（比如加一个新的加载路径、从加密 JAR 加载），应该 <strong>只重写 <code>findClass()</code></strong>；<br>
如果你要“打破委派机制”实现“类隔离、插件沙箱”，可以 <strong>重写 <code>loadClass()</code> 但要清楚风险</strong>。</p>
<h4 id="2-6-2打破类的双亲委派机制-线程上下文类加载器">2.6.2打破类的双亲委派机制 线程上下文类加载器</h4>
<p>利用上下文类加载器加载类，比如JDBC和JNDI等。</p>
<p>我们来看下JDBC的案例：</p>
<p>1、JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。</p>
<p>2.DriverManager属于rt.jar是启动类加载器加载的。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1188.png" alt="img"></p>
<p>3、依赖中的mysql驱动对应的类，由应用程序类加载器来加载。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1190.png" alt="img"></p>
<p>在类中有初始化代码：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1191.png" alt="img"></p>
<p>DriverManager属于rt.jar是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，<em>这就违反了双亲委派机制</em>。（这点存疑，一会儿再讨论）</p>
<p>那么问题来了，DriverManager怎么知道jar包中要加载的驱动在哪儿？</p>
<p>步骤 1：Driver 类中的 static 块会注册驱动</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 mysql 驱动类加载时，它自己会注册到 DriverManager 中</p>
<p>2、DriverManager 启动时会调用 <code>loadInitialDrivers()</code></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1192.png" alt="img"></p>
<p>这个<code>loadInitialDrivers()</code>里用到了 <strong>JDK 提供的 SPI 机制</strong>，自动扫描 classpath 下所有实现了 <code>java.sql.Driver</code> 接口的类。</p>
<p>3、这里使用了SPI机制，去加载所有jar包中实现了Driver接口的实现类。（spi全称为（Service Provider Interface），是JDK内置的一种服务提供发现机制。）</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1193-1024x767.png" alt="img"></p>
<p>SPI 机制从哪里找这些“实现类”？</p>
<p>它去找每个 jar 包里的：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">META</span>-<span class="keyword">INF</span>/services/java.sql.Driver</span><br></pre></td></tr></table></figure>
<p>文件中写的就是实现类名，例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.mysql</span><span class="selector-class">.cj</span><span class="selector-class">.jdbc</span>.Drive</span><br></pre></td></tr></table></figure>
<p>4、SPI 机制从哪里找这些“实现类”？</p>
<p>它去找每个 jar 包里的：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">META</span>-<span class="keyword">INF</span>/services/java.sql.Driver</span><br></pre></td></tr></table></figure>
<p>文件中写的就是实现类名，例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.mysql</span><span class="selector-class">.cj</span><span class="selector-class">.jdbc</span>.Drive</span><br></pre></td></tr></table></figure>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1195.png" alt="img"></p>
<p>5、SPI 是用哪个类加载器加载这些类的？</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl <span class="operator">=</span> Thread.currentThread().getContextClassLoader()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用当前线程的上下文类加载器</strong>，即 AppClassLoader，来加载驱动类！</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1196-1024x190.png" alt="img"></p>
<h5 id="总结：">总结：</h5>
<p><strong>背景：JDBC 驱动怎么加载的？</strong></p>
<p>我们在写 JDBC 连接数据库时，通常不需要显式加载驱动类（<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)</code>），JVM 会自动完成加载。那么 JVM 是怎么知道 mysql 驱动在哪的呢？</p>
<p>关键角色：DriverManager + SPI机制 + 线程上下文类加载器</p>
<ol>
<li>DriverManager 是谁加载的？</li>
</ol>
<ul>
<li>
<p><code>DriverManager</code> 类在 <code>rt.jar</code> 中，属于 JDK 自带类。</p>
</li>
<li>
<p>所以它是由 <strong>启动类加载器 BootstrapClassLoader</strong> 加载的。</p>
</li>
<li>
<p>mysql 驱动类是谁加载的？</p>
</li>
<li>
<p>比如 <code>com.mysql.cj.jdbc.Driver</code> 驱动类，是我们自己引入的 jar 包中的类；</p>
</li>
<li>
<p>它由 <strong>应用程序类加载器（AppClassLoader）</strong> 加载。</p>
</li>
</ul>
<p>那么，DriverManager（JDK内部）是怎么找到用户引入的 mysql 驱动类的？</p>
<p>这就涉及到：</p>
<p><strong>⭐ SPI 机制（Service Provider Interface）+ 上下文类加载器</strong></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1197.png" alt="img"></p>
<h5 id="JDBC案例中真的打破了双亲委派机制吗？">JDBC案例中真的打破了双亲委派机制吗？</h5>
<p>最早这个论点提出是在周志明《深入理解Java虚拟机》中，他认为打破了双亲委派机制，这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，所以打破了双亲委派机制。</p>
<p><strong>但是如果我们分别从DriverManager以及驱动类的加载流程上分析，JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制。</strong></p>
<p><strong>所以我认为这里没有打破双亲委派机制，只是用一种巧妙的方法让启动类加载器加载的类，去引发的其他类的加载。</strong></p>
<p>正确理解：</p>
<p><strong>并不是 DriverManager 自己去加载 mysql 驱动</strong>，而是：它借助了线程的上下文类加载（AppClassLoader）<strong>去加载</strong>用户 jar 包中的驱动类。</p>
<p>这是一种 <strong>“类加载器协作”而不是“委派破坏”</strong>。</p>
<p>综上所述：JDBC 加载驱动的过程，其实是 DriverManager 启动后，通过 SPI + 上下文类加载器让应用类加载器去加载驱动类，从而实现了插件式的扩展，<strong>并没有真正破坏双亲委派机制</strong>，而是一种巧妙的“绕开但不违背”的做法。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1209-1024x386.png" alt="img"></p>
<p>我们可以用生活里的例子来类别这种关系：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1210.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1211.png" alt="img"></p>
<h4 id="2-6-3打破类的双亲委派机制-osgi和类的热部署">2.6.3打破类的双亲委派机制 osgi和类的热部署</h4>
<p><strong>Osgi框架的类加载器</strong></p>
<p>历史上，OSGi模块化框架。它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了热部署的功能。热部署指的是在服务不停止的情况下，动态地更新字节码文件到内存中。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1198.png" alt="img"></p>
<p>由于这种机制使用已经不多，所以不再过多讨论OSGi，着重来看下热部署在实际项目中的应用。</p>
<h5 id="案例：使用阿里arthas不停机解决线上问题">案例：使用阿里arthas不停机解决线上问题</h5>
<p><strong>背景：</strong></p>
<p>小李的团队将代码上线之后，发现存在一个小bug，但是用户急着使用，如果重新打包再发布需要一个多小时的时间，所以希望能使用arthas尽快的将这个问题修复。</p>
<p><strong>思路：</strong></p>
<ol>
<li>在出问题的服务器上部署一个 arthas，并启动。</li>
<li>jad --source-only 类全限定名 &gt; 目录/文件名.java jad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码</li>
<li>mc –c 类加载器的hashcode 目录/文件名.java -d 输出目录</li>
</ol>
<p>mc 命令用来编译修改过的代码</p>
<ol>
<li>retransform class文件所在目录/xxx.class</li>
</ol>
<p>用 retransform 命令加载新的字节码</p>
<p><strong>详细流程：</strong></p>
<p>1、这段代码编写有误，在枚举中的类型判断上使用了<code>==</code> 而不是<code>equals</code>。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1199.png" alt="img"></p>
<p>2、枚举中是这样定义的，1001是普通用户，1002是VIP用户：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1200.png" alt="img"></p>
<p>3、由于代码有误，导致传递1001参数时，返回的是收费用户的内容。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1201.png" alt="img"></p>
<p>4、<code>jad --source-only 类全限定名 &gt; 目录/文件名.java</code> 使用 jad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1202-1024x78.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1203.png" alt="img"></p>
<p>5、<code>mc –c 类加载器的hashcode 目录/文件名.java -d 输出目录</code> 使用mc 命令用来编译修改过的代码</p>
<p>这里的hashcode要先使用使用sc来查看</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1206-1024x148.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1207-1024x52.png" alt="img"></p>
<p>6、<code>retransform class文件所在目录/xxx.class</code> 用 retransform 命令加载新的字节码</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1205.png" alt="img"></p>
<p>7、测试：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1208-1024x62.png" alt="img"></p>
<p><strong>注意事项：</strong></p>
<ul>
<li>1、程序重启之后，字节码文件会恢复，除非将class文件放入jar包中进行更新。</li>
<li>2、使用retransform不能添加方法或者字段，也不能更新正在执行中的方法。</li>
</ul>
<h3 id="2-7、JDK9之后的类加载器">2.7、JDK9之后的类加载器</h3>
<p>JDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的sun.misc.Launcher.java。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1212.png" alt="img"></p>
<p>由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。</p>
<ul>
<li>1.启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。</li>
<li>2、扩展类加载器被替换成了平台类加载器（Platform Class Loader）。平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。</li>
</ul>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>JDK 8 及以前</th>
<th>JDK 9 及以后（模块化系统）</th>
</tr>
</thead>
<tbody>
<tr>
<td>🌟 体系结构</td>
<td>启动类加载器 → 扩展类加载器 → 应用程序类加载器</td>
<td>启动类加载器 → 平台类加载器 → 应用程序类加载器</td>
</tr>
<tr>
<td>🔹 扩展类加载器</td>
<td><code>ExtensionClassLoader</code>（加载 jre/lib/ext）</td>
<td>✅ 被移除，⛳替代为 Platform ClassLoader</td>
</tr>
<tr>
<td>🔹 平台类加载器</td>
<td>❌ 不存在</td>
<td>✅ 新增：<code>PlatformClassLoader</code>，加载标准模块和平台库</td>
</tr>
<tr>
<td>🔹 启动类加载器</td>
<td>C++ 实现，加载 <code>rt.jar</code>（JVM 内部）</td>
<td>Java 实现，源码位于 <code>jdk.internal.loader.ClassLoaders</code> 类中</td>
</tr>
<tr>
<td>🔹 应用类加载器</td>
<td><code>AppClassLoader</code>（加载 classpath 下用户类）</td>
<td>✅ 保留，作用不变</td>
</tr>
<tr>
<td>🔹 加载路径来源</td>
<td>通过 <code>Launcher.java</code> 中硬编码的路径</td>
<td>统一改由 <code>module</code> 系统管理，Boot/Platform/App 各自处理模块</td>
</tr>
<tr>
<td>🔹 模块化支持</td>
<td>❌ 无模块化概念，纯基于类路径 classpath</td>
<td>✅ 强制启用 Java Platform Module System (JPMS)</td>
</tr>
<tr>
<td>🔹 类加载粒度</td>
<td>基于 <code>.class</code> 文件或 jar</td>
<td>支持基于模块描述符（module-info.java）的模块化加载</td>
</tr>
<tr>
<td>🔹 启动类加载器是否可获取资源</td>
<td>可以加载资源但不可直接用 Java 获取类</td>
<td>启动类加载器仍返回 <code>null</code>，对用户隐藏实现（保持一致性）</td>
</tr>
<tr>
<td>🔹 加载逻辑统一性</td>
<td>加载机制较分散</td>
<td>Boot / Platform / App 加载逻辑更加统一、模块化</td>
</tr>
<tr>
<td>🔹 类加载器是否继承自 URLClassLoader</td>
<td>Extension 和 AppClassLoader 都继承了 URLClassLoader</td>
<td>JDK9 中 PlatformClassLoader 不再继承 URLClassLoader</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>JDK 9 后最关键的变化是模块化系统 JPMS 引入</strong>，类加载器设计围绕模块系统重新架构。</li>
<li><strong>扩展类加载器被移除</strong>，由 PlatformClassLoader 统一管理平台模块。</li>
<li><strong>启动类加载器从 C++ 转向 Java 实现</strong>，但对外接口保持一致。</li>
<li><strong>类加载器职责更清晰，加载粒度从 class 级别提升到 module 级别</strong>。</li>
</ul>
<h2 id="3、运行时数据区">3、运行时数据区</h2>
<p>Java虚拟机在运行Java程序过程中管理的内存区域，称之为<strong>运行时数据区</strong>。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1214-1024x383.png" alt="img"></p>
<p>线程不共享：创建一个线程每个线程里都有一份程序计数器、Java虚拟机栈、本地方法栈对应的数据，自己的数据由自己维护，其它线程不能访问对方线程中的数据。</p>
<p>线程共享：放入任何数据，每个线程都能访问数据，共享。</p>
<ul>
<li>
<p>应用场景：Java的内存分成哪几部分？详细介绍一下。</p>
</li>
<li>
<p>Java内存中哪些部分会内存溢出？</p>
</li>
<li>
<p>JDK7和8在内存结构上的区别是什么？</p>
</li>
<li>
<p>工作中的实际问题：内存溢出。</p>
</li>
<li>
<p>内存调优的学习路线：</p>
</li>
<li>
<p>1.了解运行时内存结构，了解JVM运行过程中每一部分的内存结构以及哪些部分容易出现内存溢出。</p>
</li>
<li>
<p>2.掌握内存问题的产生原因，学习代码中常见的几种内存泄露，性能问题的常见原因。</p>
</li>
<li>
<p>3.掌握内存调优的基本方法，学习内存泄露，性能问题等常见JVM问题的常规解决方法。</p>
</li>
</ul>
<h3 id="3-1-程序计数器">3.1 程序计数器</h3>
<p>程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1215-1024x434.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1218.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1219.png" alt="img"></p>
<p>ifne 9 ，意思是将操作数栈中的数与0进行比较，如果相等执行6，如果不相等执行9。</p>
<p>在<strong>加载阶段</strong>，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个内存地址。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1216-1024x490.png" alt="img"></p>
<p>在代码执行过程中，程序计数器会记录下一行字节码指令的地址。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。这里为了简单起见，使用偏移量代替，真实内存中执行时保存的应该是地址。</p>
<p>比如当前执行的是偏移量为0的指令，那么程序计数器中保存的就是下一条的地址（偏移量1）。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1268.png" alt="img"></p>
<p>一路向下执行</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1221-1024x441.png" alt="img"></p>
<p>一直执行到方法的最后一行指令，此时方法执行return语句，当前方法执行结束，程序计数器中会放入方法出口的地址（栈中讲解，简单来说就是这个B方法结束了，A调用了B，那么要回到A方法）</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1222-1024x442.png" alt="img"></p>
<p>所以，程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。不管是分支、跳转、异常，只需要在程序计数器中放入下一行要执行的指令地址即可。</p>
<p>在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1269.png" alt="img"></p>
<h4 id="程序计数器会出现内存溢出吗？">程序计数器会出现内存溢出吗？</h4>
<p>内存溢出指的是<strong>程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限</strong>。由于每个线程只存储一个固定长度的内存地址，程序计数器是不会发生内存溢出的。程序员无需对程序计数器做任何处理。</p>
<h3 id="3-2Java虚拟机栈">3.2Java虚拟机栈</h3>
<p>Java虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，先进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存。</p>
<p>main方法执行时，会创建main方法的栈帧：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1223-1024x564.png" alt="img"></p>
<p>接下来执行study方法，会创建study方法的栈帧</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1224-1024x567.png" alt="img"></p>
<p>进入eat方法，创建eat方法的栈帧</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1225-1024x573.png" alt="img"></p>
<p>eat方法执行完之后，会弹出它的栈帧：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1226-1024x573.png" alt="img"></p>
<p>然后调用sleep方法，创建sleep方法栈帧</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1267.png" alt="img"></p>
<p>最后study方法结束之后弹出栈帧，main方法结束之后弹出main的栈帧。</p>
<p>Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。如下就有两个线程的虚拟机栈，main线程和线程A。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1227.png" alt="img"></p>
<p>Java虚拟机栈的栈帧中主要包含三方面的内容：</p>
<ul>
<li>局部变量表：作用是在运行过程中存放所有的局部变量。</li>
<li>操作数栈：是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域。</li>
<li>帧数据：包含动态链接、方法出口、异常表的引用。</li>
</ul>
<h4 id="3-2-1局部变量表">3.2.1局部变量表</h4>
<p>局部变量表的作用是在方法执行过程中存放所有的局部变量。局部变量表分为两种，一种是字节码文件中的，另外一种是栈帧中的也就是保存在内存中。栈帧中的局部变量表是根据字节码文件中的内容生成的。</p>
<p>1.我们先来看下<strong>字节码文件中的局部变量表</strong>：编译成字节码文件时就可以确定局部变量表的内容。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static voidtest1()&#123;</span><br><span class="line">    inti <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    longj <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test1方法的局部变量表如下：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1228.png" alt="img"></p>
<p>Nr表示的是变量的编号，按照生命的顺序，起始PC保存了从哪一行字节码指令开始可以访问这个局部变量，长度以生效那行到销毁那行计算。</p>
<p>局部变量表中保存了字节码指令生效的偏移量：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1229-1024x331.png" alt="img"></p>
<p>i在1中就赋值成功了，它可以访问2,3,4 起始PC2，长度3。j在3中赋值成功，起始PC3，长度1</p>
<p>比如<code>i</code>这个变量，它的起始PC是2，代表从<code>lconst_1</code>这句指令开始才能使用<code>i</code>，长度为3，也就是2-4这三句指令都可以使用<code>i</code>。为什么从2才能使用，因为0和1这两句字节码指令还在处理<code>int i = 0</code>这句赋值语句。<code>j</code>这个变量只有等3指令执行完之后也就是<code>long j = 1</code>代码执行完之后才能使用，所以起始PC为4，只能在4这行字节码指令中使用。</p>
<p>2.接下来看下<strong>栈帧中的局部变量表</strong>，栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个槽。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1230-1024x326.png" alt="img"></p>
<p><code>i</code>占用数组下标为0的位置，<code>j</code>占用数组下标1-2的位置。</p>
<p>刚才看到的是静态方法，实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1231-1024x309.png" alt="img"></p>
<p>方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1297-1024x331.png" alt="img"></p>
<p>test3方法中包含两个参数<code>k</code>,<code>m</code>，这两个参数也会被加入到局部变量表中。</p>
<p><strong>以下代码的局部变量表中会占用几个槽？</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">publicvoidtest4(<span class="built_in">int</span>k,<span class="built_in">int</span>m)&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>a = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span>b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>c = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span>i = <span class="number">0</span>;</span><br><span class="line">    longj = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。</p>
<p>1、方法执行时，实例对象<code>this</code>、<code>k</code>、<code>m</code> 会被放入局部变量表中，占用3个槽</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1232-1024x365.png" alt="img"></p>
<p>2、将1的值放入局部变量表下标为3的位置上，相当于给a进行赋值。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1298-1024x373.png" alt="img"></p>
<p>3、将2放入局部变量表下标为4的位置，给b赋值为2。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1233-1024x363.png" alt="img"></p>
<p>4、ab已经脱离了生效范围，所以下标为3和4的这两个位置可以复用。此时c的值1就可以放入下标为3的位置。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1234-1024x350.png" alt="img"></p>
<p>4、脱离c的生效范围之后，给i赋值就可以复用c的位置。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1235-1024x355.png" alt="img"></p>
<p>5、最后放入j，j是一个long类型，占用两个槽。但是可以复用b所在的位置，所以占用4和5这两个位置</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1236-1024x358.png" alt="img"></p>
<p>所以，局部变量表数值的长度为6</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1237.png" alt="img"></p>
<h4 id="3-2-2操作数栈">3.2.2操作数栈</h4>
<p>操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。</p>
<p>在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1238-1024x318.png" alt="img"></p>
<p>为什么是2？ 操作数栈中最多会出现两个数字0,1,因此最大深度为2</p>
<h4 id="3-2-3帧数据">3.2.3<strong>帧数据</strong></h4>
<p>帧数据主要包含动态链接、方法出口、异常表的引用。</p>
<p><strong>动态链接</strong></p>
<p>当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1239-1024x340.png" alt="img"></p>
<p><strong>方法出口</strong></p>
<p>方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1240.png" alt="img"></p>
<p><strong>异常表</strong></p>
<p>异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1241-1024x344.png" alt="img"></p>
<p><code>如下案例：i=1</code>这行源代码编译成字节码指令之后，会包含偏移量2-4这三行指令。其中2-3是对i进行赋值1的操作，4的没有异常就跳转到10方法结束。如果出现异常的情况下，继续执行到7这行指令，7会将异常对象放入操作数栈中，这样在catch代码块中就可以使用异常对象了。接下来执行8-9，对i进行赋值为2的操作。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1242-1024x391.png" alt="img"></p>
<p>所以异常表中，异常捕获的起始偏移量就是2，结束偏移量是4，在2-4执行过程中抛出了<code>java.lang.Exception</code>对象或者子类对象，就会将其捕获，然后跳转到偏移量为7的指令。</p>
<h4 id="3-2-4栈内存溢出">3.2.4栈内存溢出</h4>
<p>Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就<strong>会出现内存溢出</strong>。Java虚拟机栈内存溢出时会出现StackOverflowError的错误。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1243.png" alt="img"></p>
<p>如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1244-1024x151.png" alt="img"></p>
<p>我们来模拟下栈内存的溢出情况:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//递归方法调用自己</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span>()</span>&#123;</span><br><span class="line">         System.<span class="keyword">out</span>.println(++count);</span><br><span class="line">         recursion();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>使用递归让方法调用自身，但是不设置退出条件。定义调用次数的变量，每一次调用让变量加1。查看错误发生时总调用的次数。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1245.png" alt="img"></p>
<p><strong>解决方案-设置栈的大小</strong></p>
<p>要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss 。</p>
<ul>
<li>语法：-Xss栈大小</li>
<li>单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)</li>
</ul>
<p>例如：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-Xss1048576 </span></span><br><span class="line"><span class="deletion">-Xss1024K      </span></span><br><span class="line"><span class="deletion">-Xss1m</span></span><br><span class="line"><span class="deletion">-Xss1g</span></span><br></pre></td></tr></table></figure>
<p>操作步骤如下，不同IDEA版本的设置方式会略有不同：</p>
<p>1、点击修改配置Modify options</p>
<p>2、点击Add VM options</p>
<p>3、添加参数</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1247.png" alt="img"></p>
<p>调成512k之后，明显发现最大栈帧数量减少了：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1246.png" alt="img"></p>
<p>对windows来说，JDK8测试最小值为180K，最大值为1024M。</p>
<p>如果局部变量过多，操作数栈的深度过大也会影响栈内存的大小。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1248.png" alt="img"></p>
<p>Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧。</p>
<h3 id="3-3本地方法栈">3.3本地方法栈</h3>
<p>Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧。（C++）</p>
<p>在Hotspot虚拟机中，<strong>Java虚拟机栈和本地方法栈实现上使用了同一个栈空间</strong>。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1249.png" alt="img"></p>
<p>比如测试下这段代码：</p>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 本地方法栈 */</span><span class="title function_">publicclassNativeDemo1</span> &#123;</span><br><span class="line">    <span class="title function_">publicstaticvoidmain</span>(<span class="params">String</span>[] <span class="params">args</span>) &#123;</span><br><span class="line">        <span class="title function_">try</span>&#123;</span><br><span class="line">            <span class="title class_">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="title function_">newFileOutputStream</span>(<span class="string">&quot;E:<span class="char escape_">\\</span>123.txt&quot;</span>);</span><br><span class="line">            <span class="variable">fileOutputStream</span>.<span class="property">write</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="title function_">catch</span>(<span class="params">FileNotFoundException</span> <span class="params">e</span>) &#123;</span><br><span class="line">            <span class="variable">e</span>.<span class="property">printStackTrace</span>();</span><br><span class="line">        &#125; <span class="title function_">catch</span>(<span class="params">IOException</span> <span class="params">e</span>) &#123;</span><br><span class="line">            <span class="variable">e</span>.<span class="property">printStackTrace</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之后发生异常，会打印出所有栈帧的名字：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1250.png" alt="img"></p>
<p><code>open0</code>是一个本地方法，所以创建了本地方法的栈帧。本地方法和Java虚拟机方法</p>
<h3 id="3-4-堆内存">3.4 堆内存</h3>
<p>一般Java程序中堆内存是空间最大的一块内存区域。</p>
<p>创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1251-1024x282.png" alt="img"></p>
<p>这段代码中通过<code>new</code>关键字创建了两个<code>Student</code>类的对象，这两个对象会被存放在堆上。在栈上通过<code>s1</code>和<code>s2</code>两个局部变量保存堆上两个对象的地址，从而实现了引用关系的建立。</p>
<h4 id="3-4-1堆内存的溢出">3.4.1堆内存的溢出</h4>
<p>通过new关键字不停创建对象，放入集合中，模拟堆内存的溢出，观察堆溢出之后的异常信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter03.heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆内存的使用和回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            objects.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>]);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆内存大小是有上限的，当对象一直向堆中放入对象达到上限之后，就会抛出OutOfMemory错误。在这段代码中，不停创建100M大小的字节数组并放入ArrayList集合中，最终超过了堆内存的上限。抛出如下错误：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1252-1024x76.png" alt="img"></p>
<h4 id="3-4-2三个重要的值">3.4.2三个重要的值</h4>
<p>堆空间有三个需要关注的值，used、total、max。used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1253.png" alt="img"></p>
<p>可以通过：dashboard 进行访问，如果只能看内存只需要输入：memory</p>
<blockquote>
<p>手动指定刷新频率（不指定默认5秒一次）：<code>dashboard –i 刷新频率(毫秒)</code></p>
</blockquote>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1254-1024x261.png" alt="img"></p>
<p>随着堆中的对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存给堆。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1255.png" alt="img"></p>
<p>此时used达到了total的大小，Java虚拟机会向操作系统申请更大的内存。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1256.png" alt="img"></p>
<p>但是这个申请过程不是无限的，total最多只能与max相等。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1257.png" alt="img"></p>
<p>那么是不是当used = max = total的时候，堆内存就溢出了呢？</p>
<p>不是，堆内存溢出的判断条件比较复杂，在下一章《垃圾回收器》中会详细介绍。</p>
<p>如果不设置任何的虚拟机参数，max默认是系统内存的1/4，total默认是系统内存的1/64。在实际应用中一般都需要设置total和max的值。</p>
<h4 id="3-4-3设置堆的大小">3.4.3设置堆的大小</h4>
<p>要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)。</p>
<p>语法：<code>-Xmx值 -Xms值</code></p>
<p>单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)</p>
<p>限制：Xmx必须大于 2 MB，Xms必须大于1MB</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-Xms6291456</span></span><br><span class="line"><span class="deletion">-Xms6144k</span></span><br><span class="line"><span class="deletion">-Xms6m</span></span><br><span class="line"><span class="deletion">-Xmx83886080</span></span><br><span class="line"><span class="deletion">-Xmx81920k</span></span><br><span class="line"><span class="deletion">-Xmx80m</span></span><br></pre></td></tr></table></figure>
<p>这样可以将max和初始的total都设置为4g，在启动后就已经获得了最大的堆内存大小。运行过程中不需要向操作系统申请。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1258.png" alt="img"></p>
<p>使用<code>arthas</code>的<code>memory</code>命令同样可以看到：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1259-1024x182.png" alt="img"></p>
<p>为什么arthas中显示的heap堆大小与设置的值不一样呢？</p>
<p>arthas中的heap堆内存使用了JMX技术中内存获取方式，这种方式与垃圾回收器有关，计算的是可以分配对象的内存，而不是整个内存。</p>
<p><strong>建议：</strong></p>
<p>Java服务端程序开发时，建议将-Xmx和-Xms设置为相同的值，这样在程序启动之后可使用的总内存就是最大内存，而无需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况。-Xmx具体设置的值与实际的应用程序运行环境有关，在《实战篇》中会给出设置方案。</p>
<h3 id="3-5-方法区">3.5 方法区</h3>
<p>方法区是存放基础信息的位置，线程共享，主要包含三部分内容：</p>
<ul>
<li>类的元信息，保存了所有类的基本信息</li>
<li>运行时常量池，保存了字节码文件中的常量池内容</li>
<li>字符串常量池，保存了字符串常量</li>
</ul>
<h4 id="3-5-1类的元信息">3.5.1类的元信息</h4>
<p>方法区是用来存储每个类的基本信息（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成。其中就包含了类的字段、方法等字节码文件中的内容，同时还保存了运行过程中需要使用的虚方法表（实现多态的基础）等信息。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1261-1024x455.png" alt="img"></p>
<h4 id="3-5-2运行时常量池">3.5.2运行时常量池</h4>
<p>方法区除了存储类的元信息之外，还存放了运行时常量池。常量池中存放的是字节码中的常量池内容。</p>
<p>字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1262-1024x318.png" alt="img"></p>
<h4 id="3-5-3方法区的实现">3.5.3方法区的实现</h4>
<p>方法区是《Java虚拟机规范》中设计的虚拟概念，每款Java虚拟机在实现上都各不相同。Hotspot设计如下：</p>
<p>JDK7及之前的版本将方法区存放在堆区域中的<strong>永久代空间</strong>，堆的大小由虚拟机参数来控制。</p>
<p>JDK8及之后的版本将方法区存放在<strong>元空间</strong>中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1263-1024x258.png" alt="img"></p>
<p>可以通过arthas的<code>memory</code>命令看到方法区的名称以及大小：</p>
<ul>
<li>JDK7及之前的版本查看ps_perm_gen属性。</li>
<li>JDK8及之后的版本查看metaspace属性。</li>
</ul>
<h4 id="3-5-4方法区的溢出">3.5.4方法区的溢出</h4>
<p>通过ByteBuddy框架，动态创建类并将字节码数据加载到内存中。通过死循环不停地加载到方法区，观察方法区是否会出现内存溢出的情况。分别在JDK7和JDK8上运行上述代码。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1264.png" alt="img"></p>
<p>实验发现，JDK7上运行大概十几万次，就出现了错误。</p>
<p>在JDK8上运行百万次，程序都没有出现任何错误，但是内存会直线升高。这说明JDK7和JDK8在方法区的存放上，采用了不同的设计。</p>
<ul>
<li>JDK7将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数-XX:MaxPermSize=值来控制。</li>
<li>JDK8将方法区存放在元空间中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。可以使用-XX:MaxMetaspaceSize=值将元空间最大大小进行限制。</li>
</ul>
<p>在JDK8中将最大元空间内存设置为256m，再次测试</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1265.png" alt="img"></p>
<p>这次就出现了MetaSpace溢出的错误：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1266.png" alt="img"></p>
<h4 id="3-5-5字符串常量池">3.5.5字符串常量池</h4>
<p>方法区中除了类的元信息、运行时常量池之外，还有一块区域叫字符串常量池(StringTable)。</p>
<p>字符串常量池存储在代码中定义的常量字符串内容。比如“123” 这个123就会被放入字符串常量池。</p>
<p>如下代码执行时，代码中包含<code>abc</code>字符串，就会被直接放入字符串常量池。在堆上创建String对象，并通过局部变量s1引用堆上的对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1270-1024x396.png" alt="img"></p>
<p>接下来通过s2局部变量引用字符串常量池的<code>abc</code>。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1271-1024x394.png" alt="img"></p>
<p>所以s1和s2指向的不是同一个对象，打印出<code>false</code>。</p>
<p>所以s1和s2指向的不是同一个对象，打印出<code>false</code>。</p>
<h5 id="字符串常量池和运行时常量池有什么关系？">字符串常量池和运行时常量池有什么关系？</h5>
<p>早期设计时，字符串常量池是属于运行时常量池的一部分，他们存储的位置也是一致的。后续做出了调整，将字符串常量池和运行时常量池做了拆分。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1272-1024x357.png" alt="img"></p>
<p>在 JDK 7 及之前的版本中，静态变量是存储在方法区（永久代）的，而从 JDK 8 开始，随着永久代的移除，静态变量被存储在了堆区，并且位于 Class 对象内部。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1273.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1274.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1275.png" alt="img"></p>
<h5 id="StringTable的练习题1：">StringTable的练习题1：</h5>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1276.png" alt="img"></p>
<p>1、首先将<code>1</code>放入字符串常量池，通过局部变量a引用字符串常量池中的<code>1</code>字符串。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1277-1024x513.png" alt="img"></p>
<p>2、同理处理b和c：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1278-1024x506.png" alt="img"></p>
<p>3、将a和b指向的字符串进行连接，本质上就是使用StringBuilder进行连接，最后创建了一个新的字符串放入堆中。然后将局部变量d指向堆上的对象。</p>
<p>因为a+b通过stingbuild的append方法，最后new string（），<strong>new对象是放在堆中的</strong></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1279-1024x502.png" alt="img"></p>
<p>4、所以c和d指向的不是同一个对象，打印出的结果就是false。</p>
<p>即c指向了字符串常量池里的&quot;12&quot;，d指向了堆内存中的&quot;12&quot;</p>
<h5 id="StringTable的练习题2：">StringTable的练习题2：</h5>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1280.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1281-1024x453.png" alt="img"></p>
<p>说明在编译阶段，已经将1和2进行连接，最终生成12的字符串常量池中的结果。所以返回结果就是true，c和d都指向字符串常量池中的对象。</p>
<p>总结：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1282-1024x311.png" alt="img"></p>
<h5 id="intern方法">intern方法</h5>
<p>String.intern()方法是可以手动将字符串放入字符串常量池中</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1283-1024x468.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1284.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1285.png" alt="img"></p>
<p>结论：JDK7以及之后的版本中，我们在堆上创建的字符串，如果调用了intern（）方法，它只是在常量池中存放了这个对象的引用，而不再会把字符串搬运到常量池中</p>
<h4 id="3-5-6面试题：静态变量存储在哪里呢？">3.5.6面试题：静态变量存储在哪里呢？</h4>
<ul>
<li>JDK6及之前的版本中，静态变量是存放在方法区中的，也就是永久代。</li>
<li>JDK7及之后的版本中，静态变量是存放在堆中的Class对象中，脱离了永久代。具体源码可参考虚拟机源码：BytecodeInterpreter针对putstatic指令的处理。</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1286-1024x522.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1287-1024x613.png" alt="img"></p>
<h3 id="3-6-直接内存">3.6 直接内存</h3>
<p>直接内存（Direct Memory）并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。</p>
<p>在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:</p>
<ul>
<li>1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。</li>
<li>2、IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。</li>
</ul>
<p>现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。</p>
<p>使用堆创建对象的过程：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1288-1024x263.png" alt="img"></p>
<p>如果使用直接内存创建对象的过程，就不需要进行复制对象，数据直接存放在直接内存中：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1289-1024x221.png" alt="img"></p>
<h4 id="3-6-1使用方法">3.6.1使用方法</h4>
<p>要创建直接内存上的数据，可以使用<code>ByteBuffer</code>。</p>
<p>语法： <code>ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);</code></p>
<p>注意事项： arthas的memory命令可以查看直接内存大小，属性名direct。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1290-1024x265.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter03.direct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存的使用和回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>; <span class="comment">//100mb</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ByteBuffer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//1.创建DirectByteBuffer对象并返回</span></span><br><span class="line">            <span class="comment">//2.在DirectByteBuffer构造方法中，向操作系统申请直接内存空间</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">directBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(size);</span><br><span class="line">            <span class="comment">//directBuffer = null;</span></span><br><span class="line"></span><br><span class="line">            list.add(directBuffer);</span><br><span class="line">            System.out.println(++count);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后，用arthas监控发现，每隔5秒直接内存会增长100M：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1291.png" alt="img"></p>
<p>如果将<code>Thread.</code><em><code>sleep</code></em><code>(5000);</code>注释掉，让直接内存快速大量分配。操作系统内存不足时就会报错：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1292.png" alt="img"></p>
<h4 id="3-6-2设置直接内存">3.6.2设置直接内存</h4>
<p>为了避免将内存耗尽，需要设置直接内存的最大值。如果需要手动调整直接内存的大小，可以使用<code>XX:MaxDirectMemorySize=大小</code></p>
<p>单位k或K表示千字节，m或M表示兆字节，g或G表示千兆字节。默认不设置该参数情况下，JVM 自动选择 最大分配的大小。</p>
<p>以下示例以不同的单位说明如何将 直接内存大小设置为 1024 KB：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:<span class="attribute">MaxDirectMemorySize</span>=1m</span><br><span class="line">-XX:<span class="attribute">MaxDirectMemorySize</span>=1024k</span><br><span class="line">-XX:<span class="attribute">MaxDirectMemorySize</span>=1048576</span><br></pre></td></tr></table></figure>
<p>在Idea中设置直接内存最大值为1g：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1293.png" alt="img"></p>
<h2 id="4、垃圾回收">4、垃圾回收</h2>
<p>在C/C++这类没有自动垃圾回收机制的语言中，一个对象如果不再使用，需要手动释放，否则就会出现内存泄漏。</p>
<p>内存泄漏指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致内存溢出。</p>
<p>我们称这种<strong>释放对象的过程为垃圾回收</strong>，而需要<strong>程序员编写代码进行回收的方式为手动回收</strong>。手动回收的方式相对来说回收比较及时，删除代码执行之后对象就被回收了，可以快速释放内存。缺点是对程序员要求比较高，很容易出现创建完对象之后，程序员忘记释放对象。</p>
<p>Java中为了简化对象的释放，引入了<strong>自动的垃圾回收（Garbage Collection简称GC</strong>）机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言比如C#、Python、Go都拥有自己的垃圾回收器。</p>
<p>垃圾回收器如果发现某个对象不再使用，就可以回收该对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1294-1024x351.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1295-1024x362.png" alt="img"></p>
<ul>
<li>自动垃圾回收，自动根据对象是否使用由虚拟机来回收对象
<ul>
<li>优点：降低程序员实现难度、降低对象回收bug的可能性</li>
<li>缺点：程序员无法控制内存回收的及时性</li>
</ul>
</li>
<li>手动垃圾回收，由程序员编程实现对象的删除
<ul>
<li>优点：回收及时性高，由程序员把控回收的时机</li>
<li>缺点：编写不当容易出现悬空指针、重复释放、内存泄漏等问题</li>
</ul>
</li>
</ul>
<p><strong>那么垃圾回收器需要负责对哪些部分的内存进行回收呢？</strong></p>
<p>首先是<strong>线程不共享的部分</strong>，都是伴随着线程的创建而创建，线程的销毁而销毁。而方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。所以这一部分不需要垃圾回收器负责回收。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1296.png" alt="img"></p>
<h3 id="4-1-方法区的回收">4.1 方法区的回收</h3>
<p>方法区中能回收的内容主要就是不再使用的类。</p>
<ul>
<li>了解即可，因为在实际开发中，很难同时满足三个条件。</li>
<li>因为，自己编写的类是由应用程序加载器加载，而这个加载器在运行过程中是不会被回收的,所以自己编写的类，只要被加载，就不会被回收</li>
</ul>
<p>判定一个类可以被卸载。需要<strong>同时满足下面三个条件</strong>：</p>
<p>1、此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。</p>
<p>这段代码中就将局部变量对堆上实例对象的引用去除了，所以对象就可以被回收。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1299.png" alt="img"></p>
<p>2、加载该类的类加载器已经被回收。</p>
<p>这段代码让局部变量对类加载器的引用去除，类加载器就可以回收。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1300-1024x190.png" alt="img"></p>
<p>3、该类对应的 java.lang.Class 对象没有在任何地方被引用。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1301.png" alt="img"></p>
<p><strong>如果需要手动触发垃圾回收，可以调用System.gc()方法。</strong></p>
<p>调用System.gc()方法并不一定会立即回收垃圾，仅仅向JAVA虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收Java虚拟机会自行判断。</p>
<p><strong>那么类卸载主要用在什么场景下呢？</strong></p>
<p>开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。</p>
<p>每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
<h3 id="4-2-如何判断对象可以回收">4.2 如何判断对象可以回收</h3>
<p>Java中的对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许被回收。</p>
<p>比如下面代码的内存结构图：</p>
<p>第一行代码执行之后，堆上创建了Demo类的实例对象，同时栈上保存局部变量引用堆上的对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1303-1024x326.png" alt="img"></p>
<p>第二行代码执行之后，局部变量对堆上的对象引用去掉，那么堆上的对象就可以被回收了。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1304-1024x327.png" alt="img"></p>
<p>一个更复杂的案例：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1305-1024x357.png" alt="img"></p>
<p>这个案例中，如果要让对象a和b回收，必须将局部变量到堆上的引用去除。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1306-1024x366.png" alt="img"></p>
<p>那么问题来了，A和B互相之间的引用需要去除吗？答案是不需要，因为局部变量都没引用这两个对象了，在代码中已经无法访问这两个对象，即便他们之间互相有引用关系，也不影响对象的回收。</p>
<p>判断对象是否可以回收，主要有两种方式：引用计数法和可达性分析法。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1307-1024x468.png" alt="img"></p>
<h4 id="4-2-1引用计数法">4.2.1引用计数法</h4>
<p>引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。</p>
<p>对象A的计数器初始为0，局部变量a1对它引用之后，计数器加1就变成了1。同样A对B产生了引用，B的计数器也是1。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1308-1024x409.png" alt="img"></p>
<p>优越点：</p>
<p>引用计数法的<strong>优点是实现简单</strong>，C++中的智能指针就采用了引用计数法，但是它也存在缺点，主要有两点：</p>
<ul>
<li>1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响</li>
<li>2.存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。</li>
</ul>
<p>如下图由于A和B之间存在互相引用，所以计数器都为1，两个对象都不能被回收。但是由于没有局部变量对这两个代码产生引用，代码中已经无法访问到这两个对象，理应可以被回收。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1309-1024x372.png" alt="img"></p>
<p>查看垃圾回收日志</p>
<p>如果想要查看垃圾回收的信息，可以使用<code>-verbose:gc</code>参数。</p>
<p>语法： <code>-verbose:gc</code></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1310-1024x258.png" alt="img"></p>
<p>加上这个参数之后执行代码，发现对象确实被回收了：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1313-1024x763.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1311.png" alt="img"></p>
<p>通过不同的死循环创建对象，内存并没有上升，一直维持在1000K,说明每轮循环创建的两个对象在垃圾回收之后都被回收了。即没有发生内存泄漏</p>
<h4 id="4-2-2可达性分析法">4.2.2可达性分析法</h4>
<p>Java使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的<strong>根对象（GC Root）<strong>和</strong>普通对象</strong>，对象与对象之间存在<strong>引用关系</strong>。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1314-1024x351.png" alt="img"></p>
<h5 id="哪些对象被称之为GC-Root对象呢？">哪些对象被称之为GC Root对象呢？</h5>
<p>1.线程Thread对象（创建线程之后，整个线程对象），引用线程栈帧中的方法参数、局部变量等。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1315.png" alt="img"></p>
<p>2.系统类加载器加载的java.lang.Class对象，引用类中的静态变量。</p>
<p>解释一下2：系统类加载器也就是应用程序类加载器，前面说到过，他是不可回收的，这个类加载器不会被回收，所以这个类也就不会被回收，那么这个类里面的静态变量也就不会被回收，所以就可以是GC root对象</p>
<p>Launcher包含应用程序类加载器和GC Root对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1316.png" alt="img"></p>
<p>3.监视器对象，用来保存同步锁synchronized关键字持有的对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1317-1024x289.png" alt="img"></p>
<p>4.本地方法调用时使用的全局对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1318.png" alt="img"></p>
<h5 id="查看GC-Root">查看GC Root</h5>
<p>通过arthas和eclipse Memory Analyzer工具可以查看GC Root，MAT工具是eclipse推出的Java堆内存检测工具。</p>
<p>1.使用arthas的heapdump命令可将内存快照保存到本地磁盘中。</p>
<p>2.使用MAT工具打开堆内存快照文件。</p>
<p>3.选择GC Roots功能查看所有的GC Root。</p>
<h3 id="4-3-常见的引用对象">4.3 常见的引用对象</h3>
<p>可达性算法中描述的对象引用，一般指的是<strong>强引用</strong>，即是GCRoot对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外，Java中还设计了几种其他引用方式：</p>
<ul>
<li><strong>软引用</strong></li>
<li><strong>弱引用</strong></li>
<li><strong>虚引用</strong></li>
<li><strong>终结器引用</strong></li>
</ul>
<h4 id="4-3-1软引用">4.3.1软引用</h4>
<p>如果一个对象只有软引用关联到它，<strong>当程序内存不足时</strong>，就会将软引用中的数据进行回收。在JDK 1.2版之后提供了SoftReference类来实现软引用，软引用常用于<strong>缓存</strong>中。</p>
<p>软引入的好处？</p>
<p>如果对象A是一个缓存，平时会保存在内存中，如果想访问数据可以快速访问。但是如果内存不够用了，我们就可以将这部分缓存清理掉释放内存。即便缓存没了，也可以从数据库等地方获取数据，不会影响到业务正常运行，这样可以减少内存溢出产生的可能性。</p>
<p><strong>特别注意：</strong></p>
<p><strong>软引用对象本身，也需要被强引用，否则软引用对象也会被回收掉</strong>。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1323-1024x464.png" alt="img"></p>
<h5 id="软引用的使用方法">软引用的使用方法</h5>
<p>软引用的执行过程如下：</p>
<p>1.将对象使用软引用包装起来，new SoftReference&lt;对象类型&gt;(对象)。</p>
<p>2.内存不足时，虚拟机尝试进行垃圾回收。</p>
<p>3.如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。</p>
<p>4.如果依然内存不足，抛出OutOfMemory异常。</p>
<p>把最大堆内存设置为200M，无法容纳2个100M的生成，所以当第2个100M生成时内存空间不足，会把软引用释放掉，所以第2次输出软引用的内容是null。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1325.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1324.png" alt="img"></p>
<p>软引用中的对象如果在内存不足时回收，SoftReferece对象本身也需要被回收。如何知道哪些SoftReference对象需要回收呢？（<strong>软引用（SoftReference）对象是如何被 GC 回收的，以及如何利用引用队列（ReferenceQueue）监控和清理的完整过程</strong>）</p>
<p>SoftReference提供了一套队列机制：<br>
1.软引用创建时，通过构造器传入引用队列。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1326-1024x356.png" alt="img"></p>
<p>2.在软引用中包含的对象被回收时，该软引用对象会被放入引用队列。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1327-1024x325.png" alt="img"></p>
<p>3.通过代码遍历引用队列，将SoftReference的强引用删除。</p>
<p>这个队列记录了内容为空的SoftReference，可以便利队列来释放空的SoftReference</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 软引用案例3 - 引用队列使用 */</span>publicclassSoftReferenceDemo3 &#123;</span><br><span class="line"></span><br><span class="line">    publicstaticvoidmain(String[] <span class="keyword">args</span>) throwsIOException &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;SoftReference&gt; softReferences = newArrayList&lt;&gt;();</span><br><span class="line">        ReferenceQueue&lt;<span class="built_in">byte</span>[]&gt; queues = newReferenceQueue&lt;<span class="built_in">byte</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] bytes = newbyte[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">            SoftReference studentRef = newSoftReference&lt;<span class="built_in">byte</span>[]&gt;(bytes,queues);</span><br><span class="line">            softReferences.<span class="keyword">add</span>(studentRef);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SoftReference&lt;<span class="built_in">byte</span>[]&gt; <span class="keyword">ref</span> = <span class="literal">null</span>;</span><br><span class="line">        intcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="keyword">ref</span> = (SoftReference&lt;<span class="built_in">byte</span>[]&gt;) queues.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步：创建软引用并绑定引用队列</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;<span class="built_in">byte</span>[]&gt; <span class="keyword">ref</span> = <span class="keyword">new</span> SoftReference&lt;&gt;(bytes, queues);</span><br></pre></td></tr></table></figure>
<ul>
<li>你把 <code>byte[]</code> 数据包装成了一个软引用；</li>
<li>同时绑定了一个引用队列 <code>queues</code>，表示一旦这个数据被回收了，你就能通过队列知道。</li>
</ul>
<p>第二步：GC 回收软引用指向的对象</p>
<p>由于你在 <code>for</code> 循环中分配了很多大内存：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">byte</span>[] bytes = new byte[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>]; // <span class="number">100</span>MB × <span class="number">10</span>次</span><br></pre></td></tr></table></figure>
<p>当 JVM 内存不够时，GC 就会触发，开始尝试回收这些 <code>byte[]</code> 对象——因为它们只是<strong>软引用</strong>，GC 是可以回收它们的。</p>
<p>一旦 GC 回收了这些 byte[] 对象，对应的 <code>SoftReference</code> 就会被加入 <code>queues</code> 队列！</p>
<p>第三步：程序从引用队列中轮询出已失效引用</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ref = (SoftReference&lt;<span class="keyword">byte</span>[]&gt;) queues.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">count</span>); <span class="comment">// 打印：9</span></span><br></pre></td></tr></table></figure>
<ul>
<li>遍历队列，把被回收通知了的软引用拿出来；</li>
<li>你可以手动把它们从 <code>ArrayList</code> 中删掉，释放 SoftReference 本身（否则软引用对象还会占内存）；</li>
<li>最终打印出有几个对象已经被 GC 回收并放入队列。</li>
</ul>
<p>最终输出是：<code>9</code></p>
<p>表示你创建的 10 个软引用中，有 9 个关联的 <code>byte[]</code> 被 GC 回收，通知已经进入队列。</p>
<p>最终展示的结果是：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1328.png" alt="img"></p>
<p>这9个软引用对象中包含的数据已经被回收掉，所以可以手动从ArrayList中去掉，这样就可以释放这9个对象。</p>
<p>一句话总结：软引用的对象被 GC 回收后，JVM 会自动把对应的 SoftReference 放入你提供的 ReferenceQueue 中，程序就可以从这个队列中感知到该软引用失效，从而主动清除引用本身，释放内存。</p>
<h5 id="软引用的缓存案例">软引用的缓存案例</h5>
<p>使用软引用实现学生信息的缓存，能支持内存不足时清理缓存。</p>
<p>设计一个 <code>StudentCache</code> 缓存类，用软引用保存大量 <code>Student</code> 对象的缓存。当内存不足时，JVM 可以自动释放缓存中不用的对象，避免内存溢出（OOM）。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1330.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1329-1024x435.png" alt="img"></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">packagechapter04.soft;</span><br><span class="line"></span><br><span class="line">importjava.lang.<span class="keyword">ref</span>.ReferenceQueue;</span><br><span class="line">importjava.lang.<span class="keyword">ref</span>.SoftReference;</span><br><span class="line">importjava.util.HashMap;</span><br><span class="line">importjava.util.Map;</span><br><span class="line"><span class="comment">/** * 软引用案例4 - 学生信息的缓存 */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StudentCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StudentCache cache= <span class="keyword">new</span> StudentCache();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            StudentCache.getInstance().cacheStudent(<span class="keyword">new</span> Student(i, String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, StudentRef&gt; StudentRefs;<span class="comment">// 用于Cache内容的存储</span></span><br><span class="line">   <span class="keyword">private</span> ReferenceQueue&lt;Student&gt; q;<span class="comment">// 垃圾Reference的队列</span></span><br><span class="line">   <span class="comment">// 继承SoftReference，使得每一个实例都具有可识别的标识。</span></span><br><span class="line">  <span class="comment">// 并且该标识与其在HashMap内的key相同。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">StudentRef</span> <span class="title">extends</span> <span class="title">SoftReference</span>&lt;<span class="title">Student</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Integer _key= <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StudentRef</span>(<span class="params">Student em, ReferenceQueue&lt;Student&gt; q</span>)</span> &#123;</span><br><span class="line">            super(em, q);</span><br><span class="line">            _key = em.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个缓存器实例</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">StudentCache</span>()</span> &#123;</span><br><span class="line">        StudentRefs = newHashMap&lt;Integer, StudentRef&gt;();</span><br><span class="line">        q = newReferenceQueue&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得缓存器实例</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentCache <span class="title">getInstance</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以软引用的方式对一个Student对象的实例进行引用并保存该引用  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheStudent</span>(<span class="params">Student em</span>)</span> &#123;</span><br><span class="line">        cleanCache();<span class="comment">// 清除垃圾引用</span></span><br><span class="line">       StudentRef <span class="keyword">ref</span> = <span class="keyword">new</span> StudentRef(em, q);</span><br><span class="line">        StudentRefs.put(em.getId(), <span class="keyword">ref</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(StudentRefs.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据所指定的ID号，重新获取相应Student对象的实例</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span>(<span class="params">Integer id</span>)</span> &#123;</span><br><span class="line">        Student em = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 缓存中是否有该Student实例的软引用，如果有，从软引用中取得。if(StudentRefs.containsKey(id)) &#123;</span></span><br><span class="line">            StudentRef <span class="keyword">ref</span> = StudentRefs.<span class="keyword">get</span>(id);</span><br><span class="line">            em = <span class="keyword">ref</span>.<span class="keyword">get</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，</span></span><br><span class="line"><span class="comment">// 并保存对这个新建实例的软引用</span></span><br><span class="line">           <span class="keyword">if</span>(em == <span class="literal">null</span>) &#123;</span><br><span class="line">            em = newStudent(id, String.valueOf(id));</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;Retrieve From StudentInfoCenter. ID=&quot;</span>+ id);</span><br><span class="line">            <span class="keyword">this</span>.cacheStudent(em);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> em;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除那些所软引用的Student对象已经被回收的StudentRef对象</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanCache</span>()</span> &#123;</span><br><span class="line">        StudentRef <span class="keyword">ref</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="keyword">ref</span> = (StudentRef) q.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            StudentRefs.<span class="keyword">remove</span>(<span class="keyword">ref</span>._key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 清除Cache内的全部内容</span></span><br><span class="line"><span class="comment">//    public void clearCache() &#123;</span></span><br><span class="line"><span class="comment">//        cleanCache();</span></span><br><span class="line"><span class="comment">//        StudentRefs.clear();</span></span><br><span class="line"><span class="comment">//        //System.gc();</span></span><br><span class="line"><span class="comment">//        //System.runFinalization();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id, String name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getId</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">publicvoid <span class="title">setId</span>(<span class="params">intid</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1331.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1332.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1333.png" alt="img"></p>
<p>一句话总结核心机制：</p>
<blockquote>
<p>利用 <code>SoftReference</code> + <code>ReferenceQueue</code> + <code>HashMap</code> 组合，实现了一个自动可回收的缓存系统，支持在内存紧张时释放不常用对象，且可感知对象被回收并做清理。</p>
</blockquote>
<h4 id="4-3-2弱引用（了解）">4.3.2弱引用（了解）</h4>
<p>弱引用的整体机制和软引用基本一致，<strong>区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收</strong>。在JDK 1.2版之后提供了WeakReference类来实现弱引用，<strong>弱引用主要在ThreadLocal中使用</strong>。</p>
<p>弱引用对象本身也可以使用引用队列进行回收。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">packagechapter04.weak;</span><br><span class="line"></span><br><span class="line">importjava.io.IOException;</span><br><span class="line">importjava.lang.<span class="keyword">ref</span>.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 弱引用案例 - 基本使用 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeakReferenceDemo2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>) throwsIOException</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">byte</span>[] bytes = newbyte[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">        WeakReference&lt;<span class="built_in">byte</span>[]&gt; weakReference = newWeakReference&lt;<span class="built_in">byte</span>[]&gt;(bytes);</span><br><span class="line">        bytes = <span class="literal">null</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(weakReference.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(weakReference.<span class="keyword">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之后发现gc执行之后，对象已经被回收了。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1334.png" alt="img"></p>
<h4 id="4-3-3虚引用和终结器引用（了解）">4.3.3虚引用和终结器引用（了解）</h4>
<p>这两种引用在常规开发中<strong>是不会使用的。</strong></p>
<ul>
<li>
<p>虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。<strong>虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知</strong>。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。</p>
</li>
<li>
<p>终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放置在Finalizer类中的引用队列中，在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，<strong>在对象第二次被回收时，该对象才真正的被回收</strong>。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">packagechapter04.finalreference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 终结器引用案例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeReferenceDemo reference = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alive</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;当前对象还存活&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>() throws Throwable</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;finalize()执行了...&quot;</span>);</span><br><span class="line">            <span class="comment">//设置强引用自救reference = this;</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicstaticvoidmain(String[] <span class="keyword">args</span>) throws Throwable &#123;</span><br><span class="line">        reference = <span class="keyword">new</span> FinalizeReferenceDemo();</span><br><span class="line">       test();</span><br><span class="line">       test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    privatestaticvoidtest() throws InterruptedException &#123;</span><br><span class="line">        reference = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//回收对象System.gc();</span></span><br><span class="line">        <span class="comment">//执行finalize方法的优先级比较低，休眠500ms等待一下Thread.sleep(500);</span></span><br><span class="line">        <span class="keyword">if</span>(reference != <span class="literal">null</span>) &#123;</span><br><span class="line">            reference.alive();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;对象已被回收&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1335.png" alt="img"></p>
<h3 id="4-4-垃圾回收算法">4.4 垃圾回收算法</h3>
<p>Java是如何实现垃圾回收的呢？简单来说，垃圾回收要做的有两件事：</p>
<ul>
<li>1、找到内存中存活的对象</li>
<li>2、释放不再存活对象的内存，使得程序能再次利用这部分空间</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1353-1024x235.png" alt="img"></p>
<h4 id="4-4-1垃圾回收算法的评价标准">4.4.1垃圾回收算法的评价标准</h4>
<p>Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所有的用户线程。这个过程被称之为Stop The World简称STW，如果STW时间过长则会影响用户的使用。</p>
<p>如下图，用户代码执行和垃圾回收执行让用户线程停止执行（STW）是交替执行的。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1336-1024x182.png" alt="img"></p>
<p>所以判断GC算法是否优秀，可以从三个方面来考虑：</p>
<p>1.吞吐量</p>
<p>吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1337-1024x237.png" alt="img"></p>
<p>2.最大暂停时间</p>
<p>最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值。比如如下的图中，黄色部分的STW就是最大暂停时间，显而易见上面的图比下面的图拥有更少的最大暂停时间。最大暂停时间越短，用户使用系统时受到的影响就越短。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1338-1024x311.png" alt="img"></p>
<p>3.堆使用效率</p>
<p>不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。</p>
<p>上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间不可兼得。</p>
<p>一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1339.png" alt="img"></p>
<p>没有一个垃圾回收算法能兼顾上述三点评价标准，所以不同的垃圾回收算法它的侧重点是不同的，适用于不同的应用场景。</p>
<h4 id="4-4-2标记清除算法">4.4.2标记清除算法</h4>
<p>标记清除算法的核心思想分为两个阶段：</p>
<p>1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。</p>
<p>2.清除阶段，从内存中删除没有被标记也就是非存活对象。</p>
<p>第一个阶段，从GC Root对象开始扫描，将对象A、B、C在引用链上的对象标记出来：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1340-1024x375.png" alt="img"></p>
<p>第二个阶段，将没有标记的对象清理掉，所以对象D就被清理掉了。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1341-1024x372.png" alt="img"></p>
<p>优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。</p>
<p>缺点：1.碎片化问题</p>
<p>由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。</p>
<p>如下图，红色部分已经被清理掉了，总共回收了9个字节，但是每个都是一个小碎片，无法为5个字节的对象分配空间。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1342-1024x351.png" alt="img"></p>
<p>缺点2.分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。 我们需要用一个链表来维护，哪些空间可以分配对象，很有可能需要遍历这个链表到最后，才能发现这块空间足够我们去创建一个对象。如下图，遍历到最后才发现有足够的空间分配3个字节的对象了。如果链表很长，遍历也会花费较长的时间。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1343-1024x290.png" alt="img"></p>
<h4 id="4-4-3复制算法">4.4.3复制算法</h4>
<p>复制算法的核心思想是：</p>
<p>1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。</p>
<p>对象A首先分配在From空间：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1344-1024x300.png" alt="img"></p>
<p>2.在垃圾回收GC阶段，将From中存活对象复制到To空间。</p>
<p>在垃圾回收阶段，如果对象A存活，就将其复制到To空间。然后将From空间直接清空。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1345-1024x312.png" alt="img"></p>
<p>3.将两块空间的From和To名字互换。</p>
<p>接下来将两块空间的名称互换，下次依然在From空间上创建对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1346-1024x306.png" alt="img"></p>
<p>完整的复制算法的例子：</p>
<p>1.将堆内存分割成两块From空间 To空间，对象分配阶段，创建对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1347-1024x296.png" alt="img"></p>
<p>2.GC阶段开始，将GC Root搬运到To空间</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1348-1024x304.png" alt="img"></p>
<p>3.将GC Root关联的对象，搬运到To空间</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1349-1024x307.png" alt="img"></p>
<p>4.清理From空间，并把名称互换</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1350-1024x296.png" alt="img"></p>
<p>优点：</p>
<ul>
<li>吞吐量高，复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动</li>
<li>不会发生碎片化，复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。</li>
</ul>
<p>缺点：</p>
<p>内存使用效率低，每次只能让一半的内存空间来为创建对象使用。</p>
<h4 id="4-4-4标记整理算法">4.4.4标记整理算法</h4>
<p>标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。</p>
<p>核心思想分为两个阶段：</p>
<p>1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。</p>
<p>2.整理阶段，将存活对象移动到堆的一端。是清理非存活对象的内存空间</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1351-1024x238.png" alt="img"></p>
<p>优点：</p>
<ul>
<li>内存使用效率高，整个堆内存都可以使用，不会像复制算法只能使用半个堆内存</li>
<li>不会发生碎片化，在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间</li>
</ul>
<p>缺点：</p>
<p>整理阶段的效率不高，整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过Two-Finger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能。</p>
<h4 id="4-4-5分代垃圾回收算法">4.4.5分代垃圾回收算法</h4>
<p>分代垃圾回收算法是现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法（Generational GC）。</p>
<p>分代垃圾回收将整个内存区域划分为年轻代和老年代：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1352-1024x366.png" alt="img"></p>
<p>在JDK8中，添加-XX:+UseSerialGC参数使用分代回收的垃圾回收器，运行程序。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1355-1024x638.png" alt="img"></p>
<p>可以通过memory命令来查看内存</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1354-1024x228.png" alt="img"></p>
<p>Eden + survivor 这两块区域组成了年轻代。</p>
<p>tenured_gen指的是晋升区域，其实就是老年代。</p>
<p>1、分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1356-1024x332.png" alt="img"></p>
<p>2、随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发<strong>年轻代的GC</strong>，称为Minor GC或者Young GC。</p>
<p><strong>Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。</strong></p>
<p>eden[首次]满时，会触发垃圾回收，根据可达性判断存活的对象，将存活的对象复制到某个幸存区（假设为From区），同时Eden区清空。当后续eden再满时，就会将eden和From区的对象进行回收然后将幸存的对象复制到To区。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1357-1024x359.png" alt="img"></p>
<p>3、接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1358-1024x366.png" alt="img"></p>
<p>此时会回收<strong>eden区和S1(from)中的对象</strong>，并把eden和from区中剩余的对象放入S0。</p>
<p>注意：每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。</p>
<p>4、如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1359-1024x360.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1360-1024x350.png" alt="img"></p>
<p>当整个新生代的空间都被使用时，无法放入新的对象时，先尝试Minor GC，把未达到年龄阈值但是最老的对象放入老年代，如果老年代空间也被占满了，会触发Full GC（回收整个堆的所有对象）</p>
<p>一个长时间运行的应用可能积累了许多长生命周期的对象，导致老年代逐渐填满，即使新生代并未完全填满，JVM也可能触发Full GC来清理老年代</p>
<p>如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。</p>
<p>至于为什么不会被回收：因为这里的回收条件依然要满足可达性分析，如果不满足，是不能被回收的</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1361-1024x362.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1362-1024x294.png" alt="img"></p>
<h3 id="4-5-垃圾回收器">4.5 垃圾回收器</h3>
<h4 id="4-5-1为什么分代GC算法要把堆分成年轻代和老年代？">4.5.1为什么分代GC算法要把堆分成年轻代和老年代？</h4>
<p>首先我们要知道堆内存中对象的特性：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1363-1024x532.png" alt="img"></p>
<ul>
<li>系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。</li>
<li>老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。</li>
<li>在虚拟机的默认设置中，新生代大小要远小于老年代的大小。</li>
</ul>
<p>分代GC算法将堆分成年轻代和老年代主要原因有：</p>
<ul>
<li>1、可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。</li>
<li>2、新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。</li>
<li>3、分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW时间就会减少。</li>
</ul>
<p>-----------------------------------------------------------------------------------------------------------</p>
<p>垃圾回收器是垃圾回收算法的具体实现。</p>
<h4 id="4-5-2垃圾回收器组合关系">4.5.2垃圾回收器组合关系</h4>
<p>由于垃圾回收器分为年轻代和老年代，<strong>除了G1之外其他垃圾回收器必须成对组合进行使用。</strong></p>
<p>具体的关系图如下：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1364-1024x367.png" alt="img"></p>
<h4 id="4-5-3Serial和Serial-Old的组合">4.5.3Serial和Serial Old的组合</h4>
<h5 id="年轻代-Serial垃圾回收器">年轻代-Serial垃圾回收器</h5>
<p>Serial是一种<strong>单线程串行回收</strong>年轻代的垃圾回收器。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1365.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1366-1024x131.png" alt="img"></p>
<h5 id="老年代-SerialOld垃圾回收器">老年代-SerialOld垃圾回收器</h5>
<p>SerialOld是Serial垃圾回收器的老年代版本，采用<strong>单线程串行回收</strong></p>
<p>-XX:+UseSerialGC 新生代、老年代都使用串行回收器。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1368.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1367-1024x151.png" alt="img"></p>
<h4 id="4-5-4ParNew和CMS的组合">4.5.4ParNew和CMS的组合</h4>
<h5 id="年轻代-ParNew垃圾回收器">年轻代-ParNew垃圾回收器</h5>
<p>ParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用<strong>多线程</strong>进行垃圾回收</p>
<p>-XX:+UseParNewGC 新生代使用ParNew回收器， 老年代使用串行回收器</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1369.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1370-1024x134.png" alt="img"></p>
<h5 id="老年代-CMS-Concurrent-Mark-Sweep-垃圾回收器-JDK14废弃">老年代- CMS(Concurrent Mark Sweep)垃圾回收器(JDK14废弃)</h5>
<p>CMS垃圾回收器关注的是系统的<strong>暂停时间</strong>，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。</p>
<p>参数：XX:+UseConcMarkSweepGC</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1372.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1373-1024x164.png" alt="img"></p>
<p>CMS执行步骤：</p>
<p>1.初始标记，用极短的时间标记出GC Roots能直接关联到的对象。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1374.png" alt="img"></p>
<p>2.并发标记, 标记所有的对象，用户线程不需要暂停。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1375.png" alt="img"></p>
<p>3.重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1376.png" alt="img"></p>
<p>4.并发清理，清理死亡的对象，用户线程不需要暂停。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1377-1024x277.png" alt="img"></p>
<p>也就是说只有两个阶段会产生STW，一个是初始标记阶段一个是重新标记阶段，但这两个停顿时间会短一些(并发标记时间比较长 重新标记只是找错漏情况 会比较短)</p>
<p><strong>缺点：</strong></p>
<p>1、CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）调整N次Full GC之后再整理。</p>
<p>2.、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。(浮动垃圾（Floating Garbage） 是指：在 CMS 的并发标记阶段，应用线程继续运行期间新产生的、后来变成不可达的对象，但 CMS 没有标记到它们。这些对象在这一轮 GC 中被“遗漏”了，因此不会被回收，直到下一次GC才有机会被清理</p>
<p>3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。</p>
<h4 id="4-5-5Parallel-Scavenge-和Parallel-Old的组合（JDK8默认组合）">4.5.5Parallel Scavenge 和Parallel Old的组合（JDK8默认组合）</h4>
<h5 id="年轻代-Parallel-Scavenge垃圾回收器">年轻代-Parallel Scavenge垃圾回收器</h5>
<p>Parallel Scavenge是<strong>JDK8默认的年轻代垃圾回收器</strong>，多线程并行回收，关注的是系统的吞吐量。具备<strong>自动调整堆内存大小</strong>的特点。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1378.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1379-1024x163.png" alt="img"></p>
<p><strong>常用参数：</strong></p>
<p>Parallel Scavenge允许手动设置最大暂停时间和吞吐量。Oracle官方建议在使用这个组合时，不要设置堆内存的最大值，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小。</p>
<ul>
<li>最大暂停时间，<code>-XX:MaxGCPauseMillis=n</code> 设置每次垃圾回收时的最大停顿毫秒数</li>
<li>吞吐量，<code>-XX:GCTimeRatio=n</code> 设置吞吐量为n（用户线程执行时间 = n/n + 1）</li>
<li><strong>自动调整内存大小</strong>, <code>-XX:+UseAdaptiveSizePolicy</code>设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小</li>
</ul>
<p>吞吐量的值默认99（用户线程执行99%时间，垃圾回收线程1%）</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1390-1024x58.png" alt="img"></p>
<p>最大暂停时间默认值(非常大，基本任何时间都满足，相对于没有限制最大暂停时间)</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1391-1024x61.png" alt="img"></p>
<h5 id="老年代-Parallel-Old垃圾回收器">老年代-Parallel Old垃圾回收器</h5>
<p>Parallel Old是为Parallel Scavenge收集器设计的老年代版本，利用多线程并行收集。</p>
<p>参数： -XX:+UseParallelGC 或</p>
<p>-XX:+UseParallelOldGC可以使用Parallel Scavenge + Parallel Old这种组合。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1380.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1382-1024x141.png" alt="img"></p>
<h4 id="G1垃圾回收器（JDK9之后默认的垃圾回收器）">G1垃圾回收器（JDK9之后默认的垃圾回收器）</h4>
<p>JDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器。Parallel Scavenge关注吞吐量，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小。CMS关注暂停时间，但是吞吐量方面会下降。</p>
<p>而G1设计目标就是将上述两种垃圾回收器的优点融合：</p>
<ul>
<li>1.支持巨大的堆空间回收，并有较高的吞吐量。</li>
<li>2.支持多CPU并行垃圾回收。</li>
<li>3.允许用户设置最大暂停时间。</li>
</ul>
<p>JDK9之后强烈建议使用G1垃圾回收器。</p>
<p>G1出现之前的垃圾回收器，年轻代和老年代一般是连续的，如下图：</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1383-1024x332.png" alt="img"></p>
<p>G1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域<strong>不要求是连续的</strong>。分为Eden、Survivor、Old区。Region的大小通过堆空间大小/2048计算得到，也可以通过参数-XX:G1HeapRegionSize=32m指定(其中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1384.png" alt="img"></p>
<p>G1垃圾回收有两种方式：</p>
<p>1、年轻代回收（Young GC）</p>
<p>2、混合回收（Mixed GC）</p>
<h5 id="年轻代回收">年轻代回收</h5>
<p>年轻代回收（Young GC），回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数</p>
<p>-XX:MaxGCPauseMillis=n（默认200） 设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间。</p>
<p>1、新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%即占年轻代设置大小的60%），无法分配对象时需要回收时会执行Young GC。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1385.png" alt="img"></p>
<p>2、标记出Eden和Survivor区域中的存活对象，</p>
<p>3、根据配置的最大暂停时间选择某些区域将<strong>存活对象</strong>复制到一个新的Survivor区中（年龄+1），清空这些区域。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1386.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1387.png" alt="img"></p>
<p>G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。</p>
<p>比如 -XX:MaxGCPauseMillis=n（默认200），每个Region回收耗时40ms，那么这次回收最多只能回收4个Region。</p>
<p>4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1388.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1389.png" alt="img"></p>
<p>5、当某个存活对象的年龄到达阈值（默认15），将被放入老年代。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1392.png" alt="img"></p>
<p>6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1393.png" alt="img"></p>
<p>7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时</p>
<p>（-XX:InitiatingHeapOccupancyPercent默认45%）会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1394.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1395-1024x558.png" alt="img"></p>
<h5 id="混合回收">混合回收</h5>
<p>混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize Marking）、并发清理（cleanup）</p>
<p><strong>G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高</strong>，这也是G1（Garbage first）名称的由来。最后清理阶段使用复制算法，不会产生内存碎片。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1396-1024x322.png" alt="img"></p>
<p>混合回收的步骤：</p>
<ul>
<li>1、初始标记，STW，采用三色标记法标记从GC Root可直达的对象。 STW时间极短。</li>
<li>2、并发标记，并发执行，对存活对象进行标记。</li>
<li>3、最终标记，STW，处理SATB相关的对象标记。 STW时间极短。</li>
<li>4、清理，STW，如果区域中没有任何存活对象就直接清理。 STW时间极短。</li>
<li>5、转移，将存活对象复制到别的区域。 STW时间较长。</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1397-1024x380.png" alt="img"></p>
<p>注意：如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法，此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1398.png" alt="img"></p>
<h4 id="4-5-6G1-–-Garbage-First-垃圾回收器（相关参数）">4.5.6G1 – Garbage First 垃圾回收器（相关参数）</h4>
<p>参数1： <code>-XX:+UseG1GC</code> 打开G1的开关，JDK9之后默认不需要打开</p>
<p>参数2：<code>-XX:MaxGCPauseMillis=毫秒值</code> 最大暂停的时间</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1400.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1399-1024x136.png" alt="img"></p>
<p>使用以下代码测试g1垃圾回收器，打印出每个阶段的时间:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">packagechapter04.gc;</span><br><span class="line"></span><br><span class="line">importjava.io.IOException;</span><br><span class="line">importjava.util.ArrayList;</span><br><span class="line">importjava.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 垃圾回收器案例3 */</span></span><br><span class="line"> <span class="comment">//-XX:+UseG1GC   -Xmn8g -Xmx16g -XX:SurvivorRatio=8  -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GcDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>) throws IOException</span> &#123;</span><br><span class="line">        intcount = <span class="number">0</span>;</span><br><span class="line">        List&lt;Object&gt; list = newArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(++count);if(count++ % 10240 == 0)&#123;</span></span><br><span class="line">                list.clear();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            byte[] bytes = new byte[1024 * 1024 * 1];</span></span><br><span class="line">               list.<span class="keyword">add</span>(newbyte[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span> / <span class="number">2</span>]);</span><br><span class="line"><span class="comment">//            System.gc();&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个region大小为2m，一共有84个young区，26个幸存者区。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1401.png" alt="img"></p>
<p>初始标记花了0.0478秒。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1402.png" alt="img"></p>
<p>并发标记总共耗时10ms，不会产生STW。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1403.png" alt="img"></p>
<h4 id="4-5-7总结">4.5.7总结</h4>
<p>垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下：</p>
<p>JDK8及之前：</p>
<p>ParNew + CMS（关注暂停时间）、Parallel Scavenge + Parallel Old (关注吞吐量)、 G1（JDK8之前不建议，较大堆并且关注暂停时间）</p>
<p>JDK9之后:</p>
<p>G1（默认）</p>
<p>从JDK9之后，由于G1日趋成熟，JDK默认的垃圾回收器已经修改为G1，所以强烈建议在生产环境上使用G1。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1404-1024x517.png" alt="img"></p>
<p>对于线程不共享的程序计数器和栈空间来说，它会伴随着线程的创建而创建，跟着线程的回收而回收</p>
<p>对于线程共享的两部分方法区和堆来说，方法区一般不需要回收，在特定的某些技术如JSP等技术会通过回收类加载器去回收方法区的类，但一般对于程序员来说这块很少关注；堆则会有垃圾回收器来负责回收</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1406-1024x204.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1405.png" alt="img"></p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1407-1024x396.png" alt="img"></p>
<p>标记-清除算法：标记之后再清除，容易产生内存碎片</p>
<p>复制算法：从一块区域复制到另一块区域容易造成只能使用一部分内存，对内存的使用率会下降</p>
<p>标记-整理算法：标记之后将存活的对象推到一边，对象会移动，效率不高</p>
<p>分代GC算法:将内存区域划分为年轻代、幸存者区、老年代进行回收、可以使用多种回收算法</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/06/image-1408-1024x469.png" alt="img"></p>
<p>Serial和Serial Old的组合：单线程回收，主要适用于单核CPU场景</p>
<p>ParNew和CMS的组合:暂停时间较短，适用于大型互联网应用中与用户交互的部分（创建订单，查询商品信息），但还需注意CMS的缺点</p>
<p>Parallel Scavenge 和Parallel Old的组合：吞吐量高，适用于后台进行大量数据操作</p>
<p>G1垃圾回收器：适用于较大的堆，具有可控的暂停时间</p>
<h1 id="基础篇完结">基础篇完结</h1>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>JVM基础篇</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://itgeqian.github.io/posts/8.html">https://itgeqian.github.io/posts/8.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>geqian's Blog🍭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-06-15</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-06-18</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>JVM</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1PAY.jpg" target="_blank"><img class="post-qr-code-img" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1PAY.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E6%94%AF%E4%BB%98%E5%AE%9DPAY.jpg" target="_blank"><img class="post-qr-code-img" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E6%94%AF%E4%BB%98%E5%AE%9DPAY.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/10.html"><img class="prev-cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaWeb+AI（基础篇）</div></div></a></div><div class="next-post pull-right"><a href="/posts/9.html"><img class="next-cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mysql基础篇</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%88%9D%E5%A7%8BJVM"><span class="toc-text">1、初始JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFJVM"><span class="toc-text">1.1 什么是JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-JVM%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">1.2 JVM的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E8%A7%A3%E9%87%8A%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-text">1.2.1 解释和运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">1.2.2 内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91"><span class="toc-text">1.2.3 即时编译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E5%B8%B8%E8%A7%81%E7%9A%84JVM"><span class="toc-text">1.3常见的JVM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.字节码文件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">2.1 Java虚拟机的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">2.2字节码文件的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A7%BF%E5%8A%BF%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-text">以正确的姿势打开文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-text">1.基本信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Magic%E9%AD%94%E6%95%B0"><span class="toc-text">Magic魔数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%89%AF%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">主副版本号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF"><span class="toc-text">其他基础信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9A-%E4%BF%9D%E5%AD%98%E4%BA%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%EF%BC%8C%E7%B1%BB%E6%88%96%E6%8E%A5%E5%8F%A3%E5%90%8D%EF%BC%8C%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%BB%E8%A6%81%E5%9C%A8%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E4%B8%AD%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-text">2.**常量池：**保存了字符串常量，类或接口名，字段名主要在字节码指令中使用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E6%AE%B5%EF%BC%9A-%E5%BD%93%E5%89%8D%E7%B1%BB%E6%88%96%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF%E3%80%82"><span class="toc-text">3.**字段：**当前类或接口声明的字段信息。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%EF%BC%9A-%E5%BD%93%E5%89%8D%E7%B1%BB%E6%88%96%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E%E7%9A%84%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E3%80%82"><span class="toc-text">4.**方法：**当前类或接口声明的方法信息字节码指令。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i-%E4%B8%8E-i"><span class="toc-text">i++与++i</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B1%9E%E6%80%A7%EF%BC%9A-%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%AF%94%E5%A6%82%E6%BA%90%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%97%E8%A1%A8%E7%AD%89%E3%80%82"><span class="toc-text">5.**属性：**类的属性，比如源码的文件名内部类的列表等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8"><span class="toc-text">字节码文件常见工具使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-text">2.3类的生命周期加载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-text">2.3.1加载阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="toc-text">2.3.2 连接阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-text">2.3.3初始化阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clinit%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">clinit不会执行的几种情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E6%80%BB%E7%BB%93"><span class="toc-text">2.3.4类的声明周期总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2.4类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">2.4.1什么是类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2.4.2类加载器的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Bootstrap-ClassLoader%EF%BC%89"><span class="toc-text">2.4.3启动类加载器（Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Extension-ClassLoader-%E5%92%8C-Application-ClassLoader%EF%BC%89"><span class="toc-text">2.4.4扩展类加载器和应用程序类加载器（Extension ClassLoader 和 Application ClassLoader）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">2.5、双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1%E6%A1%88%E4%BE%8B1%EF%BC%9A"><span class="toc-text">2.5.1案例1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2%E6%A1%88%E4%BE%8B2%EF%BC%9A"><span class="toc-text">2.5.2案例2：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2.5.3双亲委派机制的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="toc-text">2.5.4如何指定加载类的类加载器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5%E4%B8%89%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">2.5.5三个面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">2.6打破双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1%E6%89%93%E7%A0%B4%E7%B1%BB%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">2.6.1打破类的双亲委派机制 自定义类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%88%B6%E7%B1%BB%E6%80%8E%E4%B9%88%E6%98%AFAppClassLoader%E5%91%A2%EF%BC%9F"><span class="toc-text">自定义类加载器父类怎么是AppClassLoader呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%9B%B8%E5%90%8C%E9%99%90%E5%AE%9A%E5%90%8D%E7%9A%84%E7%B1%BB%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%86%B2%E7%AA%81%E5%90%97%EF%BC%9F"><span class="toc-text">两个自定义类加载器加载相同限定名的类，不会冲突吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E5%85%B3%E4%BA%8EloadClass%E5%92%8CfindClass"><span class="toc-text">补充：关于loadClass和findClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2%E6%89%93%E7%A0%B4%E7%B1%BB%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">2.6.2打破类的双亲委派机制 线程上下文类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDBC%E6%A1%88%E4%BE%8B%E4%B8%AD%E7%9C%9F%E7%9A%84%E6%89%93%E7%A0%B4%E4%BA%86%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F"><span class="toc-text">JDBC案例中真的打破了双亲委派机制吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3%E6%89%93%E7%A0%B4%E7%B1%BB%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6-osgi%E5%92%8C%E7%B1%BB%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-text">2.6.3打破类的双亲委派机制 osgi和类的热部署</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8Carthas%E4%B8%8D%E5%81%9C%E6%9C%BA%E8%A7%A3%E5%86%B3%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98"><span class="toc-text">案例：使用阿里arthas不停机解决线上问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E3%80%81JDK9%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">2.7、JDK9之后的类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-text">3、运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">3.1 程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%90%97%EF%BC%9F"><span class="toc-text">程序计数器会出现内存溢出吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">3.2Java虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text">3.2.1局部变量表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-text">3.2.2操作数栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3%E5%B8%A7%E6%95%B0%E6%8D%AE"><span class="toc-text">3.2.3帧数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">3.2.4栈内存溢出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">3.3本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-text">3.4 堆内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E6%BA%A2%E5%87%BA"><span class="toc-text">3.4.1堆内存的溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%80%BC"><span class="toc-text">3.4.2三个重要的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3%E8%AE%BE%E7%BD%AE%E5%A0%86%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">3.4.3设置堆的大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">3.5 方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1%E7%B1%BB%E7%9A%84%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-text">3.5.1类的元信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">3.5.2运行时常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.5.3方法区的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BA%A2%E5%87%BA"><span class="toc-text">3.5.4方法区的溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">3.5.5字符串常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">字符串常量池和运行时常量池有什么关系？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringTable%E7%9A%84%E7%BB%83%E4%B9%A0%E9%A2%981%EF%BC%9A"><span class="toc-text">StringTable的练习题1：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringTable%E7%9A%84%E7%BB%83%E4%B9%A0%E9%A2%982%EF%BC%9A"><span class="toc-text">StringTable的练习题2：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#intern%E6%96%B9%E6%B3%95"><span class="toc-text">intern方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-6%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%E5%91%A2%EF%BC%9F"><span class="toc-text">3.5.6面试题：静态变量存储在哪里呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">3.6 直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3.6.1使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2%E8%AE%BE%E7%BD%AE%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">3.6.2设置直接内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">4、垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-text">4.1 方法区的回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-text">4.2 如何判断对象可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">4.2.1引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-text">4.2.2可达性分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E8%A2%AB%E7%A7%B0%E4%B9%8B%E4%B8%BAGC-Root%E5%AF%B9%E8%B1%A1%E5%91%A2%EF%BC%9F"><span class="toc-text">哪些对象被称之为GC Root对象呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BGC-Root"><span class="toc-text">查看GC Root</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.3 常见的引用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-text">4.3.1软引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">软引用的使用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%A1%88%E4%BE%8B"><span class="toc-text">软引用的缓存案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">4.3.2弱引用（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3%E8%99%9A%E5%BC%95%E7%94%A8%E5%92%8C%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">4.3.3虚引用和终结器引用（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">4.4 垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86"><span class="toc-text">4.4.1垃圾回收算法的评价标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">4.4.2标记清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">4.4.3复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">4.4.4标记整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">4.4.5分代垃圾回收算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">4.5 垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E4%BB%A3GC%E7%AE%97%E6%B3%95%E8%A6%81%E6%8A%8A%E5%A0%86%E5%88%86%E6%88%90%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-text">4.5.1为什么分代GC算法要把堆分成年轻代和老年代？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-text">4.5.2垃圾回收器组合关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3Serial%E5%92%8CSerial-Old%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-text">4.5.3Serial和Serial Old的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3-Serial%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">年轻代-Serial垃圾回收器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3-SerialOld%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">老年代-SerialOld垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4ParNew%E5%92%8CCMS%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-text">4.5.4ParNew和CMS的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3-ParNew%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">年轻代-ParNew垃圾回收器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3-CMS-Concurrent-Mark-Sweep-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-JDK14%E5%BA%9F%E5%BC%83"><span class="toc-text">老年代- CMS(Concurrent Mark Sweep)垃圾回收器(JDK14废弃)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-5Parallel-Scavenge-%E5%92%8CParallel-Old%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%88JDK8%E9%BB%98%E8%AE%A4%E7%BB%84%E5%90%88%EF%BC%89"><span class="toc-text">4.5.5Parallel Scavenge 和Parallel Old的组合（JDK8默认组合）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3-Parallel-Scavenge%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">年轻代-Parallel Scavenge垃圾回收器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3-Parallel-Old%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">老年代-Parallel Old垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88JDK9%E4%B9%8B%E5%90%8E%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%89"><span class="toc-text">G1垃圾回收器（JDK9之后默认的垃圾回收器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-text">年轻代回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="toc-text">混合回收</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-6G1-%E2%80%93-Garbage-First-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-text">4.5.6G1 – Garbage First 垃圾回收器（相关参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-7%E6%80%BB%E7%BB%93"><span class="toc-text">4.5.7总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87%E5%AE%8C%E7%BB%93"><span class="toc-text">基础篇完结</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By geqian's Blog🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20230913" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20230913号"><img src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/20230913.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 geqianの学习笔记 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/杂项/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 geqianの杂项 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/JVM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍜 geqianのJUC (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/学习笔记/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🏛️ geqianの前端工程 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/SSM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📖 geqianのSSM+SpringBoot系列 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/学习笔记/SSM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📖 geqianのSSM+SpringBoot系列 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/mysql/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">❓ geqianのmysql (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/Redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💖 geqianのRedis (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://itgeqian.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1.html&quot;);" href="javascript:void(0);" alt="">实验三 汽车租赁系统的UML设计建模 （完结）</a><div class="blog-slider__text">关于汽车租赁系统的UML设计建模</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2.html&quot;);" href="javascript:void(0);" alt="">GQ Video项目部署</a><div class="blog-slider__text">微服务项目GQ Video项目部署</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>