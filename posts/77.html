<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>javase+集合相关面试题 | geqian's Blog🍭</title><meta name="keywords" content="javase+集合"><meta name="author" content="geqian's Blog🍭"><meta name="copyright" content="geqian's Blog🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="我对java基础和集合类的相关理解">
<meta property="og:type" content="article">
<meta property="og:title" content="javase+集合相关面试题">
<meta property="og:url" content="https://itgeqian.github.io/posts/77.html">
<meta property="og:site_name" content="geqian&#39;s Blog🍭">
<meta property="og:description" content="我对java基础和集合类的相关理解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/31.jpg">
<meta property="article:published_time" content="2025-10-07T00:19:03.000Z">
<meta property="article:modified_time" content="2025-10-20T03:42:00.000Z">
<meta property="article:author" content="geqian&#39;s Blog🍭">
<meta property="article:tag" content="javase+集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/31.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://itgeqian.github.io/posts/77"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javase+集合相关面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-20 11:42:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><script src="https://cdn.jsdelivr.net/npm/echarts@6/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="geqian's Blog🍭" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.png" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">geqian's Blog🍭</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">javase+集合相关面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2025-10-07T00:19:03.000Z" title="发表于 2025-10-07 08:19:03">2025-10-07</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-20T03:42:00.000Z" title="更新于 2025-10-20 11:42:00">2025-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="javase+集合相关面试题"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="GQ八股-Java基础-集合">GQ八股-Java基础+集合</h1>
<h2 id="java基础">java基础</h2>
<h3 id="Java中的序列化和反序列化是什么？"><strong>Java中的序列化和反序列化是什么？</strong></h3>
<p><strong>序列化</strong>：指将一个对象转化为字节流的过程，通常用于存储或者通过网络传输。<code>ObjectOutputStream</code>用于将对象序列化。</p>
<p><strong>反序列化</strong>：指将字节流还原为原始对象的过程，使用<code>ObjectInputStream</code>来实现。</p>
<p><strong>关键要求</strong>：</p>
<ol>
<li><strong>Serializable接口</strong>：类必须实现<code>Serializable</code>接口，才能被序列化。</li>
<li><strong>transient关键字</strong>：标记为<code>transient</code>的字段会被序列化时忽略。</li>
<li><strong>serialVersionUID</strong>：每个类应定义<code>serialVersionUID</code>，用于验证序列化和反序列化版本一致性。</li>
<li><strong>性能与安全</strong>：序列化可能导致性能下降，同时反序列化存在安全风险（例如反序列化攻击），因此需要对输入数据进行验证。</li>
<li><strong>静态变量</strong>：静态变量不会被序列化，因为它们与实例无关。</li>
</ol>
<p>总结：序列化和反序列化为Java对象的存储和传输提供了便利，但需要关注性能和安全性问题。</p>
<h3 id="Exception-和-Error-的区别">Exception 和 Error 的区别</h3>
<p>Exception 和 Error 都是 Throwable 的子类，<br>
区别在于：</p>
<ul>
<li><strong>Exception</strong> 表示程序可以处理的异常，比如业务逻辑错误、文件找不到等。</li>
<li><strong>Error</strong> 表示系统层面的严重错误，比如内存溢出（OutOfMemoryError）或栈溢出（StackOverflowError），程序一般无法恢复。</li>
</ul>
<p>Exception 又分为两类：</p>
<ul>
<li><strong>Checked Exception</strong>（受检异常）：编译期必须处理，比如 IOException；</li>
<li><strong>Unchecked Exception</strong>（运行时异常）：运行期才抛出，比如 NullPointerException。</li>
</ul>
<p>通常我们只捕获 Exception，不处理 Error。</p>
<p>如果面试官追问</p>
<p><strong>Q：那为什么 Error 不推荐捕获？</strong></p>
<blockquote>
<p>因为 Error 通常由 JVM 抛出，代表系统层问题，程序恢复不了，捕获也没意义。比如堆内存溢出时，就算 catch 了也无法分配对象继续运行。</p>
</blockquote>
<p><strong>Q：Exception 和 RuntimeException 的关系呢？</strong></p>
<blockquote>
<p>RuntimeException 是 Exception 的子类，它代表运行时异常，不需要强制 try-catch，比如空指针、数组越界。</p>
</blockquote>
<h3 id="Java的优势">Java的优势</h3>
<ol>
<li><strong>跨平台性</strong><br>
Java的“写一次，运行多平台”特性通过JVM（Java虚拟机）实现，保证了Java程序能够在不同操作系统上运行，不需要针对每个系统重新编译。</li>
<li><strong>垃圾回收</strong><br>
Java提供了自动垃圾回收功能（GC），可以管理内存的分配与回收，减轻了开发者的负担，且不需要手动释放内存，避免了内存泄漏问题。</li>
<li><strong>生态系统</strong><br>
Java有强大的生态支持，包括丰富的第三方库、工具、框架和资源，使开发更加高效，适用的领域广泛。</li>
<li><strong>面向对象</strong><br>
Java采用面向对象的编程模型，支持继承、多态、封装等特性，代码易于维护和扩展，提升了开发效率和系统的可维护性。</li>
</ol>
<p>这些特点使Java成为了一个高度可移植、可靠并且在企业级开发中广泛应用的语言。</p>
<h3 id="java中的多态特性">java中的多态特性</h3>
<p>Java 多态特性：</p>
<p>Java 的多态是指同一方法在不同的对象上执行时，表现出不同的行为。它是面向对象编程的核心特性之一，通过方法重载和方法重写来实现。主要有两种类型：</p>
<ol>
<li><strong>编译时多态（方法重载）</strong>：
<ul>
<li>同一个类中，可以定义多个同名的方法，但是它们的参数列表（参数的数量、类型或顺序）必须不同。</li>
<li>这种多态性是在编译阶段决定的，编译器会根据方法的参数类型来决定调用哪个版本的重载方法。</li>
</ul>
</li>
<li><strong>运行时多态（方法重写）</strong>：
<ul>
<li>子类继承父类，并可以重写父类的方法，运行时决定具体调用哪个类的方法。</li>
<li>这种多态性发生在程序运行时，当父类引用指向子类对象时，实际执行的是子类的重写方法。</li>
</ul>
</li>
</ol>
<p>多态的优点：</p>
<ul>
<li><strong>代码的可扩展性</strong>：可以编写更灵活的代码，减少重复代码。</li>
<li><strong>解耦</strong>：通过接口或继承来解耦代码，易于修改和维护。</li>
</ul>
<p>面试中简洁回答：</p>
<p>Java 多态是指同一个方法调用，在不同的对象上会产生不同的执行效果。它主要分为编译时多态（方法重载）和运行时多态（方法重写）。编译时多态通过方法的参数差异来决定调用哪个方法，而运行时多态通过子类重写父类的方法来决定实际调用的版本。</p>
<h3 id="java中的参数传递是按值还是按引用">java中的参数传递是按值还是按引用</h3>
<p>在Java中，方法参数的传递是基于“值传递”机制的，但这里有一些细节需要注意：</p>
<ul>
<li>对于<strong>基本数据类型</strong>（例如 <code>int</code>, <code>char</code>，<code>boolean</code>），参数传递的是<strong>值的副本</strong>，因此修改副本不会影响原始变量。</li>
<li>对于<strong>引用数据类型</strong>（如类的实例），传递的是<strong>对象的引用</strong>，也就是对象的内存地址。在方法内部修改对象的属性会影响原始对象，但无法改变引用，使得引用指向另一个对象。</li>
</ul>
<p>总结来说，Java中方法参数的传递是<strong>值传递</strong>，但对于对象引用来说，实际上是传递引用的副本，所以能修改对象的内容，但不能修改引用本身。</p>
<h3 id="为什么java不支持多重继承">为什么java不支持多重继承</h3>
<p>Java不支持多重继承的主要原因是避免“钻石问题”，即当一个类继承了多个父类，并且这些父类有相同的方法或属性时，会导致冲突。为了防止这种复杂性，Java选择了单继承模型。通过接口（interface）提供了灵活的多继承方式，允许一个类实现多个接口，从而避免了传统多继承的缺点。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/11/image-96-1024x442.png" alt="img"></p>
<h3 id="java面向对象编程与面向过程编程的区别是什么">java面向对象编程与面向过程编程的区别是什么</h3>
<p>在Java中，面向过程编程和面向对象编程的区别，主要体现在思维方式和代码组织方式上。</p>
<ol>
<li>面向过程编程（Procedure-Oriented Programming）<br>
它以“过程”为核心，把程序看作一系列顺序执行的步骤，强调“先做什么、再做什么”。程序的基本单元是函数或过程，更关注执行的流程和算法逻辑，适合用来处理结构简单、流程清晰的任务。</li>
</ol>
<p>举个例子，我们要写一个“煮咖啡”的程序，面向过程的思路可能是：</p>
<ul>
<li>
<p>打开咖啡机；</p>
</li>
<li>
<p>加水；</p>
</li>
<li>
<p>加咖啡粉；</p>
</li>
<li>
<p>煮咖啡；</p>
</li>
<li>
<p>倒出咖啡。<br>
整个过程就像一条流水线，关注的是步骤和执行顺序。</p>
</li>
</ul>
<ol start="2">
<li>面向对象编程（Object-Oriented Programming, OOP）<br>
它以“对象”为核心，将数据和操作数据的方法封装在一起，程序的基本单元是对象。OOP更注重封装、继承、多态等特性，强调代码的复用性、可扩展性和灵活性。</li>
</ol>
<p>如果用面向对象的方式来实现“煮咖啡”，我们会先抽象出对象，比如“人”和“咖啡机”。</p>
<ul>
<li>
<p>“人”负责发出“煮咖啡”的指令；</p>
</li>
<li>
<p>“咖啡机”对象内部封装了加水、加豆、加热等方法。</p>
</li>
<li>
<p>当人调用咖啡机的 makeCoffee() 方法时，内部会自动完成一系列步骤。这样，代码更清晰、更易维护，也便于后期扩展，比如增加“加奶”“打泡”等新功能。</p>
</li>
</ul>
<p>总结来说：</p>
<ul>
<li>
<p>面向过程关注“做事的步骤”，适合小型、简单的任务；</p>
</li>
<li>
<p>面向对象关注“谁来做这件事”，更适合复杂、可扩展的系统开发。</p>
</li>
</ul>
<p>Java作为典型的面向对象语言，正是通过“封装、继承、多态”这些特性，让开发者能够更高效地管理复杂业务逻辑。</p>
<ol start="3">
<li>一句总结：</li>
</ol>
<p>“面向过程关注流程，面向对象关注对象。前者适合解决问题，后者适合构建系统。就像煮咖啡——面向过程一步步写流程，而面向对象则让‘咖啡机对象’自己完成整个动作。”</p>
<h3 id="Java-方法重载和方法重写之间的区别是什么？">Java 方法重载和方法重写之间的区别是什么？</h3>
<p>Java 里的 重载（Overload） 和 重写（Override） 最大区别在于：</p>
<ul>
<li>重载 **发生在同一个类中，方法名相同但参数不同（**类型、数量或顺序不同），和返回值无关，主要用于提高代码的灵活性，比如构造函数的重载。</li>
<li>而 重写 <strong>发生在父类和子类之间，子类对父类方法进行改写或扩展以实现多态</strong>。重写要求方法名、参数列表都相同，返回值类型相同或是其子类，访问修饰符权限不能更低。<br>
此外，private、static、final 方法不能被重写。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">对比项</th>
<th style="text-align:left"><strong>方法重载（Overload）</strong></th>
<th style="text-align:left"><strong>方法重写（Override）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>定义</strong></td>
<td style="text-align:left">在<strong>同一个类中</strong>定义多个同名方法，参数列表不同</td>
<td style="text-align:left">在<strong>子类中重写父类的方法</strong>，以实现多态</td>
</tr>
<tr>
<td style="text-align:left"><strong>发生位置</strong></td>
<td style="text-align:left">同一个类中</td>
<td style="text-align:left">父类与子类之间</td>
</tr>
<tr>
<td style="text-align:left"><strong>参数列表</strong></td>
<td style="text-align:left">必须不同（类型、数量、顺序至少有一处不同）</td>
<td style="text-align:left">必须完全相同</td>
</tr>
<tr>
<td style="text-align:left"><strong>返回值类型</strong></td>
<td style="text-align:left">可以不同（但仅靠返回值不同不能构成重载）</td>
<td style="text-align:left">必须相同，或是父类返回值的子类（协变返回类型）</td>
</tr>
<tr>
<td style="text-align:left"><strong>访问修饰符</strong></td>
<td style="text-align:left">无限制</td>
<td style="text-align:left">子类重写方法的访问权限<strong>不能低于</strong>父类方法</td>
</tr>
<tr>
<td style="text-align:left"><strong>异常声明</strong></td>
<td style="text-align:left">可随意定义</td>
<td style="text-align:left">子类方法抛出的异常<strong>不能比父类更宽泛</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>static / final / private 方法</strong></td>
<td style="text-align:left">可以被重载</td>
<td style="text-align:left">不能被重写（static 是隐藏，final/private 无法重写）</td>
</tr>
<tr>
<td style="text-align:left"><strong>调用方式</strong></td>
<td style="text-align:left">由编译器在<strong>编译时确定</strong>（编译时多态）</td>
<td style="text-align:left">由 JVM 在<strong>运行时动态绑定</strong>（运行时多态）</td>
</tr>
<tr>
<td style="text-align:left"><strong>目的</strong></td>
<td style="text-align:left">提高代码灵活性和可读性（同一功能不同实现）</td>
<td style="text-align:left">实现多态性，让子类定制父类行为</td>
</tr>
<tr>
<td style="text-align:left"><strong>示例</strong></td>
<td style="text-align:left"><code>void print(int a)</code> vs <code>void print(String s)</code></td>
<td style="text-align:left">子类重写 <code>void eat()</code> 改变父类默认实现</td>
</tr>
</tbody>
</table>
<p>重载是编译时多态，同类中同名不同参；<br>
重写是运行时多态，子类改写父类方法，方法名与参数都必须一致。</p>
<h3 id="什么是-Java-内部类？它有什么作用？">什么是 Java 内部类？它有什么作用？</h3>
<p>Java 内部类是<strong>定义在另一个类中的类</strong>，根据定义位置不同分为四种：<strong>成员内部类、静态内部类、局部内部类和匿名内部类</strong>。</p>
<ul>
<li>成员内部类可以访问外部类的所有成员，包括 private；</li>
<li>静态内部类只能访问外部类的静态成员；</li>
<li>局部内部类定义在方法中，只在方法内部可见；</li>
<li>匿名内部类没有类名，常用于接口回调或事件处理。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义位置</th>
<th>可访问范围</th>
<th>是否有类名</th>
<th>常见用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员内部类</td>
<td>外部类中，非静态位置</td>
<td>可访问外部类所有成员（含 private）</td>
<td>有</td>
<td>外部类与内部类强关联时使用</td>
</tr>
<tr>
<td>静态内部类</td>
<td>外部类中，static 修饰</td>
<td>只能访问外部类静态成员</td>
<td>有</td>
<td>辅助逻辑类，不依赖外部类实例</td>
</tr>
<tr>
<td>局部内部类</td>
<td>方法或代码块中定义</td>
<td>可访问 final 或 effectively final 的局部变量</td>
<td>有</td>
<td>临时逻辑封装</td>
</tr>
<tr>
<td>匿名内部类</td>
<td>无类名，直接定义实例</td>
<td>同局部类</td>
<td>无</td>
<td>简化接口实现或回调逻辑</td>
</tr>
</tbody>
</table>
<p>它的主要作用是提高封装性和代码内聚性，并且在只在一个地方使用的情况下可以简化代码结构。</p>
<p><strong>速答版</strong>：<br>
Java 内部类就是定义在类内部的类，分为成员内部类、静态内部类、局部内部类和匿名内部类。<br>
它能访问外部类的成员，提高封装性和内聚性，常用于回调、事件处理等场景。</p>
<h3 id="Java8-有哪些新特性？">Java8 有哪些新特性？</h3>
<p>Java 8 是一次非常重要的版本更新，引入了很多影响后续生态的特性。</p>
<ul>
<li>
<p>最核心的是 Lambda 表达式 和 函数式接口，让 Java 能以更简洁的方式实现函数式编程；</p>
</li>
<li>
<p>然后是 Stream API，可以用链式操作来处理集合，比如过滤、排序、映射这些操作，代码更优雅；</p>
</li>
<li>
<p>还新增了 接口的默认方法和静态方法，让接口在扩展时不破坏原有实现；</p>
</li>
<li>
<p>同时引入了 全新的日期时间 API（LocalDate、LocalTime、LocalDateTime），解决了老的 Date 不可变与线程安全问题；</p>
</li>
<li>
<p>在内存管理方面，用 元空间（Metaspace）替代了永久代（PermGen），解决了内存不足和 GC 效率低的问题；</p>
</li>
<li>
<p>此外还有 Optional 类 避免空指针，CompletableFuture 和 StampedLock 等并发增强类，以及 :: 方法引用语法。</p>
</li>
</ul>
<p>可以说 Java8 的这些改进让代码更简洁、更安全，也为后续的响应式编程打下了基础。</p>
<p><strong>速答版</strong>：<br>
Java8 的主要新特性有 Lambda 表达式、Stream API、接口默认方法、新日期时间 API、Optional 类，以及用元空间替代永久代。这些特性让 Java 更简洁、更高效、更现代化。</p>
<h3 id="Java-中-String、StringBuffer-和-StringBuilder-的区别是什么？">Java 中 String、StringBuffer 和 StringBuilder 的区别是什么？</h3>
<p>String、StringBuffer、StringBuilder用于表示一串字符，即字符序列。StringJoiner是JDK8引入的一个String拼接工具</p>
<p>在 Java 中，String、StringBuffer 和 StringBuilder 的主要区别在于<strong>可变性</strong>、<strong>线程安全性</strong>和<strong>性能</strong>。</p>
<p>首先，String 是<strong>不可变</strong>的，底层用 final char[] 修饰，每次修改都会创建新的对象，所以<strong>适合字符串内容不频繁变化的场景</strong>，比如常量池或日志输出。</p>
<p>而 StringBuffer 和 StringBuilder 都是<strong>可变</strong>的，修改内容不会新建对象，底层通过 append() 来操作。</p>
<p>不同的是，<strong>StringBuffer 是线程安全的</strong>，因为内部方法使用了 synchronized，适合多线程环境下的字符串操作；<br>
StringBuilder 则是非线程安全的，但没有同步锁，性能更高，适合单线程环境。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/11/image-97-1024x231.png" alt="img"></p>
<p>总结一句话：String 用于少变内容，StringBuffer 多线程改字符串，StringBuilder 单线程拼接最快。</p>
<p>速答版：</p>
<ul>
<li>String 不可变，线程安全；</li>
<li>StringBuffer 可变、线程安全、性能一般；</li>
<li>StringBuilder 可变、线程不安全，但性能最好。</li>
</ul>
<h3 id="Java-的-StringBuilder-是怎么实现的？">Java 的 StringBuilder 是怎么实现的？</h3>
<p>StringBuilder 的底层是通过一个 可变的 char 数组 来存储字符序列的。</p>
<p>和 String 不同的是，String 的底层也是 char[]，但被 final 修饰且是私有的，所以内容不可变；而 StringBuilder 没有这个限制。</p>
<p>当我们调用 append()、insert() 等方法时，StringBuilder 会 直接修改底层字符数组的内容，而不是像 String 那样创建新对象。</p>
<p>如果数组容量不够，会通过 Arrays.copyOf() 扩容，扩容规则是：新容量 = 旧容量 × 2 + 2，这样可以减少扩容次数、提升性能。</p>
<p>另外，它的所有方法没有加同步锁，所以是 线程不安全 的，但单线程下性能最好。</p>
<p>速答版：<br>
StringBuilder 底层是可变的 char[]，通过 append 直接修改，不会创建新对象；容量不足时会按 2 倍加 2 扩容；线程不安全但性能最好。</p>
<h3 id="Java-中包装类型和基本类型的区别是什么？">Java 中包装类型和基本类型的区别是什么？</h3>
<p>在 Java 中，基本类型和包装类型的区别主要体现在 <strong>性能</strong>、<strong>存储</strong>、<strong>比较方式</strong>和<strong>默认值</strong> 这几个方面。</p>
<ul>
<li>
<p>首先，基本类型 不是对象，占用内存小、效率高，适合频繁使用的简单运算；<br>
包装类型 是对象，会涉及堆内存分配和垃圾回收，性能相对低。</p>
</li>
<li>
<p>在比较时，基本类型用 == 比较数值，而包装类型的 == 比较的是地址，若要比较内容要用 equals()。</p>
</li>
<li>
<p>默认值也不同：基本类型如 int 默认是 0，boolean 默认 false，而包装类型的默认值是 null。</p>
</li>
<li>
<p>存储上，基本类型作为局部变量存在线程栈中，若是成员变量则在堆中；包装类型一定是对象，存在堆上。</p>
</li>
</ul>
<p>总结一句话：基本类型轻量高效，包装类型更灵活但开销更大。</p>
<p>速答版：<br>
基本类型存数值、效率高、不占内存；包装类型是对象，占堆内存、支持泛型和 null。<br>
比较上一个比值、一个比地址，默认值也不同：0 vs null。</p>
<p>附上对比表</p>
<table>
<thead>
<tr>
<th style="text-align:left">对比项</th>
<th style="text-align:left">基本类型（Primitive）</th>
<th style="text-align:left">包装类型（Wrapper）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>定义位置</strong></td>
<td style="text-align:left">位于 JVM 基本数据类型体系（如 int、double）</td>
<td style="text-align:left">位于 <code>java.lang</code> 包下的类（如 Integer、Double）</td>
</tr>
<tr>
<td style="text-align:left"><strong>是否对象</strong></td>
<td style="text-align:left">❌ 不是对象</td>
<td style="text-align:left">✅ 是对象（继承自 Object）</td>
</tr>
<tr>
<td style="text-align:left"><strong>存储位置</strong></td>
<td style="text-align:left">局部变量在<strong>栈上</strong>，成员变量在<strong>堆上</strong></td>
<td style="text-align:left">永远在<strong>堆中</strong>（对象引用存于栈上）</td>
</tr>
<tr>
<td style="text-align:left"><strong>默认值</strong></td>
<td style="text-align:left">数值型为 <code>0</code>，布尔型为 <code>false</code></td>
<td style="text-align:left">全部为 <code>null</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>比较方式</strong></td>
<td style="text-align:left"><code>==</code> 比较<strong>值</strong></td>
<td style="text-align:left"><code>==</code> 比较<strong>地址</strong>，<code>equals()</code> 比较<strong>值</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>性能表现</strong></td>
<td style="text-align:left">占用内存小、执行快</td>
<td style="text-align:left">占用内存大、执行慢（涉及 GC）</td>
</tr>
<tr>
<td style="text-align:left"><strong>用途场景</strong></td>
<td style="text-align:left">常用于数值计算、频繁运算</td>
<td style="text-align:left">适用于集合框架（如 List<Integer>）和需要对象的场景</td>
</tr>
<tr>
<td style="text-align:left"><strong>初始化方式</strong></td>
<td style="text-align:left">直接赋值（如 <code>int a = 1;</code>）</td>
<td style="text-align:left">需 new 或自动装箱（如 <code>Integer a = 1;</code>）</td>
</tr>
<tr>
<td style="text-align:left"><strong>可空性</strong></td>
<td style="text-align:left">❌ 不能为 null</td>
<td style="text-align:left">✅ 可为 null</td>
</tr>
<tr>
<td style="text-align:left"><strong>泛型支持</strong></td>
<td style="text-align:left">❌ 不支持泛型</td>
<td style="text-align:left">✅ 可用于泛型（例如 <code>List&lt;Integer&gt;</code>）</td>
</tr>
</tbody>
</table>
<h3 id="接口和抽象类有什么区别？">接口和抽象类有什么区别？</h3>
<h4 id="为什么-Java-要同时存在抽象类和接口？它们在设计思想上分别解决了什么问题？">为什么 Java 要同时存在抽象类和接口？它们在设计思想上分别解决了什么问题？</h4>
<p>我们从语法 + 思想 + 场景 三层逻辑来回答</p>
<h4 id="概念层（简述区别）">概念层（简述区别）</h4>
<p>抽象类是对事物共性的抽象，可以包含属性和方法；<br>
接口是对行为规范的抽象，更关注对象能做什么。</p>
<h4 id="语法层（核心对比表）">语法层（核心对比表）</h4>
<table>
<thead>
<tr>
<th>对比点</th>
<th>抽象类（abstract class）</th>
<th>接口（interface）</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承实现</td>
<td>单继承</td>
<td>多实现</td>
</tr>
<tr>
<td>成员内容</td>
<td>可有属性、构造方法、普通方法、抽象方法</td>
<td>仅能有常量和方法（JDK8 起可有默认方法、静态方法，JDK9 可有私有方法）</td>
</tr>
<tr>
<td>设计定位</td>
<td>模板：抽象出相同部分，提高复用</td>
<td>协议：定义行为规范，解耦调用方与实现方</td>
</tr>
<tr>
<td>访问修饰</td>
<td>可有各种修饰符</td>
<td>默认 public、static、final（常量）</td>
</tr>
<tr>
<td>场景</td>
<td>父类通用功能扩展</td>
<td>不同类的行为统一</td>
</tr>
</tbody>
</table>
<h4 id="思想层">思想层</h4>
<p>抽象类体现的是模板复用思想，<br>
接口体现的是解耦和规范思想。</p>
<p>举个例子</p>
<p>比如我们有 Bird、Airplane、Superman 都能飞。</p>
<ul>
<li>它们的“飞”是一种行为能力，应该定义在接口 Flyable 中（规定必须实现 fly()）。</li>
<li>而“鸟类”有共同特征，比如翅膀、吃虫等，就应该抽象为一个抽象类 Bird，让子类继承它共享实现。</li>
</ul>
<p>所以接口是「能做什么」，抽象类是「是什么 + 怎么做」。</p>
<h4 id="一句话总结">一句话总结</h4>
<p>抽象类和接口最大的区别在于“<strong>目的</strong>”。</p>
<ul>
<li>抽象类是<strong>对类的共性抽象</strong>，可以包含属性和方法，强调复用；</li>
<li>接口是<strong>对行为的抽象</strong>，强调规范与解耦。</li>
</ul>
<blockquote>
<p>比如我们有 Bird、Airplane、Superman 都能飞。</p>
</blockquote>
<ul>
<li>它们的“飞”是一种行为能力，应该定义在接口 Flyable 中（规定必须实现 fly()）。</li>
<li>而“鸟类”有共同特征，比如翅膀、吃虫等，就应该抽象为一个抽象类 Bird，让子类继承它共享实现。</li>
</ul>
<p>所以接口只关注「能做什么」，抽象类则关注「是什么 + 怎么做」。</p>
<p>抽象类解决代码复用问题，接口解决多继承和行为统一问题。</p>
<p>一句话：<strong>抽象类是模板，接口是契约。</strong></p>
<h3 id="JDK-和-JRE-有什么区别？">JDK 和 JRE 有什么区别？</h3>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/11/image-98-1024x439.png" alt="img"></p>
<h3 id="你使用过哪些-JDK-提供的工具？">你使用过哪些 JDK 提供的工具？</h3>
<table>
<thead>
<tr>
<th>分类</th>
<th>工具</th>
<th>功能简述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>基础开发工具</strong></td>
<td><code>javac</code></td>
<td>Java 编译器，将 <code>.java</code> 源码编译为 <code>.class</code> 字节码</td>
</tr>
<tr>
<td></td>
<td><code>java</code></td>
<td>运行 Java 应用的命令，启动 JVM</td>
</tr>
<tr>
<td></td>
<td><code>javadoc</code></td>
<td>根据注释生成 API 文档</td>
</tr>
<tr>
<td></td>
<td><code>jar</code></td>
<td>打包/解压 JAR 文件</td>
</tr>
<tr>
<td></td>
<td><code>jdb</code></td>
<td>Java 调试工具，命令行调试、断点、变量查看</td>
</tr>
<tr>
<td><strong>性能监控与分析工具</strong></td>
<td><code>jps</code></td>
<td>查看当前正在运行的 Java 进程</td>
</tr>
<tr>
<td></td>
<td><code>jstack</code></td>
<td>查看线程堆栈，用于分析死锁和卡顿</td>
</tr>
<tr>
<td></td>
<td><code>jmap</code></td>
<td>导出内存映射（heap dump）文件，分析内存泄漏</td>
</tr>
<tr>
<td></td>
<td><code>jhat</code></td>
<td>堆分析工具，配合 <code>jmap</code> 使用</td>
</tr>
<tr>
<td></td>
<td><code>jstat</code></td>
<td>JVM 统计监控工具（GC 次数、加载类数等）</td>
</tr>
<tr>
<td></td>
<td><code>jconsole</code></td>
<td>图形化 JVM 监控工具</td>
</tr>
<tr>
<td></td>
<td><code>jvisualvm</code></td>
<td>综合性能分析工具（线程、GC、CPU 等）</td>
</tr>
<tr>
<td><strong>诊断与远程工具</strong></td>
<td><code>jinfo</code></td>
<td>查看和调整 JVM 参数</td>
</tr>
<tr>
<td></td>
<td><code>jstatd</code></td>
<td>远程 JVM 监控守护进程</td>
</tr>
</tbody>
</table>
<p><strong>但面试官想听到的不是“你会背”，而是“你会用”</strong><br>
所以不要机械背诵工具清单，而要讲出你真的用过、解决过问题的场景。</p>
<p>我平时在开发和排查问题时用过一些 JDK 自带的工具。</p>
<ol>
<li>首先是开发类工具，比如 javac、java、jar、javadoc 这些是日常必用的。</li>
<li>其次是性能排查类工具：</li>
</ol>
<ul>
<li>我常用 jps 查看运行中的 Java 进程；</li>
<li>遇到线程死锁或 CPU 占用高时，会用 jstack 导出线程堆栈排查问题；</li>
<li>如果怀疑内存泄漏，会通过 jmap -dump 导出堆文件，然后用 jvisualvm 或 Eclipse MAT 分析；</li>
<li>GC 频繁或 Full GC 慢的时候，我会用 jstat -gc 实时观察垃圾回收情况。</li>
</ul>
<ol start="3">
<li>最后是调优与监控类：<br>
我也用过 jconsole 和 jvisualvm 做 JVM 性能监控，比如查看线程数量、内存占用、GC 情况等。</li>
</ol>
<h4 id="补充">补充</h4>
<p>如果被问：“那你更喜欢哪个工具？”</p>
<ul>
<li>可以说：jvisualvm 因为它图形化、集成度高、可以远程连接。</li>
</ul>
<p>如果被问：“这些工具和 Arthas、SkyWalking 有什么区别？”</p>
<ul>
<li>可以说：JDK 工具偏底层调试，而 Arthas / SkyWalking 更适合线上系统监控和诊断。</li>
</ul>
<h3 id="Java-中-hashCode-和-equals-方法是什么？它们与-操作符有什么区别？">Java 中 hashCode 和 equals 方法是什么？它们与 == 操作符有什么区别？</h3>
<p>在 Java 中：</p>
<ul>
<li>== 比较的是两个引用是否指向同一个对象；</li>
<li>equals() 用于比较对象的内容是否相等，很多类（比如 String、Integer）都重写了它；</li>
<li>hashCode() 用于计算对象的哈希值，在 HashMap、HashSet 等集合中定位元素。</li>
</ul>
<p>实际上，equals() 与 hashCode() 有一致性要求——如果两个对象相等，它们的哈希码必须相同，否则会导致哈希集合中无法正确识别重复元素。</p>
<p><strong>一句话总结</strong>：<br>
== 比“是不是同一个对象”，equals 比“内容”，hashCode 用来“快速查找”。</p>
<h3 id="Java-中的-hashCode-和-equals-方法之间有什么关系？">Java 中的 hashCode 和 equals 方法之间有什么关系？</h3>
<ol>
<li>概念简述</li>
</ol>
<p>在 Java 中，equals() 和 hashCode() 是判断对象相等性的重要方法，<br>
它们在基于哈希的数据结构（如 HashMap、HashSet）中共同决定了对象的存取行为。<br>
2. 关系规则（必须背熟）<br>
它们之间遵循一致性约定（Contract）：</p>
<ul>
<li>如果两个对象通过 equals() 相等，那么它们的 hashCode() 必须相等。</li>
<li>但如果 hashCode() 相等，equals() 不一定相等（可能是哈希冲突）。</li>
<li>同一个对象多次调用 hashCode()，在程序运行期间必须返回同一个值。</li>
</ul>
<p>一句话总结：equals 决定“逻辑相等”，hashCode 决定“存储位置”。</p>
<ol start="3">
<li>为什么要重写 hashCode()</li>
</ol>
<p>如果我们只重写了 equals() 而没有重写 hashCode()，<br>
那么即使两个对象在逻辑上相等，哈希集合（HashSet/HashMap）也会认为它们是两个不同对象。<br>
这会导致：</p>
<ul>
<li>HashSet 出现重复数据；</li>
<li>HashMap 的 key 无法正确覆盖旧值；</li>
<li>contains()、remove() 等操作失败。</li>
</ul>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/11/image-99-787x1024.png" alt="img"><br>
4. 总结一句话</p>
<ul>
<li>equals() 决定对象“是否相等”，</li>
<li>hashCode() 决定对象“放在哪”。</li>
</ul>
<p>两者必须一起重写，才能保证基于哈希的集合正确工作。</p>
<h4 id="面试时口语答题版">面试时口语答题版</h4>
<p>在 Java 中，equals() 和 hashCode() 是判断对象相等性的两个核心方法。<br>
equals() 判断两个对象的内容是否相等，hashCode() 用于计算对象在哈希结构中的位置。<br>
它们之间有一致性约定：如果两个对象 equals() 相等，它们的 hashCode() 必须相等，否则在 HashMap 或 HashSet 中会出现定位错误。</p>
<p>比如我们定义了自定义类做 HashSet 的 key，只重写 equals() 不重写 hashCode()，会导致集合中出现重复数据。<br>
因此，重写 equals() 时必须同时重写 hashCode()，保证逻辑相等和哈希一致。</p>
<h3 id="什么是-Java-中的动态代理？">什么是 Java 中的动态代理？</h3>
<p>动态代理是 Java 提供的<strong>一种在运行时动态创建代理对象的机制</strong>。<br>
它允许我们在不修改目标对象代码的情况下，对方法调用进行增强，比如添加日志、权限验证或事务控制。<br>
Java 中主要有两种实现方式：一种是基于接口的 JDK 动态代理，另一种是基于继承的 CGLIB 动态代理。<br>
JDK 代理通过 InvocationHandler 拦截方法调用；CGLIB 通过生成目标类的子类实现。<br>
它的核心作用是让代码更灵活、更解耦，也是 Spring AOP 的基础。</p>
<p><strong>延伸</strong><br>
问1：动态代理底层是怎么生成类的？<br>
答：JDK 动态代理会在运行时使用 ProxyGenerator 生成 $Proxy0.class 字节码文件，然后由 ClassLoader 加载到内存中。</p>
<p>问2：Spring 是用哪种？<br>
答：Spring AOP 优先使用 JDK 动态代理；如果目标类没有接口，则自动切换到 CGLIB。</p>
<h3 id="JDK-动态代理和-CGLIB-动态代理有什么区别？">JDK 动态代理和 CGLIB 动态代理有什么区别？</h3>
<p>JDK 动态代理是基于接口的实现，通过反射机制在运行时生成代理类，并通过 InvocationHandler 调用目标对象的方法。<br>
它只能代理实现了接口的类。</p>
<p>CGLIB 动态代理是基于继承机制的，通过 ASM 字节码生成技术创建目标类的子类来实现代理，<br>
因此可以代理没有接口的普通类，但不能代理被 final 修饰的类或方法。</p>
<p>在 Spring AOP 中，如果目标类实现了接口，会优先使用 JDK 动态代理，否则自动切换到 CGLIB。<br>
性能上 JDK8 后两者几乎没有差别。</p>
<p>总结口诀</p>
<table>
<thead>
<tr>
<th>口诀</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“接口用 JDK，类用 CGLIB”</td>
<td>代理对象类型区分</td>
</tr>
<tr>
<td>“继承受限 final，接口灵活无限”</td>
<td>限制区别</td>
</tr>
<tr>
<td>“JDK 反射调，CGLIB 生成类”</td>
<td>实现原理</td>
</tr>
<tr>
<td>“AOP 双轮驱动，版本无性能坑”</td>
<td>框架应用</td>
</tr>
</tbody>
</table>
<h3 id="Java-中的注解原理是什么？">Java 中的注解原理是什么？</h3>
<p>注解是 Java 提供的一种元数据机制，用于在代码中添加结构化信息。<br>
它本质上是继承自 Annotation 接口的特殊接口，编译器会将注解信息写入字节码文件中。</p>
<p>在运行时，可以通过反射机制读取这些元数据，完成如依赖注入、配置映射等逻辑。</p>
<p>根据保留策略不同，注解分为编译期（SOURCE、CLASS）和运行期（RUNTIME）。<br>
运行期注解是框架如 Spring、MyBatis 的核心机制。</p>
<p>总结口诀</p>
<table>
<thead>
<tr>
<th>口诀</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“注解是标记，反射是钥匙”</td>
<td>反射是读取注解的关键</td>
</tr>
<tr>
<td>“保留到运行期，反射能识别”</td>
<td>只有 <code>RUNTIME</code> 才能反射读取</td>
</tr>
<tr>
<td>“编译做检查，运行做增强”</td>
<td>区分注解用途</td>
</tr>
<tr>
<td>“框架靠注解，灵魂是反射”</td>
<td>框架底层实现原理</td>
</tr>
</tbody>
</table>
<h3 id="你使用过-Java-的反射机制吗？如何应用反射？">你使用过 Java 的反射机制吗？如何应用反射？</h3>
<p>Java 的反射机制是指<strong>在运行时动态获取类的结构信息</strong>（包括属性、方法、构造器等），并能对对象进行<strong>动态创建、访问和修改</strong>的机制。</p>
<blockquote>
<p>它的核心类包括 Class、Method、Field、Constructor。</p>
</blockquote>
<ul>
<li>
<p>反射的最大优点是<strong>灵活性强，不需编译期确定类型</strong>，很多框架如 Spring、MyBatis、Junit 都依赖它实现依赖注入和动态代理。（<strong>框架三件套 = 反射 + 动态代理 + 注解</strong>。）</p>
</li>
<li>
<p>缺点是<strong>性能较低、安全性降低</strong>，但可以通过缓存 Method 对象或使用 MethodHandle 来优化性能。</p>
</li>
</ul>
<p><strong>小结</strong>：<br>
Java 的反射机制是一种在运行时动态获取类信息并操作对象的机制，是 Spring、MyBatis 等框架的核心基础，但要注意性能与安全性问题。</p>
<p>补充： 反射常用操作代码示例：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">1.</span> 获取类对象的三种方式</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; cls1 = <span class="keyword">Class</span>.forName(&quot;com.example.User&quot;);</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; cls2 = <span class="keyword">User</span>.<span class="keyword">class</span>;</span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; cls3 = <span class="built_in">new</span> <span class="keyword">User</span>().getClass();</span><br><span class="line"></span><br><span class="line">// <span class="number">2.</span> 创建对象</span><br><span class="line"><span class="keyword">Object</span> obj = cls1.newInstance(); // 调用无参构造</span><br><span class="line"></span><br><span class="line">// <span class="number">3.</span> 获取并调用方法</span><br><span class="line"><span class="keyword">Method</span> <span class="keyword">method</span> = cls1.getMethod(&quot;setName&quot;, String.<span class="keyword">class</span>);</span><br><span class="line"><span class="keyword">method</span>.invoke(obj, &quot;Alice&quot;);</span><br><span class="line"></span><br><span class="line">// <span class="number">4.</span> 访问私有属性</span><br><span class="line">Field field = cls1.getDeclaredField(&quot;age&quot;);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);  // 暴力反射</span><br><span class="line">field.<span class="keyword">set</span>(obj, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(field.<span class="keyword">get</span>(obj)); // 输出 <span class="number">25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="什么是-Java-中的不可变类？">什么是 Java 中的不可变类？</h3>
<p>不可变类（Immutable Class）是指对象一旦被创建，其状态（成员变量）就不能被修改的类。<br>
一旦初始化完成，对象的属性在整个生命周期中都保持不变，例如 String、Integer、BigDecimal 等。<br>
不可变类的核心特征：</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1️⃣ 类必须用 <code>final</code> 修饰</td>
<td>防止被继承后修改行为</td>
</tr>
<tr>
<td>2️⃣ 所有字段必须是 <code>private</code> 且 <code>final</code></td>
<td>防止外部直接修改属性</td>
</tr>
<tr>
<td>3️⃣ 不提供任何 setter 方法</td>
<td>确保状态一经初始化无法改变</td>
</tr>
<tr>
<td>4️⃣ 所有可变对象字段必须防御性复制</td>
<td>Getter 返回副本，防止外部修改原对象</td>
</tr>
<tr>
<td>5️⃣ 通过构造函数初始化全部属性</td>
<td>保证对象在创建时即处于完整状态</td>
</tr>
</tbody>
</table>
<h4 id="面试回答：">面试回答：</h4>
<p>不可变类是指<strong>对象在创建后，其状态就不能再被修改的类</strong>。<br>
类通常被声明为 final，所有成员变量是 <strong>private final</strong>，并且<strong>没有 setter 方法</strong>。<br>
如果类包含可变对象字段，需要通过防御性复制来保护内部状态不被外部修改。</p>
<p>不可变类的典型例子有 String、Integer、BigDecimal 等。<br>
它们的优点是线程安全、可缓存、调试简单；<br>
缺点是频繁修改会产生大量中间对象，浪费内存。</p>
<h3 id="什么是-Java-的-SPI（Service-Provider-Interface）机制？">什么是 Java 的 SPI（Service Provider Interface）机制？</h3>
<p>Java 的 SPI（Service Provider Interface）是一种服务发现机制，<br>
用于在运行时动态加载接口的不同实现类，实现系统解耦与模块化扩展。</p>
<p>它的核心是通过接口定义规范，第三方在 META-INF/services 目录下注册实现类，<br>
由 ServiceLoader 在运行时自动发现并加载这些类。</p>
<p>SPI 的典型应用是 JDBC、Dubbo、SLF4J 等。<br>
优点是扩展性强、解耦好；缺点是性能较低且无法动态刷新。</p>
<ul>
<li>
<p>一句话总结：<br>
Java SPI 是一种运行时加载第三方实现类的机制，<br>
通过接口 + 配置文件 + ServiceLoader 实现解耦与可插拔扩展，<br>
是 Java 框架（如 JDBC、Dubbo、Spring Boot Starter）底层的重要基础。</p>
</li>
<li>
<p>一句话概括了 SPI 和 API 的区别：<br>
“API 是我提供接口和实现，SPI 是我提供接口，别人实现。”</p>
</li>
</ul>
<h3 id="Java-泛型的作用是什么？">Java 泛型的作用是什么？</h3>
<p>Java 泛型的作用主要有三点：<br>
第一，类型安全，它可以在编译阶段检查类型，避免运行时 ClassCastException（类型转换异常）；<br>
第二，代码重用，通过泛型类和泛型方法，可以让同一份代码适用于多种数据类型；<br>
第三，消除显式类型转换，取出集合元素时不需要再手动强制类型转换，代码更简洁安全。</p>
<p>泛型只在编译期有效，编译后会进行“类型擦除/泛型擦除”，JVM 实际运行时使用的是原始类型（如 Object），所以泛型不会影响程序运行效率，只是提供编译期的安全检查。</p>
<h3 id="Java-泛型擦除是什么？">Java 泛型擦除是什么？</h3>
<h4 id="定义：">定义：</h4>
<p>泛型擦除（Type Erasure）是 Java 编译器在编译阶段执行的一种机制，<br>
它会在生成字节码时移除所有泛型类型信息，<br>
将类型参数替换为其限定类型（上界），<br>
若无上界则替换为 Object，以保证运行时与非泛型代码的兼容性。</p>
<h4 id="作用：">作用：</h4>
<ul>
<li>保持向下兼容（与 Java 5 之前版本兼容）；</li>
<li>减少 JVM 的复杂性（运行时不需要泛型类型检查）；</li>
</ul>
<h4 id="影响：">影响：</h4>
<ul>
<li>运行时无法获取泛型实际类型（List<String> 和 List<Integer> 在运行时完全相同）；</li>
<li>无法直接创建泛型数组或进行泛型类型判断；</li>
<li>反射只能获取泛型声明信息，不能获取运行时真实类型。</li>
</ul>
<h3 id="什么是-Java-泛型的上下界限定符？">什么是 Java 泛型的上下界限定符？</h3>
<p>Java 泛型的上下界限定符用于约束泛型参数的取值范围。</p>
<ul>
<li>? extends T 表示泛型类型必须是 T 或 T 的子类，常用于“只读”场景，保证读取时类型安全。</li>
<li>? super T 表示泛型类型必须是 T 或 T 的父类，常用于“只写”场景，保证插入时类型安全。</li>
</ul>
<p>它们遵循 PECS 原则（Producer Extends, Consumer Super）：</p>
<ul>
<li>生产者用 extends，消费者用 super。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">List</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="title class_">Integer</span>&gt;(); <span class="comment">// 只能读</span></span><br><span class="line"><span class="title class_">List</span>&lt;? <span class="variable language_">super</span> <span class="title class_">Integer</span>&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="title class_">Number</span>&gt;();   <span class="comment">// 只能写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Java-中的深拷贝和浅拷贝有什么区别？">Java 中的深拷贝和浅拷贝有什么区别？</h3>
<p>在 Java 中，拷贝分为浅拷贝和深拷贝：</p>
<ul>
<li>浅拷贝 只复制对象的基本类型字段，对于引用类型字段只复制引用地址，新旧对象共享同一堆内实例，因此修改一个对象会影响另一个。</li>
<li>深拷贝 不仅复制对象本身，还会递归复制其引用对象，两个对象完全独立，互不影响。</li>
</ul>
<p>Java 默认的 clone() 方法是浅拷贝，如需深拷贝可通过手动实现 clone()、对象序列化或工具类来完成。</p>
<p>用一个例子可以更好的理解-身份证复印件 vs 克隆人 ：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>浅拷贝</strong></td>
<td>复印了身份证。看起来信息一样（名字、地址相同），但你拿复印件去办事，所有操作其实都还是对“原人”生效。</td>
</tr>
<tr>
<td><strong>深拷贝</strong></td>
<td>造了一个“克隆人”，这个人和你一模一样（数据完全复制），但独立存在。他改发型、搬家都不会影响你。</td>
</tr>
</tbody>
</table>
<p>浅拷贝：两个人共用一个脑袋。<br>
深拷贝：每个人有自己的脑袋。</p>
<h3 id="什么是-Java-的-Integer-缓存池？">什么是 Java 的 Integer 缓存池？</h3>
<p>Java 的 Integer 缓存池是为了节省内存和提升性能而设计的。<br>
在 -128 ~ 127 范围内的 Integer 对象会被缓存并复用，<br>
当自动装箱或调用 Integer.valueOf() 时，若值在此范围内，会直接返回缓存对象，而不是新建。<br>
若使用 new Integer() 或超出该范围，则会创建新对象。<br>
缓存池通过静态内部类 IntegerCache 实现，范围可通过 JVM 参数调整。</p>
<p>补充：<br>
面试陷阱题</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer a <span class="operator">=</span> <span class="number">127</span><span class="comment">;</span></span><br><span class="line">Integer b <span class="operator">=</span> <span class="number">127</span><span class="comment">;</span></span><br><span class="line">Integer c <span class="operator">=</span> <span class="number">128</span><span class="comment">;</span></span><br><span class="line">Integer d <span class="operator">=</span> <span class="number">128</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">System.out.println(a <span class="operator">=</span><span class="operator">=</span> b)<span class="comment">; // ✅ true</span></span><br><span class="line">System.out.println(c <span class="operator">=</span><span class="operator">=</span> d)<span class="comment">; // ❌ false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原因：</p>
<ul>
<li>127 在缓存范围内 → a、b 引用同一对象</li>
<li>128 超出缓存范围 → c、d 各自新建对象</li>
</ul>
<h3 id="Java-的类加载过程是怎样的？">Java 的类加载过程是怎样的？</h3>
<p>Java 类加载分为三个主要阶段：加载、链接和初始化。<br>
其中“链接”又分为 验证、准备、解析 三个子阶段。</p>
<ul>
<li>加载阶段：把类字节码加载进内存，生成 Class 对象；</li>
<li>验证阶段：确保字节码符合 JVM 规范；</li>
<li>准备阶段：为静态变量分配内存并赋默认值；</li>
<li>解析阶段：把符号引用替换为直接引用；</li>
<li>初始化阶段：执行静态变量赋值与静态代码块逻辑。</li>
</ul>
<p>最终类就可以被 JVM 使用。</p>
<p>总结口诀（方便背诵）<br>
加载 → 验证 → 准备 → 解析 → 初始化<br>
简称：“<strong>加 验 准 解 初</strong>”</p>
<p>口诀记法：</p>
<p>加载类进内存，验证格式真；<br>
准备分配值，解析换引用；<br>
初始化执行码，一切都齐全。</p>
<h3 id="什么是-Java-的-BigDecimal？">什么是 Java 的 BigDecimal？</h3>
<p>BigDecimal 是 Java 提供的用于高精度小数计算的类，属于 java.math 包。<br>
它能避免 float 和 double 的精度误差，常用于金融、结算等高精度场景。<br>
BigDecimal 是不可变类，每次运算都会生成新的对象，提供加减乘除、比较、取整等方法，<br>
并支持多种舍入模式（如四舍五入 HALF_UP）。<br>
建议使用字符串构造方法以避免精度丢失。</p>
<h3 id="BigDecimal-为什么能保证精度不丢失">BigDecimal 为什么能保证精度不丢失?</h3>
<p>BigDecimal 之所以能保证精度不丢失，是因为它采用了 任意精度的<strong>整数表示法</strong>，<br>
BigDecimal 通过将数值部分（intVal）和小数位数（scale）<strong>分开存储</strong>，<br>
在计算时进行整数运算，最后通过 scale 调整小数点位置，避免了二进制浮点表示导致的精度丢失。</p>
<h3 id="使用-new-String-“abc”-语句在-Java-中会创建多少个对象？">使用 new String(“abc”) 语句在 Java 中会创建多少个对象？</h3>
<p>答：其实啊，new String(“abc”) 这句代码最多会创建两个对象，最少创建一个对象。<br>
我这么解释你就懂了：<br>
首先，Java 里有个字符串常量池（String Pool），JVM 在看到 “abc” 这个字面量的时候，会先去常量池里看看有没有 “abc” 这个字符串。</p>
<ul>
<li>如果已经有了，那就直接用，不再创建；</li>
<li>如果还没有，那 JVM 就会在常量池里先放一个 “abc”。</li>
</ul>
<p>接着呢，new String(“abc”) 这个操作，<br>
一定会在<strong>堆内存</strong>（Heap)里再创建一个新的对象，这个新对象的内容就是拷贝常量池里的 “abc”。</p>
<p>所以最后的情况是：</p>
<ul>
<li>如果 “abc” 在常量池里早就存在了 → 只在堆中创建 1 个对象；</li>
<li>如果 “abc” 在常量池里是第一次出现 → 会创建 2 个对象（常量池 1 个 + 堆里 1 个）。</li>
</ul>
<p><strong>一句话总结</strong>：<br>
new String(“abc”) 至少创建一个对象，最多两个。<br>
常量池管字面量，堆内存管 new 出来的对象。</p>
<h3 id="Java-中-final、finally-和-finalize-各有什么区别？">Java 中 final、finally 和 finalize 各有什么区别？</h3>
<p>final -&gt;修饰符（防修改）：final 可以修饰类、方法、变量，意思是“不能再改了”。<br>
finally -&gt;异常处理语句块（保证执行）:finally 一定会和 try-catch 一起出现，无论是否发生异常，finally 块里的代码都会执行。<br>
finalize()  -&gt; 对象回收前的“遗言方法”（已过时):finalize() 是 Object 类的一个方法，当垃圾回收器（GC）准备回收对象时，会调用它来让对象“临终清理”。(不推荐使用，因为 JVM 不保证它什么时候执行，甚至可能根本不执行。)</p>
<h3 id="为什么在-Java-中编写代码时会遇到乱码问题？">为什么在 Java 中编写代码时会遇到乱码问题？</h3>
<p>其实 Java 出现乱码，最根本的原因就是——<strong>编码和解码方式不一致</strong>。</p>
<p>比如写文件的时候用 UTF-8，但读的时候用 GBK，那 JVM 就会把字节解释错，原本的中文就变成了乱码。</p>
<p>常见的情况有三种：</p>
<ol>
<li>默认编码不同（Windows 是 GBK，Linux 是 UTF-8）；</li>
<li>文件流读写没指定编码；</li>
<li>数据库字符集不统一。</li>
</ol>
<p>只要统一用 UTF-8 就行，编码、解码、数据库都保持一致就不会乱。</p>
<h3 id="为什么-JDK-9-中将-String-的-char-数组改为-byte-数组？">为什么 JDK 9 中将 String 的 char 数组改为 byte 数组？</h3>
<p>JDK 9 把 String 的底层从 char[] 换成了 byte[]</p>
<ul>
<li>因为char数组，每个字符占用2个字节，但实际上，大量字符串（比如英文、数字、符号）只需要 1 个字节。这就造成空间浪费。</li>
<li>改用了byte数组后，通过一个 coder 字段来标记编码方式（0 → LATIN1（单字节），1 → UTF-16（双字节）），JVM 会根据字符串内容自动选择合适的编码。</li>
</ul>
<p>这样英文只占 1 字节，中文用 2 字节，不但省了一半内存，还提升了性能</p>
<h3 id="如果一个线程在-Java-中被两次调用-start-方法，会发生什么？">如果一个线程在 Java 中被两次调用 start() 方法，会发生什么？</h3>
<ul>
<li>一个线程在 Java 中只能启动一次。调用 start() 后，线程状态会从“新建”（NEW）变成“就绪”(RUNNABLE)，再由 JVM 调度执行。</li>
<li>如果再次调用 start()，线程已经不是新建状态了，JVM 就会抛出IllegalThreadStateException，因为线程生命周期是单向的，不能重复启动。</li>
</ul>
<h3 id="栈和队列在-Java-中的区别是什么？">栈和队列在 Java 中的区别是什么？</h3>
<p>栈和队列的主要区别在于数据的进出顺序。<br>
栈是后进先出（LIFO），像叠盘子，最后放上去的先拿走；<br>
队列是先进先出（FIFO），像排队买票，先来的人先走。</p>
<p>在 Java 里，Stack 类实现了栈结构，现在更推荐用 Deque。<br>
队列则由 Queue 接口实现，比如 LinkedList、PriorityQueue。</p>
<p>栈常用于函数调用、递归、表达式求值；<br>
队列常用于任务调度、消息队列或广度优先搜索（BFS）。</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>特点</th>
<th>常见场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈（Stack）</td>
<td>后进先出 LIFO</td>
<td>函数调用栈、表达式求值、括号匹配、深度优先搜索（DFS）</td>
</tr>
<tr>
<td>队列（Queue）</td>
<td>先进先出 FIFO</td>
<td>任务调度、消息队列、数据流处理、广度优先搜索（BFS）</td>
</tr>
</tbody>
</table>
<h3 id="Java-的-Optional-类是什么？它有什么用？">Java 的 Optional 类是什么？它有什么用？</h3>
<p>Optional 是 Java 8 引入的一个容器类，用来表示一个可能为空的值。<br>
它的主要作用是防止空指针异常，通过像 isPresent()、orElse()、ifPresent() 这样的 API，<br>
让我们不用到处写 if (obj != null)，代码更清晰、更安全。</p>
<p>你可以理解成它是一个“带状态的盒子”，<br>
盒子里可能有值，也可能是空的，但我们不用再直接碰 null。</p>
<h3 id="Java-的-I-O-流是什么？">Java 的 I/O 流是什么？</h3>
<p>Java 的 I/O 流其实就是用来读写数据的“通道”，<br>
程序可以通过它从文件、网络等地方读取数据，或者把数据输出到文件、控制台。</p>
<p>它分为两大类：</p>
<ul>
<li>字节流（InputStream / OutputStream），处理二进制数据；</li>
<li>字符流（Reader / Writer），处理文本数据。</li>
</ul>
<p>举个例子：读图片就用字节流，读写文本就用字符流。<br>
这样设计是为了让程序更灵活、更高效地操作不同类型的数据。</p>
<h3 id="Java-中的基本数据类型有哪些？">Java 中的基本数据类型有哪些？</h3>
<p>Java 一共有 8 种基本数据类型，用来存放最基础的数据，<br>
它们不属于对象类型，也不存放在堆里，而是在栈中。</p>
<p>整数类型有 4 个：byte、short、int、long；<br>
浮点类型 2 个：float、double；<br>
字符类型是 char；<br>
布尔类型是 boolean。</p>
<p>这些类型的设计是为了性能更高，不需要对象包装。</p>
<h3 id="什么是-Java-中的自动装箱和拆箱？">什么是 Java 中的自动装箱和拆箱？</h3>
<p>自动装箱和拆箱是 Java 编译器帮我们做的类型转换。<br>
比如，当我们把 int 放进 List<Integer> 时，会自动变成 Integer —— 这就是装箱；<br>
当我们从 List 取出来再参与运算时，它又会自动变回 int —— 这就是拆箱。</p>
<p>它是在 Java 5 引入的，主要是为了让代码更简洁。<br>
底层其实就是调用 valueOf() 和 xxxValue() 方法。</p>
<p>不过要注意两点：<br>
一是频繁装拆箱会影响性能，二是拆箱时如果是 null 会直接抛 NullPointerException。</p>
<h3 id="什么是-Java-中的迭代器（Iterator）？">什么是 Java 中的迭代器（Iterator）？</h3>
<h4 id="Iterator-是什么？">Iterator 是什么？</h4>
<p>Iterator 是 Java 集合框架中的一个接口，用于顺序遍历集合中的元素。<br>
它提供了一种统一访问集合元素的方式，开发者不需要关心集合的底层实现。<br>
常与 Collection 接口及其子类（如 List、Set）配合使用。</p>
<h4 id="核心方法">核心方法</h4>
<ul>
<li>boolean hasNext()：判断集合中是否还有下一个元素；</li>
<li>E next()：返回下一个元素，若没有则抛出 NoSuchElementException；</li>
<li>void remove()：删除最近一次通过 next() 返回的元素，仅在调用 next() 之后使用，否则抛出 IllegalStateException。</li>
</ul>
<h4 id="主要作用">主要作用</h4>
<ul>
<li>提供统一、简洁、安全的遍历方式，避免直接使用索引；</li>
<li>支持在遍历过程中删除元素；</li>
<li>for-each 语法实际上是基于 Iterator 实现的语法糖。</li>
</ul>
<h3 id="Java-运行时异常和编译时异常之间的区别是什么？">Java 运行时异常和编译时异常之间的区别是什么？</h3>
<p>Java 的异常分两类：编译时异常和运行时异常。<br>
举例：</p>
<ul>
<li>编译时异常-&gt;FileNotFoundException、IOException</li>
<li>运行时异常-&gt;算数异常 (ArithmeticException)、空指针异常 (NullPointerException)、数组越界 (ArrayIndexOutOfBoundsException)</li>
</ul>
<p>二者的区别：</p>
<ul>
<li>编译时异常在编译阶段就会被检查，比如文件读写错误，必须用 try-catch 或 throws 处理，否则编译不过；</li>
<li>而运行时异常是程序运行时才抛出的，比如空指针或数组越界，编译器不会强制你处理。</li>
</ul>
<p>设计上是因为编译时异常多来自外部环境，而运行时异常多是代码逻辑错误。</p>
<h3 id="什么是-Java-中的继承机制？">什么是 Java 中的继承机制？</h3>
<p>Java 的继承是面向对象的三大特性之一，<br>
它允许子类通过 extends 关键字继承父类的属性和方法，从而实现代码复用和功能扩展。<br>
Java 只支持单继承，但支持接口的多继承。<br>
优点是结构清晰、便于维护，缺点是耦合性高、灵活性差。</p>
<h3 id="什么是-Java-的封装特性？">什么是 Java 的封装特性？</h3>
<p>封装就是把对象的属性和方法包装在类里面，对外只提供访问接口，比如通过 getter/setter 控制访问权限。<br>
这样做可以隐藏内部实现细节，保护数据安全，也让代码更容易维护和扩展。</p>
<h3 id="Java-中的访问修饰符有哪些？">Java 中的访问修饰符有哪些？</h3>
<p>Java 有四种访问修饰符：public、protected、default、private。<br>
它们控制类和成员的访问范围。<br>
private 最严格，只能在当前类访问；default 是包级访问；<br>
protected 可以被同包或不同包的子类访问；public 最开放，任何地方都能访问。<br>
代码示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> name;       <span class="comment">// 所有人可访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;        <span class="comment">// 同包或子类可访问</span></span><br><span class="line">    <span class="type">String</span> gender;            <span class="comment">// 默认访问，同包可访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> idCard;    <span class="comment">// 仅类内可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Java-中静态方法和实例方法的区别是什么？">Java 中静态方法和实例方法的区别是什么？</h3>
<ul>
<li>静态方法用 static 定义，属于类本身，不需要创建对象就能调用，只能访问静态成员，常用于工具类或工厂方法。</li>
<li>实例方法属于对象，必须通过对象调用，可以访问类中所有成员，常用于操作对象属性或实现对象行为。</li>
</ul>
<p>总结一句话：<br>
静态方法属于类，实例方法属于对象；<br>
静态方法不依赖对象，只能访问静态成员；<br>
实例方法依赖对象，可以访问一切成员。</p>
<h3 id="Java-中-for-循环与-foreach-循环的区别是什么？">Java 中 for 循环与 foreach 循环的区别是什么？</h3>
<p>for 循环比较灵活，可以通过索引访问、修改、删除元素，适合需要<strong>控制循环逻辑</strong>的场景；<br>
foreach 是语法糖，用起来更简洁，但不能访问索引，也不能在遍历时修改集合内容，否则会报错。</p>
<p>总结一句话：<br>
for 灵活、能控制；foreach 简洁、安全但不能改。</p>
<h3 id="什么是-Java-中的双亲委派模型？">什么是 Java 中的双亲委派模型？</h3>
<h3 id="什么是双亲委派机制？">什么是双亲委派机制？</h3>
<p>Java 的双亲委派机制是类加载的一种设计模式。<br>
当类加载器收到加载请求时，它不会自己立刻加载，而是把请求交给父加载器，一层层向上委派，直到 Bootstrap 尝试加载。<br>
如果上层加载器都加载不了，才由当前加载器执行加载。<br>
这样做可以<strong>防止同一个类被重复加载</strong>，同时<strong>保证核心类的安全性</strong>，比如 java.lang.Object 永远由启动类加载器加载。</p>
<ul>
<li>一句话记忆：先找爸爸，爸爸找不到我再上！</li>
</ul>
<h4 id="工作流程">工作流程:</h4>
<p>1️ 当前类加载器接收到一个类加载请求；<br>
2️ 它不会立刻加载，而是将请求交给父类加载器；<br>
3️ 父类加载器再交给更上层的父类加载器；<br>
4️ 一直到最顶层的 Bootstrap ClassLoader（启动类加载器）；<br>
5️ 如果父加载器都无法完成加载，才由当前加载器执行加载。<br>
即：<strong>自下而上委派，自上而下加载</strong></p>
<h4 id="三种主要类加载器"><strong>三种主要类加载器</strong></h4>
<table>
<thead>
<tr>
<th>类加载器</th>
<th>实现方式</th>
<th>加载内容</th>
<th>加载路径</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bootstrap ClassLoader</strong></td>
<td>C++ 实现（JVM 内部）</td>
<td>JRE 核心类库</td>
<td><code>&lt;JAVA_HOME&gt;/lib</code></td>
</tr>
<tr>
<td><strong>Extension ClassLoader</strong></td>
<td>Java 实现</td>
<td>扩展类库</td>
<td><code>&lt;JAVA_HOME&gt;/lib/ext</code></td>
</tr>
<tr>
<td><strong>Application ClassLoader</strong></td>
<td>Java 实现</td>
<td>用户类（classpath）</td>
<td><code>classpath</code> 路径</td>
</tr>
</tbody>
</table>
<pre><code>                    启动类加载器（Bootstrap ClassLoader）
                            ↑
                    扩展类加载器（ExtClassLoader）
                            ↑
                    应用类加载器（AppClassLoader）
</code></pre>
<p>一般加载顺序是：应用类加载器 → 扩展类加载器 → 启动类加载器<br>
子类 → 父类 → Bootstrap → 父类返回 → 子类加载</p>
<h4 id="设计目的">设计目的</h4>
<p>“为什么要设计双亲委派机制？”<br>
1️ 防止类被重复加载<br>
→ 同一个类只会被一个加载器加载，避免内存中出现多个副本。</p>
<p>2️ 保证核心类安全<br>
→ 比如 java.lang.Object 永远由 Bootstrap 加载，<br>
即使用户自定义同名类也不会被替代。</p>
<p>3️ 实现类隔离<br>
→ 不同类加载器加载的类互相独立，互不干扰，方便模块化和沙箱机制。</p>
<h4 id="破坏双亲委派的场景">破坏双亲委派的场景</h4>
<p>实际开发中，有些框架“故意”打破双亲委派。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SPI 机制（Service Provider Interface）</strong></td>
<td>典型如 JDBC 的 <code>DriverManager</code>，需要由子加载器加载厂商实现类。</td>
</tr>
<tr>
<td><strong>Web 容器热加载机制（热部署）</strong></td>
<td>如 Tomcat / Spring Boot，为实现模块热替换，需要自定义类加载器。</td>
</tr>
<tr>
<td><strong>插件化框架</strong></td>
<td>比如 OSGi、Dubbo 插件系统，为实现模块隔离也会自定义加载逻辑。</td>
</tr>
</tbody>
</table>
<h4 id="面试简答">面试简答</h4>
<p>双亲委派机制是 Java 类加载器的一种设计模式。<br>
当类加载器加载类时，不会自己先去加载，而是把请求交给父类加载器，<br>
父类加载器再向上委派，直到最顶层的 Bootstrap ClassLoader。<br>
如果父类无法加载，才由当前加载器执行加载。<br>
这样可以避免类重复加载、保证核心类安全、实现类加载隔离。<br>
常见的类加载器包括 Bootstrap、Extension 和 Application 三种。<br>
在 SPI 或 Tomcat 热加载中，出于扩展性考虑会打破这一机制。</p>
<h3 id="Java-中-wait-和-sleep-的区别？">Java 中 wait() 和 sleep() 的区别？</h3>
<p>在 Java 中，wait() 和 sleep() 都能让线程暂停，但它们的作用和机制不同。</p>
<ul>
<li>wait() 属于 Object 类，必须在同步块中使用，会释放锁，通常配合 notify() 或 notifyAll() 实现线程通信。</li>
<li>sleep() 属于 Thread 类，不需要同步块，不会释放锁，只是让线程休眠指定时间后自动恢复。<br>
简单来说：wait 用于线程通信，sleep 用于线程延时；wait 放锁，sleep 不放锁。</li>
</ul>
<h3 id="Java-Object-类中有什么方法，有什么作用？">Java Object 类中有什么方法，有什么作用？</h3>
<p>Java 的 Object 类是所有类的父类，它定义了一组通用方法，<br>
主要包括对象比较（equals、hashCode）、对象拷贝（clone）、<br>
对象字符串表示（toString）、反射（getClass）、<br>
多线程协调（wait、notify、notifyAll）以及垃圾回收钩子（finalize）。<br>
这些方法几乎构成了所有 Java 对象的基本行为。</p>
<h3 id="Java-中的字节码是什么？">Java 中的字节码是什么？</h3>
<ul>
<li>Java 字节码（Bytecode）是 Java 编译器将 .java 源文件编译后生成的中间表示形式，<strong>它位于 Java 源代码与 JVM 执行的机器码之间。</strong></li>
<li>存储在 .class 文件中。</li>
<li>它是平台无关的指令集，由JVM 解释器或 JIT 编译器将其翻译为机器码运行。</li>
<li>字节码是 Java 实现 “一次编译，到处运行” 的核心机制。</li>
</ul>
<h3 id="什么是-BIO、NIO、AIO？">什么是 BIO、NIO、AIO？</h3>
<p>在 Java 中：</p>
<ul>
<li>BIO（Blocking I/O）：是传统的同步阻塞模型，一个请求一个线程，调用方在 I/O 操作完成前会一直被阻塞。适合连接数少、逻辑简单的场景。</li>
<li>NIO（Non-blocking I/O）：是同步非阻塞模型，I/O 操作立即返回，通过轮询（Selector）检查状态，一个线程可处理多个连接，提高并发性能。</li>
<li>AIO（Asynchronous I/O）：是异步非阻塞模型，I/O 请求发出后由操作系统完成，完成后通过回调或事件通知应用层。适用于高并发高响应场景。</li>
</ul>
<p>🔹 用比喻：<br>
BIO 是“自己一直盯着水烧开”；<br>
NIO 是“自己时不时来看看水开没”；<br>
AIO 是“请别人帮忙看，水开了他会通知你”。</p>
<h3 id="什么是-Channel？">什么是 Channel？</h3>
<p>在 Java NIO 中，Channel 是一个<strong>数据通道</strong>（Data Channel）， 用于在程序与 I/O 设备（文件、网络套接字等）之间进行数据的读写。 与传统的 I/O 流不同，Channel 是<strong>双向的、可读可写</strong>，并且支持<strong>非阻塞模式</strong>。</p>
<p>它通常与 Buffer 和 Selector 配合使用：</p>
<ul>
<li>Buffer 用于临时存储数据；</li>
<li>Selector 用于实现多路复用，从而用一个线程同时处理多个连接。</li>
</ul>
<p>常见的实现类包括：</p>
<ul>
<li>FileChannel（文件 I/O）</li>
<li>SocketChannel（TCP 客户端）</li>
<li>ServerSocketChannel（TCP 服务端）</li>
<li>DatagramChannel（UDP 通信）</li>
</ul>
<p>一句话总结：</p>
<p>Channel 就是 NIO 的“管道”，负责在程序与外部资源之间传输数据，是高效非阻塞 I/O 的核心。</p>
<h3 id="什么是-Selector？">什么是 Selector？</h3>
<p>Selector 是 Java NIO（New I/O） 中用于实现 <strong>I/O 多路复用</strong>（Multiplexing） 的核心组件。<br>
它允许一个线程同时监听多个 Channel（通道）上的事件（如可读、可写、连接就绪等），<br>
从而实现一个线程管理多个网络连接，大幅减少线程开销，提高系统并发性能。</p>
<p>工作原理：<br>
Channel 向 Selector 注册感兴趣的事件（如 OP_READ、OP_WRITE 等），<br>
Selector 通过 select() 方法检测哪些 Channel 就绪，然后再由程序去处理这些就绪事件。</p>
<p>类比理解<br>
可以把 Selector 理解成一个“<strong>监控中心</strong>”：<br>
它不停地查看哪些连接（Channel）有事要处理（比如有数据可读、有新连接等），<br>
然后把这些“有事的连接”交给程序去处理。</p>
<p>所以 Selector 的核心优势就是——<strong>一个线程就能看管成百上千个连接</strong>，<br>
不再像传统 BIO 一样一个连接就要一个线程。</p>
<h3 id="Float-经过一系列的操作后-加减乘除-，如何判断是否和另一个数相等呢？">Float 经过一系列的操作后(加减乘除)，如何判断是否和另一个数相等呢？</h3>
<p>在 Java 中，浮点数（float、double）不能直接用 == 比较是否相等，<br>
因为二进制浮点数无法精确表示所有十进制小数，会产生精度误差。</p>
<p>常见解决方案有三种：</p>
<p>1.容差比较法：<br>
Math.abs(a - b) &lt; epsilon，通过设置精度范围判断是否相等。</p>
<p>2.使用 BigDecimal：<br>
用于高精度计算场景（如金融），比较时用 compareTo() 而不是 equals()。</p>
<p>3.整数化处理：<br>
若业务允许（如金额以“分”为单位），可转为整数后再比较。</p>
<p>一句话总结：<br>
不能直接用 == 比较浮点数，推荐使用“误差范围法”或 BigDecimal.compareTo()。</p>
<h3 id="PO、VO、BO、DTO、DAO、POJO-有什么区别？">PO、VO、BO、DTO、DAO、POJO 有什么区别？</h3>
<h4 id="PO、VO、BO、DTO、DAO、POJO-到底怎么区分？">PO、VO、BO、DTO、DAO、POJO 到底怎么区分？</h4>
<p>让我一句话概括它们：</p>
<blockquote>
<p><strong>PO 放数据库、VO 给前端看、DTO 用来传数据、BO 干业务逻辑、DAO 操作数据库、POJO 是最普通的 Java 类。</strong><br>
——简单记：<strong>存储→PO、展示→VO、传输→DTO、业务→BO、访问数据库→DAO</strong></p>
</blockquote>
<h4 id="①-PO（持久化对象）——和数据库最贴近的对象">① PO（持久化对象）——和数据库最贴近的对象</h4>
<p><strong>PO 就是和数据库表一一对应的类。字段基本等于表字段。</strong></p>
<ul>
<li>主要目的是“读库/写库”</li>
<li>字段一般不会删减（不展示也得存）</li>
<li>不会加展示用字段（如 createTimeStr）</li>
</ul>
<p><strong>什么时候用？</strong><br>
Service / Mapper 在与数据库交互时，取出来的就是 PO；最终转成其它对象再返回。</p>
<h4 id="②-VO（视图对象）——返回给前端-页面用的">② VO（视图对象）——返回给前端/页面用的</h4>
<p>你可以把 VO 理解为：</p>
<blockquote>
<p><strong>“为了让前端更好用而设计的对象”</strong></p>
</blockquote>
<ul>
<li>字段是展示友好的（如格式化时间、状态文案）</li>
<li>可以组合多个来源的数据</li>
<li>不带数据库字段，不暴露敏感信息</li>
</ul>
<p>项目里的 VO 例子</p>
<ul>
<li><code>ResponseVO</code>：统一响应结构</li>
<li><code>PaginationResultVO</code>：分页数据包装</li>
<li>有时会自定义业务 VO，例如组合多个来源的展示字段</li>
</ul>
<p>也就是说：<br>
<strong>Controller 返回值永远是 VO 或分页 VO，不直接给前端 PO。</strong></p>
<h4 id="③-DTO（数据传输对象）——用来传输数据的“契约”">③ DTO（数据传输对象）——用来传输数据的“契约”</h4>
<p>DTO 的核心点是：</p>
<blockquote>
<p><strong>”我不是给前端看的，也不是用来存数据库的，我就是用来传数据的。”</strong></p>
</blockquote>
<ul>
<li>可能作为 Controller 的入参（CreateDTO/UpdateDTO）</li>
<li>也可能作为 Service 之间的传输载体</li>
<li>字段按业务含义组织，不按展示/数据库组织</li>
</ul>
<p>项目中 的 DTO 例子</p>
<ul>
<li><code>TokenUserInfoDto</code>：用户登录态，会发到 Redis</li>
<li><code>UserCountInfoDto</code>：统计粉丝数/点赞数</li>
<li><code>VideoInfoEsDto</code>：搜索时传给 ES</li>
<li><code>VideoPlayInfoDto</code>：跨层使用的数据结构</li>
</ul>
<p>也就是说：<br>
<strong>DTO 是中立的数据模型，既不是前端展示，也不绑定表结构。</strong></p>
<h4 id="④-BO（业务对象）——处理业务逻辑用的">④ BO（业务对象）——处理业务逻辑用的</h4>
<p>BO 属于业务域内的模型：</p>
<ul>
<li>用来封装业务逻辑（如“订单结算结果”“视频发布结果”）</li>
<li>可以包含多个 PO/DTO/外部数据的组合</li>
<li>业务层专用，不对外暴露</li>
</ul>
<p>很多项目不显式写 BO，但概念上它就是“业务处理阶段的对象”。</p>
<h4 id="⑤-DAO（数据访问对象）——操作数据库">⑤ DAO（数据访问对象）——操作数据库</h4>
<p>DAO 就是：</p>
<ul>
<li>提供 <code>save/get/update/delete</code> 的接口</li>
<li>Service 层不会直接操作数据库，而是调 DAO</li>
</ul>
<p>在 MyBatis/Spring 项目里你看到的：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserMapper.<span class="keyword">java</span></span><br><span class="line"><span class="keyword"></span>VideoInfoMapper.<span class="keyword">java</span></span><br></pre></td></tr></table></figure>
<p>其实就是 DAO，只不过现在大家叫 Mapper。</p>
<h4 id="⑥-POJO（普通-Java-对象）——最基础的类">⑥ POJO（普通 Java 对象）——最基础的类</h4>
<p>POJO 不是一个“职责角色”，只是指：</p>
<ul>
<li>最普通的 Java 类</li>
<li>没继承、没实现特殊接口</li>
</ul>
<p><strong>PO/VO/DTO/BO 这些其实都是 POJO 的“变种”。</strong></p>
<h4 id="把它们串起来">把它们串起来</h4>
<blockquote>
<p>在我们后端分层里，几个对象的职责非常明确：<br>
<strong>PO 是和数据库表对应的，用来持久化存储；<br>
DTO 是输入输出的契约，是服务之间或前后端之间的数据载体；<br>
VO 是返回给前端展示的对象，会做格式化/文案等处理；<br>
BO 是业务处理阶段的对象，可以组合多个来源的数据；<br>
DAO/Mapper 则负责具体的数据库 CRUD。<br>
而它们本质上都是 POJO，只是职责不同。</strong></p>
</blockquote>
<h4 id="结合你的-项目-来讲">结合你的 <strong>项目</strong> 来讲</h4>
<p>你可以这样讲（非常推荐）：</p>
<blockquote>
<p>在我的 项目里，这些对象分得更明确：</p>
<ul>
<li><strong>VO</strong>：比如 <code>ResponseVO</code>、<code>PaginationResultVO</code>，都是返回给前端的展示类；有些接口会拼组多个来源的数据再封装成自定义 VO。</li>
<li><strong>DTO</strong>：比如 <code>TokenUserInfoDto</code>、<code>VideoInfoEsDto</code>，用于服务之间、缓存、搜索层的传输，不会直接暴露给前端。</li>
<li><strong>Query 对象</strong>：像 <code>VideoInfoPostQuery</code>、<code>UserInfoQuery</code>，用于分页/条件查询，是输入专用。</li>
<li><strong>PO</strong>：例如 <code>UserInfo</code> 这种实体类，只负责映射数据库，不直接返回给前端。</li>
</ul>
<p>因为分层清晰，所以 Controller 只处理 DTO/Query，Service 处理 PO 和业务逻辑，最终用 VO 返回前端，整个系统观察性和扩展性都很好。 </p>
</blockquote>
<h4 id="面试官最爱的问题：">面试官最爱的问题：</h4>
<p><strong>为什么要搞这么多对象？不能用一个对象走天下吗？</strong></p>
<blockquote>
<p>不能，因为不同阶段关心点不一样：</p>
<ul>
<li><strong>PO</strong>：字段多、和数据库强绑定，不适合暴露</li>
<li><strong>VO</strong>：展示字段往往需要组合/格式化</li>
<li><strong>DTO</strong>：输入输出的契约要稳定、可校验</li>
<li><strong>BO</strong>：业务逻辑可能需要多个数据源的组合</li>
</ul>
<p>如果混在一起，就会出现“数据丢了没人发现、数据库字段改动导致前端挂掉”等问题，项目越大越混乱。<br>
分成多个对象其实是“职责隔离”，保证系统稳定可维护。</p>
</blockquote>
<h2 id="Java-集合面试题">Java 集合面试题</h2>
<h3 id="Java-中有哪些集合类？请简单介绍">Java 中有哪些集合类？请简单介绍</h3>
<p>Java 集合主要分为两大体系：</p>
<ul>
<li>
<p>Collection单列集合（存单值）包括：</p>
<ul>
<li>
<p>List（有序可重复，如 ArrayList、LinkedList）</p>
</li>
<li>
<p>Set（无序不重复，如 HashSet、TreeSet）</p>
</li>
<li>
<p>Queue（队列，如 PriorityQueue）</p>
</li>
</ul>
</li>
<li>
<p>Map双列集合（键值对存储）包括：</p>
<ul>
<li>HashMap、LinkedHashMap、TreeMap、Hashtable。</li>
</ul>
</li>
</ul>
<p>各集合底层一般是数组、链表、哈希表或红黑树，根据应用场景选择即可。</p>
<p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/11/image-100-1024x541.png" alt="img"></p>
<h3 id="数组和链表在-Java-中的区别是什么？">数组和链表在 Java 中的区别是什么？</h3>
<p>数组和链表的主要区别在于<strong>存储方式</strong>、<strong>访问效率</strong>、<strong>插入删除性能</strong>和<strong>空间利用率</strong>。</p>
<ul>
<li>数组在内存中是<strong>连续存储</strong>的，支持 O(1) 时间的随机访问，但插入删除需要移动元素，效率较低。</li>
<li>链表在内存中是<strong>非连续存储</strong>的，每个节点包含数据和指针，插入删除效率高 O(1)，但访问需要遍历 O(n)。</li>
<li>数组空间利用率高，但扩容麻烦；链表空间开销大，但结构灵活。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>数组适合数据量固定、频繁访问的场景；</li>
<li>链表适合数据量不固定、频繁插入删除的场景。</li>
</ul>
<p>一句话总结：</p>
<p>“数组快在访问，慢在插删；链表快在插删，慢在访问。”</p>
<h3 id="Java-中的-List-接口有哪些实现类？">Java 中的 List 接口有哪些实现类？</h3>
<p>Java 中常见的 List 实现类有：<strong>ArrayList、LinkedList、Vector、Stack</strong> 和 <strong>CopyOnWriteArrayList</strong>。</p>
<ul>
<li><strong>ArrayList</strong>：基于动态数组实现，随机访问快，插入删除慢，线程不安全。</li>
<li><strong>LinkedList</strong>：基于双向链表实现，插入删除快，随机访问慢，也不是线程安全的。</li>
<li><strong>Vector</strong>：早期线程安全版本的 ArrayList，方法同步，性能较低。</li>
<li><strong>Stack</strong>：继承自 Vector，实现了先进后出（LIFO）的栈结构。</li>
<li><strong>CopyOnWriteArrayList</strong>：线程安全，读操作无锁，写操作会复制一份新数组，适合读多写少的并发场景。</li>
</ul>
<p>一句话总结：<br>
“ArrayList 访问快，LinkedList 增删快，Vector 是同步老版本，CopyOnWriteArrayList 适合并发读多写少。”</p>
<h3 id="Java-中-ArrayList-和-LinkedList-有什么区别？">Java 中 ArrayList 和 LinkedList 有什么区别？</h3>
<p>ArrayList 和 LinkedList 都实现了 List 接口，区别主要在底层结构和性能上：</p>
<ul>
<li>ArrayList 基于<strong>动态数组</strong>实现，内存连续，随机访问快（O(1)），但插入删除慢（O(n)），适合读多写少场景；</li>
<li>LinkedList 基<strong>于双向链表</strong>实现，内存不连续，插入删除快（O(1)），访问慢（O(n)），适合频繁插删的场景；</li>
<li>二者都<strong>线程不安全</strong>，如需线程安全可用 CopyOnWriteArrayList。</li>
</ul>
<p>一句话总结：<br>
“ArrayList 快在访问，慢在增删；LinkedList 快在增删，慢在访问。”</p>
<h3 id="Java-ArrayList-的扩容机制是什么？">Java ArrayList 的扩容机制是什么？</h3>
<p>在 Java 中，ArrayList 是基于<strong>动态数组</strong>实现的。<br>
当元素数量超过当前数组的容量时，就会<strong>触发扩容机制</strong>。</p>
<p>默认情况下，ArrayList 的<strong>初始容量是 10</strong>。当发生扩容时，会创建一个<strong>新的数组</strong>，容量大约是旧容量的** 1.5 倍**，也就是通过 oldCapacity + (oldCapacity &gt;&gt; 1) 这个计算式来得到的。</p>
<p>然后，会把原来数组中的元素通过 Arrays.copyOf() 方法复制到新数组里。</p>
<p>扩容的过程是比较<strong>耗时</strong>的，因为涉及到<strong>内存分配和数据复制</strong>，<br>
所以如果能<strong>提前指定容量</strong>，性能会更好。</p>
<p><strong>此外，ArrayList 没有负载因子（loadFactor），这是和 HashMap 不同的地方</strong>。</p>
<p>另外在 JDK 1.7 和 1.8 版本之间有个小区别：</p>
<ul>
<li>在 JDK 1.7 中，调用无参构造方法时会直接创建一个长度为 10 的数组；</li>
<li>而在 JDK 1.8 中，采用了懒加载机制，只有在第一次调用 add() 方法时才真正分配空间。</li>
</ul>
<p>一句话总结：<br>
“ArrayList 的扩容机制就是——当容量不够时，自动按 1.5 倍增长，并复制旧数据到新数组中。”</p>
<h4 id="面试回答：-2">面试回答：</h4>
<p>ArrayList 底层是动态数组实现的，当元素数量超过当前容量时就会触发扩容。默认初始容量是 10，扩容时新容量是旧容量的 1.5 倍，实际上是通过 oldCapacity + (oldCapacity &gt;&gt; 1) 计算出来的。然后用 Arrays.copyOf() 把旧数组的内容复制到新数组里。</p>
<p>扩容过程会涉及内存分配和数据复制，性能相对较低，<br>
所以在预知元素数量时最好在构造时指定初始容量。</p>
<p>ArrayList 没有负载因子，和 HashMap 不一样。</p>
<p>在 JDK 1.7 中是构造时分配数组，1.8 以后是懒加载，只有第一次 add() 才真正分配空间。</p>
<p>总结：<br>
“ArrayList 的扩容机制 = 触发时自动按 1.5 倍新建数组 + 拷贝旧数据。”</p>
<h3 id="说说-Java-中-HashMap-的原理？">说说 Java 中 HashMap 的原理？</h3>
<p>HashMap 的底层是 <strong>数组 + 链表 + 红黑树</strong>  的结构。<br>
1.当我们向 HashMap 中存入一个键值对时，会先根据 key 的 hashCode 计算哈希值，再定位到数组下标。<br>
2.如果该位置为空，就直接插入；如果已有元素，就会比较 key：</p>
<ul>
<li>相同则覆盖 value；</li>
<li>不同则判断是链表还是红黑树结构。
<ul>
<li>若为链表 → 遍历插入尾部</li>
<li>若为TreeNode → 插入红黑树；</li>
</ul>
</li>
</ul>
<p>3.插入后判断</p>
<ul>
<li>链表长度 &gt; 8 且 table 大小 ≥ 64 → 转红黑树；（在 JDK 1.8 以后，为了避免链表过长导致性能下降，当链表长度超过 8 且数组容量 ≥ 64 时，会自动转换为 红黑树 提升查询效率。）</li>
<li>若红黑树节点数小于6-&gt;转回链表</li>
<li>若 size 超过 threshold（阈值） → 扩容。（HashMap 默认初始容量是 16，负载因子是 0.75，当元素数量超过 capacity × loadFactor 时会触发扩容（容量 ×2）。</li>
</ul>
<p>不过要注意的是：<strong>HashMap 不是线程安全的</strong>，多线程环境下建议使用 ConcurrentHashMap。</p>
<h3 id="Java-中-HashMap-的扩容机制是怎样的？">Java 中 HashMap 的扩容机制是怎样的？</h3>
<p>HashMap的扩容机制<br>
HashMap 在存储元素超过一定数量时会触发扩容，具体机制如下：</p>
<p>1.触发扩容<br>
当 HashMap 中的元素数量超过 负载因子（默认是 0.75）与当前容量的乘积时，扩容操作就会触发。</p>
<p>2.扩容规则<br>
扩容时，HashMap 的容量会 翻倍。例如，从 16 扩容到 32。<br>
扩容后，新的数组大小为原来的一倍，因此元素将重新分配到新的数组中。</p>
<p>3.扩容时jdk7会重新计算每个元素的哈希值，jdk8时不会重新计算哈希值，jdk8是通过hash值与上老数组的容量 (hash &amp; oldCapacity )来判断hash值的最高位是不是1，如果是1，则扩容后元素存放的位置为<strong>旧数组下标+老数组的容量</strong>，如果是0，说明元素还是存放在原来的下标位置。</p>
<h3 id="为什么-HashMap-在-Java-中扩容时采用-2-的-n-次方倍？">为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？</h3>
<p>HashMap 采用 2 的 n 次方作为容量，是为了让哈希值分布更均匀、减少冲突，并通过位运算代替取模运算来提升索引效率。<br>
同时在扩容时，只需判断哈希值新增一位的 0/1，即可快速确定新位置，避免重新计算哈希，提高扩容性能。</p>
<h3 id="为什么-Java-中-HashMap-的默认负载因子是-0-75？">为什么 Java 中 HashMap 的默认负载因子是 0.75？</h3>
<p>HashMap 的默认负载因子是 0.75，这个值是为了在<strong>时间复杂度</strong>和<strong>空间利用率</strong>之间取得一个合理的平衡。</p>
<ul>
<li>如果负载因子太小，比如 0.5，虽然哈希冲突少，查询快，</li>
<li>但会导致频繁扩容，浪费空间；</li>
<li>如果负载因子太大，比如 0.9，虽然空间利用率高，</li>
<li>但冲突多，查找效率会下降。<br>
所以 0.75 是经过大量实践验证的经验值，既能保证较低的冲突概率，又能减少扩容次数。</li>
</ul>
<p>总结：<br>
“0.75 是 HashMap 在空间利用率与查找效率之间的最优平衡点。”</p>
<h3 id="为什么-JDK-1-8-对-HashMap-进行了红黑树的改动？">为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？</h3>
<p>在 JDK1.8 之前，HashMap 使用链表来解决哈希冲突。<br>
当冲突比较严重时，链表会变得很长，查找、插入、删除的时间复杂度从 O(1) 退化为 O(n)。</p>
<p>为了避免性能急剧下降，从 JDK1.8 开始，当桶中元素数量超过 8 时，<br>
并且数组长度大于 64，HashMap 会将链表转换为红黑树。<br>
红黑树是一种自平衡二叉查找树，操作复杂度是 O(log n)，可以显著提升性能。</p>
<p>当元素数量减少到 6 以下时，红黑树又会退化回链表，以节省内存。</p>
<p>另外，之所以不直接使用红黑树，是因为树节点体积更大，占用更多内存。<br>
因此，只有在冲突严重时才树化，是在<strong>性能与内存之间的平衡设计</strong>。</p>
<p>一句话总结：<br>
“JDK1.8 引入红黑树是为了解决哈希冲突导致的性能退化问题，<br>
将最坏时间复杂度从 O(n) 优化为 O(log n)，实现时间与空间的最佳折中。”</p>
<h3 id="JDK-1-8-对-HashMap-除了红黑树还进行了哪些改动？">JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？</h3>
<p>除了引入红黑树以外，JDK1.8 对 HashMap 还做了三项关键优化：</p>
<p>第一，<strong>优化了哈希函数</strong>。<br>
通过 (h = key.hashCode() ^ (h &gt;&gt;&gt; 16)) 通过高 16 位与低 16 位异或，使高位信息参与索引计算，让哈希值分布更均匀，减少冲突。</p>
<p>第二，<strong>改进了扩容机制</strong>。<br>
JDK1.7 每次扩容都要重新计算 hash 值，而 JDK1.8 直接通过 (hash &amp; oldCap) 旧容量（oldCap）的高位判断节点的新位置，无需重新计算 hash。</p>
<p>第三，<strong>插入方式从头插法改为尾插法</strong>。<br>
头插法在多线程扩容时可能造成<strong>链表反转和死循环</strong>，改为尾插法后可以有效避免这一问题。</p>
<p>一句话总结：<br>
“JDK1.8 的 HashMap 通过优化哈希函数、改进扩容机制、改为尾插法，在性能、稳定性和安全性上都比 JDK1.7 有显著提升。”</p>
<h3 id="使用-HashMap-时，有哪些提升性能的技巧？">使用 HashMap 时，有哪些提升性能的技巧？</h3>
<p>在使用 HashMap 时，主要可以从以下几个方面提升性能：</p>
<p>① <strong>预估初始容量，避免频繁扩容</strong><br>
HashMap 扩容会触发 rehash，代价高；可以通过 new HashMap(expectedSize / 0.75f) 预设容量。</p>
<p>② <strong>合理调整负载因子（LoadFactor）</strong><br>
默认 0.75 是空间与时间的平衡点，数据密集或读多写少的场景可略调低。</p>
<p>③<strong>确保 hashCode 分布均匀</strong><br>
设计良好的 hashCode 可避免冲突，减少链表/红黑树退化，提高访问效率。</p>
<p>④ <strong>根据场景选用合适 Map 实现类</strong></p>
<ul>
<li>LinkedHashMap：保持插入顺序；</li>
<li>ConcurrentHashMap：高并发场景；</li>
<li>TreeMap：需要排序的场景。</li>
</ul>
<p>一句话总结：<br>
提前规划容量、优化哈希函数、合理配置负载因子，才是 HashMap 高性能的关键。</p>
<h3 id="什么是-Hash-碰撞？怎么解决哈希碰撞？">什么是 Hash 碰撞？怎么解决哈希碰撞？</h3>
<p>Hash 碰撞是指不同的 key 通过哈希函数计算后得到相同的哈希值，从而映射到哈希表中的同一个槽位。</p>
<p>常见的解决方式包括：</p>
<p><strong>① 拉链法（链地址法）</strong>：<br>
每个槽位对应一个链表或红黑树，所有哈希值相同的元素存在该链表中。<br>
（Java 的 HashMap 就是采用这种方式）</p>
<p><strong>② 开放寻址法</strong>：<br>
当发生碰撞时，继续在数组中寻找下一个空闲槽位（如线性探测、二次探测）。</p>
<p><strong>③ 再哈希法（双重哈希）</strong>：<br>
使用多个哈希函数，在发生碰撞时重新计算新的索引位置。</p>
<p>🔹总结一句话：<br>
“Hash 碰撞是不可避免的，关键在于通过合理的冲突解决策略（如拉链法+红黑树）保持高效性能。”</p>
<h3 id="Java-的-CopyOnWriteArrayList-和-Collections-synchronizedList-有什么区别？分别有什么优缺点？">Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？</h3>
<p>CopyOnWriteArrayList 和 Collections.synchronizedList 都是线程安全的 List 实现，但机制完全不同。</p>
<ul>
<li><strong>CopyOnWriteArrayList</strong> 采用“写时复制”策略，写操作会复制一个新数组再修改，读操作无锁，适合读多写少的并发场景。优点是读性能极高、迭代安全；缺点是写操作慢且内存占用高。</li>
<li><strong>Collections.synchronizedList</strong> 通过 synchronized 关键字为所有操作加锁，实现线程安全。优点是实现简单，写操作无额外内存开销；缺点是读写都加锁，性能较差，且迭代需手动同步。</li>
</ul>
<p>一句话总结：<br>
读多写少用 CopyOnWriteArrayList，读写频繁用 Collections.synchronizedList（或直接用 ConcurrentHashMap、CopyOnWriteArraySet 等 JUC 类更优）。</p>
<h3 id="Java-中的-HashMap-和-Hashtable-有什么区别？">Java 中的 HashMap 和 Hashtable 有什么区别？</h3>
<p>在 Java 中，HashMap 和 Hashtable 的区别主要有四点：</p>
<p>第一，<strong>线程安全性不同</strong>：<br>
HashMap 是非线程安全的，多线程环境下可能出现数据不一致；<br>
而 Hashtable 是线程安全的，因为内部所有方法都加了 synchronized。</p>
<p>第二，<strong>性能不同</strong>：<br>
由于没有同步锁，HashMap 在单线程环境下性能更好。<br>
而 Hashtable 因为锁粒度太粗，性能偏低。</p>
<p>第三，<strong>对 null 的支持不同</strong>：<br>
HashMap 允许一个 null 键和多个 null 值；<br>
Hashtable 不允许任何 null 键或 null 值。</p>
<p>第四，<strong>迭代器机制不同</strong>：<br>
HashMap 使用 fail-fast 的 Iterator，迭代时修改会抛出ConcurrentModificationException（并发修改异常）；<br>
Hashtable 使用旧的 Enumeration，不会抛异常，但已经过时。</p>
<p>另外，HashMap 继承自 AbstractMap，Hashtable 继承自过时的 Dictionary 类。<br>
一句话总结：<br>
“HashMap 非线程安全、性能高；Hashtable 线程安全但过时，建议用 ConcurrentHashMap 替代。”</p>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别是什么？">ConcurrentHashMap 和 Hashtable 的区别是什么？</h3>
<p>在 Java 中，ConcurrentHashMap 和 Hashtable 都是<strong>线程安全</strong>的哈希表实现，但它们在实现线程安全的方式上完全不同。</p>
<p>Hashtable 使用的是整表锁，即每次读写都要竞争同一把锁，所以并发性能比较低。</p>
<p>而 ConcurrentHashMap 在 <strong>JDK7 采用分段锁机制</strong>，<br>
<strong>在 JDK8 之后采用了 CAS + synchronized 的方式</strong>：<br>
CAS 用于无锁写入，如果冲突严重再退化为锁定特定桶的头结点。</p>
<p>这样锁的粒度更细，可以让多个线程同时访问不同桶，从而大幅提高并发性能。</p>
<p>此外，ConcurrentHashMap 的底层结构也更优化，<br>
它在高冲突时会将链表转换为红黑树，进一步提升查询效率。</p>
<p>一句话总结：<br>
“Hashtable 锁整张表，而 ConcurrentHashMap 只锁冲突桶 + 使用 CAS，无锁读写，并发性能更高。”</p>
<h3 id="Java-中的-HashSet-和-HashMap-有什么区别？">Java 中的 HashSet 和 HashMap 有什么区别？</h3>
<ol>
<li>
<p>HashSet 不允许重复元素，只存储一个元素<br>
HashSet 是一个不允许重复元素的集合。在 HashSet 中，存储的每个元素都是唯一的。当你尝试插入一个已经存在的元素时，插入操作会失败。</p>
</li>
<li>
<p>HashMap 存储键值对，键必须唯一，值可以重复<br>
HashMap 是一个由键值对组成的集合。它的键（key）必须是唯一的，但值（value）可以重复。如果你尝试将一个已经存在的键对应的值更新为一个新的值，它会替换掉旧的值。</p>
</li>
<li>
<p>HashSet 底层基于 HashMap 实现，HashSet 存储的元素是存储在 HashMap 的键中，value 就是一个 Object 对象<br>
HashSet 的底层是通过 HashMap 来实现的。在 HashSet 中，元素被存储为 HashMap 的键，而每个键的值（value）在 HashMap 中其实并不关心，它是一个常量对象，通常使用 Object 类型。</p>
</li>
</ol>
<h3 id="Java-中的-LinkedHashMap-是什么？">Java 中的 LinkedHashMap 是什么？</h3>
<p><strong>LinkedHashMap 是 HashMap 的子类</strong>，它在 HashMap 的基础上通过维护一个 <strong>双向链表</strong>，来记录键值对的 <strong>插入顺序</strong>或<strong>访问顺序</strong>。</p>
<p>默认情况下按插入顺序排序，如果在构造时将 accessOrder 设为 true，<br>
则按最近访问顺序（LRU）排序。</p>
<p>它的查找、插入、删除操作依然是 O(1) 时间复杂度，并且允许键和值为 null。</p>
<p>常用于实现<strong>LRU 缓存</strong> 或需要保持插入顺序的场景。</p>
<h3 id="Java-中的-TreeMap-是什么？">Java 中的 TreeMap 是什么？</h3>
<p>TreeMap 是 Java 中实现 Map 接口的一种数据结构，<strong>它是基于红黑树的</strong>。红黑树是一种<strong>平衡的二叉查找树</strong>，它能确保在执行插入、删除和查找操作时，时间复杂度都能保持在 O(log n)。在 TreeMap 中，<strong>所有的键都会根据自然顺序或者我们提供的 Comparator 进行排序</strong>。</p>
<p>另外，<strong>TreeMap 不允许 null 作为键，因为 null 不能进行比较排序，但它允许存储 null 值</strong>。TreeMap 的一个特点是，<strong>它在实现上是一个有序的集合，能保证键值对始终按照升序排列</strong>。</p>
<h3 id="Java-中的-IdentityHashMap-是什么？">Java 中的 IdentityHashMap 是什么？</h3>
<p>IdentityHashMap 主要用在那些<strong>需要根据对象的内存地址来判断是否相等的场景</strong>，<strong>而不是判断两个对象的内容是否相同</strong>。简单来说，IdentityHashMap 会使用 <strong>==</strong> 来判断两个键是否相同，<strong>而不是像 HashMap 使用 equals() 方法来判断</strong>。它通常在一些特殊的情况下使用，比如<strong>缓存管理或者需要进行对象唯一性的场景</strong>。</p>
<p>此外，IdentityHashMap 和 HashMap 的存储方式也有所不同，它存储键的方式<strong>更注重引用</strong>而不是对象内容，因此它适用于某些特定的使用场景。</p>
<h3 id="Java-中的-WeakHashMap-是什么-？">Java 中的 WeakHashMap 是什么 ？</h3>
<ul>
<li><strong>WeakHashMap</strong> 是一种使用<strong>弱引用</strong>（Weak Reference）作为键（key）的哈希表实现。与普通的 HashMap 不同，WeakHashMap 会允许垃圾回收器去回收不再被其他对象引用的键。也就是说，当 WeakHashMap 中的键对象不再被其他任何地方引用时，该键值对会自动从 WeakHashMap 中移除。</li>
<li>通过这种机制，WeakHashMap 能够避免因对象持续存在于内存中而导致的<strong>内存泄漏</strong>问题。</li>
<li>WeakHashMap适用于<strong>需要对缓存对象进行动态管理</strong>的场景，<strong>它通过弱引用机制，确保对象可以在没有强引用时自动被垃圾回收。</strong></li>
</ul>
<h3 id="Java-中-ConcurrentHashMap-1-7-和-1-8-之间有哪些区别？">Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？</h3>
<h4 id="1-数据结构">1.数据结构</h4>
<p>JDK 1.7 ：ConcurrentHashMap 采用了<strong>Segment（分段锁）</strong>+ <strong>HashEntry（哈希表</strong>）来组成数据结构。</p>
<p>JDK 1.8 : ConcurrentHashMap 去掉了 Segment，使用<strong>数组+链表和红黑树的结构</strong>(与HashMap类似)。</p>
<h4 id="2-锁的类型与粒度">2.锁的类型与粒度</h4>
<p>JDK 1.7： 分段锁(Segment)继承了 ReentrantLock，每个 Segment 是独立的，因此可以支持更多的并发线程，<strong>默认情况下有 16 个 Segment</strong>。</p>
<p>JDK 1.8： 使用 <strong>synchronized 和 CAS</strong> 来保证线程安全，相比于 1.7 更细粒度的锁。</p>
<h4 id="3-扩容机制：">3. 扩容机制：</h4>
<p>JDK 1.7： 每个segment里单独进行自己的扩容。</p>
<p>JDK 1.8： JDK 1.8 的扩容机制引入了<strong>渐进式扩容</strong>，当我们的元素个数达到扩容阈值时，<strong>首先创建一个 2 倍大小的数组，然后后续每次有线程对当前数据结构进行操作（新增、修改等），都会帮忙迁移部分的数组槽位上的数据(使用tranferIndex进行标记)，直到旧数组的数据完全迁移到新数组为止</strong>。扩容过程更加高效，减少了锁的竞争。</p>
<h3 id="Java-中-ConcurrentHashMap-的-get-方法是否需要加锁？">Java 中 ConcurrentHashMap 的 get 方法是否需要加锁？</h3>
<p>在 Java 中的 ConcurrentHashMap 中，get() 方法<strong>不需要加锁</strong>。这个设计是<strong>为了提升性能，并减少锁的开销</strong>。</p>
<ul>
<li>
<p>get方法是读取数据操作，不对资源做处理，所以只要使用 <strong>volatile</strong> 关键字来确保每次读取操作都能获取到最新的数据即可。</p>
</li>
<li>
<p>具体来说，get() 方法是在数组节点上执行的，它通过 Unsafe 类的 getObjectVolatile() 方法来保证线程可见性，确保每次读取到的值是最新的。</p>
</li>
</ul>
<h3 id="为什么-Java-的-ConcurrentHashMap-不支持-key-或-value-为-null？">为什么 Java 的 ConcurrentHashMap 不支持 key 或 value 为 null？</h3>
<p>Java 中的 ConcurrentHashMap 不支持 key 或 value 为 null 主要是为了<strong>避免并发操作时出现不可预知的行为</strong>。比如，在多线程环境下执行 get(key) 时，<strong>如果 key 对应的值是 null，就无法判断这是因为 key 不存在，还是它的 value 就是 null。如果允许 null，那么就需要额外的代码来区分这些情况，增加了复杂度。</strong></p>
<p>此外，ConcurrentHashMap 的设计是为了避免歧义和并发问题。如果允许 null 作为 key 或 value，就会使得例如 get、put、containsKey 等操作更加复杂，可能<strong>导致频繁的状态检查或异常情况</strong>。</p>
<blockquote>
<p>hahsmap为什么可以？</p>
</blockquote>
<p>hashmap设计的初衷是单线程，它有containsKey方法可以判断key是否存在。<br>
ConcurrentHashMap不能用containsKey, 因为多线程环境下也会有歧义。</p>
<h3 id="Java-中的-CopyOnWriteArrayList-是什么？">Java 中的 CopyOnWriteArrayList 是什么？</h3>
<p>CopyOnWriteArrayList 是 Java 提供的线程安全的动态数组实现。这个类通过“<strong>写时复制”</strong>（Copy on Write）机制来保证<strong>线程安全</strong>，<strong>在进行写操作时，会先复制一份数组副本，写操作仅在新的副本上进行，而不对原始数组进行修改。</strong></p>
<p>基本特性:</p>
<ul>
<li>线程安全：使用 CopyOnWrite 机制，读操作不会加锁，写操作在写副本时加锁，保证线程安全。</li>
<li>写操作开销大：每次写操作都需要复制整个数组，有一定的性能消耗，而且消耗内存。</li>
<li>读操作无锁：由于数组是每次写时才被复制，所以对于大量的读操作是无锁的，性能较高。</li>
</ul>
<p>适合场景：</p>
<p>适合<strong>读多写少</strong>的情况。常用于事件通知、事件监停器等场景，能有效减少同步开销，确保线程安全。</p>
<h3 id="你遇到过-ConcurrentModificationException-错误吗？它是如何产生的？">你遇到过 ConcurrentModificationException 错误吗？它是如何产生的？</h3>
<p><strong>ConcurrentModificationException</strong> 它通常出现在多线程环境中，当我们在遍历集合（如 ArrayList）时，<strong>如果在遍历的过程中修改了集合的结构（比如添加或删除元素），就会抛出这个异常</strong>。这个异常的产生是因为 Java 使用了 <strong>fail-fast 机制</strong>，它会在检测到结构性修改时立即抛出异常，防止继续执行后续操作，避免不一致的状态。</p>
<blockquote>
<p>举例：</p>
</blockquote>
<p>比如，如果你在使用 for-each 遍历 ArrayList 时，同时修改了集合的内容，就会触发这个异常。Java 集合类会在 next() 方法调用时检查是否有结构性修改，如果检测到有修改，它会抛出 ConcurrentModificationException。</p>
<blockquote>
<p>如何避免:</p>
</blockquote>
<p>“为了避免这个异常，通常我们可以使用 <strong>Iterator</strong> 来遍历集合，<strong>因为 Iterator 提供了 remove() 方法来安全地删除元素</strong>。此外，在多线程环境下，可以使用像 <strong>CopyOnWriteArrayList</strong> 这样的线程安全集合，或者使用 <strong>synchronized</strong> 来同步操作。”</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>javase+集合相关面试题</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://itgeqian.github.io/posts/77.html">https://itgeqian.github.io/posts/77.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>geqian's Blog🍭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-10-07</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-10-20</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javase-%E9%9B%86%E5%90%88/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>javase+集合</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1PAY.jpg" target="_blank"><img class="post-qr-code-img" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1PAY.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E6%94%AF%E4%BB%98%E5%AE%9DPAY.jpg" target="_blank"><img class="post-qr-code-img" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E6%94%AF%E4%BB%98%E5%AE%9DPAY.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/73.html"><img class="prev-cover" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/20.jpg" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis相关面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/2.html"><img class="next-cover" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/%E7%88%B1%E5%BF%83.jpg" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GQ Video项目部署</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GQ%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88"><span class="toc-text">GQ八股-Java基础+集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80"><span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java中的序列化和反序列化是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception-%E5%92%8C-Error-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Exception 和 Error 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">Java的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7"><span class="toc-text">java中的多态特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E6%8C%89%E5%80%BC%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8"><span class="toc-text">java中的参数传递是按值还是按引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">为什么java不支持多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">java面向对象编程与面向过程编程的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 方法重载和方法重写之间的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">什么是 Java 内部类？它有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">Java8 有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中 String、StringBuffer 和 StringBuilder 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%9A%84-StringBuilder-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 的 StringBuilder 是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中包装类型和基本类型的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">接口和抽象类有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E8%A6%81%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%9C%A8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8A%E5%88%86%E5%88%AB%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">为什么 Java 要同时存在抽象类和接口？它们在设计思想上分别解决了什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%B1%82%EF%BC%88%E7%AE%80%E8%BF%B0%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-text">概念层（简述区别）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%B1%82%EF%BC%88%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94%E8%A1%A8%EF%BC%89"><span class="toc-text">语法层（核心对比表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3%E5%B1%82"><span class="toc-text">思想层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="toc-text">一句话总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-%E5%92%8C-JRE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">JDK 和 JRE 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B-JDK-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-text">你使用过哪些 JDK 提供的工具？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-hashCode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B8%8E-%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中 hashCode 和 equals 方法是什么？它们与 &#x3D;&#x3D; 操作符有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-hashCode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">Java 中的 hashCode 和 equals 方法之间有什么关系？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E6%97%B6%E5%8F%A3%E8%AF%AD%E7%AD%94%E9%A2%98%E7%89%88"><span class="toc-text">面试时口语答题版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">什么是 Java 中的动态代理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">JDK 动态代理和 CGLIB 动态代理有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的注解原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87-Java-%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-text">你使用过 Java 的反射机制吗？如何应用反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%EF%BC%9F"><span class="toc-text">什么是 Java 中的不可变类？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%EF%BC%9A"><span class="toc-text">面试回答：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-SPI%EF%BC%88Service-Provider-Interface%EF%BC%89%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">什么是 Java 的 SPI（Service Provider Interface）机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 泛型的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 泛型擦除是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%EF%BC%9A"><span class="toc-text">影响：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%9F"><span class="toc-text">什么是 Java 泛型的上下界限定符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中的深拷贝和浅拷贝有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-Integer-%E7%BC%93%E5%AD%98%E6%B1%A0%EF%BC%9F"><span class="toc-text">什么是 Java 的 Integer 缓存池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 的类加载过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-BigDecimal%EF%BC%9F"><span class="toc-text">什么是 Java 的 BigDecimal？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E4%BF%9D%E8%AF%81%E7%B2%BE%E5%BA%A6%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-text">BigDecimal 为什么能保证精度不丢失?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-new-String-%E2%80%9Cabc%E2%80%9D-%E8%AF%AD%E5%8F%A5%E5%9C%A8-Java-%E4%B8%AD%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">使用 new String(“abc”) 语句在 Java 中会创建多少个对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-final%E3%80%81finally-%E5%92%8C-finalize-%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中 final、finally 和 finalize 各有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-Java-%E4%B8%AD%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E6%97%B6%E4%BC%9A%E9%81%87%E5%88%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">为什么在 Java 中编写代码时会遇到乱码问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JDK-9-%E4%B8%AD%E5%B0%86-String-%E7%9A%84-char-%E6%95%B0%E7%BB%84%E6%94%B9%E4%B8%BA-byte-%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-text">为什么 JDK 9 中将 String 的 char 数组改为 byte 数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%9C%A8-Java-%E4%B8%AD%E8%A2%AB%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">如果一个线程在 Java 中被两次调用 start() 方法，会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%9C%A8-Java-%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">栈和队列在 Java 中的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%9A%84-Optional-%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">Java 的 Optional 类是什么？它有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%9A%84-I-O-%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 的 I&#x2F;O 流是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Java 中的基本数据类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%EF%BC%9F"><span class="toc-text">什么是 Java 中的自动装箱和拆箱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Iterator%EF%BC%89%EF%BC%9F"><span class="toc-text">什么是 Java 中的迭代器（Iterator）？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Iterator 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-text">核心方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="toc-text">主要作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 运行时异常和编译时异常之间的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">什么是 Java 中的继承机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84%E5%B0%81%E8%A3%85%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">什么是 Java 的封装特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Java 中的访问修饰符有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中静态方法和实例方法的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-for-%E5%BE%AA%E7%8E%AF%E4%B8%8E-foreach-%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中 for 循环与 foreach 循环的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">什么是 Java 中的双亲委派模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">什么是双亲委派机制？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">工作流程:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">三种主要类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-text">设计目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">破坏双亲委派的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E7%AE%80%E7%AD%94"><span class="toc-text">面试简答</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-wait-%E5%92%8C-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中 wait() 和 sleep() 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Object-%E7%B1%BB%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Java Object 类中有什么方法，有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的字节码是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-BIO%E3%80%81NIO%E3%80%81AIO%EF%BC%9F"><span class="toc-text">什么是 BIO、NIO、AIO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Channel%EF%BC%9F"><span class="toc-text">什么是 Channel？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Selector%EF%BC%9F"><span class="toc-text">什么是 Selector？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Float-%E7%BB%8F%E8%BF%87%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C%E5%90%8E-%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4-%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%92%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9B%B8%E7%AD%89%E5%91%A2%EF%BC%9F"><span class="toc-text">Float 经过一系列的操作后(加减乘除)，如何判断是否和另一个数相等呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PO%E3%80%81VO%E3%80%81BO%E3%80%81DTO%E3%80%81DAO%E3%80%81POJO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">PO、VO、BO、DTO、DAO、POJO 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PO%E3%80%81VO%E3%80%81BO%E3%80%81DTO%E3%80%81DAO%E3%80%81POJO-%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-text">PO、VO、BO、DTO、DAO、POJO 到底怎么区分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-PO%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1%EF%BC%89%E2%80%94%E2%80%94%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%80%E8%B4%B4%E8%BF%91%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">① PO（持久化对象）——和数据库最贴近的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-VO%EF%BC%88%E8%A7%86%E5%9B%BE%E5%AF%B9%E8%B1%A1%EF%BC%89%E2%80%94%E2%80%94%E8%BF%94%E5%9B%9E%E7%BB%99%E5%89%8D%E7%AB%AF-%E9%A1%B5%E9%9D%A2%E7%94%A8%E7%9A%84"><span class="toc-text">② VO（视图对象）——返回给前端&#x2F;页面用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-DTO%EF%BC%88%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%EF%BC%89%E2%80%94%E2%80%94%E7%94%A8%E6%9D%A5%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E2%80%9C%E5%A5%91%E7%BA%A6%E2%80%9D"><span class="toc-text">③ DTO（数据传输对象）——用来传输数据的“契约”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-BO%EF%BC%88%E4%B8%9A%E5%8A%A1%E5%AF%B9%E8%B1%A1%EF%BC%89%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%94%A8%E7%9A%84"><span class="toc-text">④ BO（业务对象）——处理业务逻辑用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4-DAO%EF%BC%88%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%EF%BC%89%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">⑤ DAO（数据访问对象）——操作数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5-POJO%EF%BC%88%E6%99%AE%E9%80%9A-Java-%E5%AF%B9%E8%B1%A1%EF%BC%89%E2%80%94%E2%80%94%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E7%B1%BB"><span class="toc-text">⑥ POJO（普通 Java 对象）——最基础的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E5%AE%83%E4%BB%AC%E4%B8%B2%E8%B5%B7%E6%9D%A5"><span class="toc-text">把它们串起来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E4%BD%A0%E7%9A%84-%E9%A1%B9%E7%9B%AE-%E6%9D%A5%E8%AE%B2"><span class="toc-text">结合你的 项目 来讲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E6%9C%80%E7%88%B1%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">面试官最爱的问题：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">Java 集合面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9F%E8%AF%B7%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">Java 中有哪些集合类？请简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%9C%A8-Java-%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">数组和链表在 Java 中的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-List-%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9F"><span class="toc-text">Java 中的 List 接口有哪些实现类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中 ArrayList 和 LinkedList 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java ArrayList 的扩容机制是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%EF%BC%9A-2"><span class="toc-text">面试回答：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Java-%E4%B8%AD-HashMap-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">说说 Java 中 HashMap 的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-HashMap-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 中 HashMap 的扩容机制是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap-%E5%9C%A8-Java-%E4%B8%AD%E6%89%A9%E5%AE%B9%E6%97%B6%E9%87%87%E7%94%A8-2-%E7%9A%84-n-%E6%AC%A1%E6%96%B9%E5%80%8D%EF%BC%9F"><span class="toc-text">为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD-HashMap-%E7%9A%84%E9%BB%98%E8%AE%A4%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E6%98%AF-0-75%EF%BC%9F"><span class="toc-text">为什么 Java 中 HashMap 的默认负载因子是 0.75？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JDK-1-8-%E5%AF%B9-HashMap-%E8%BF%9B%E8%A1%8C%E4%BA%86%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%94%B9%E5%8A%A8%EF%BC%9F"><span class="toc-text">为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-1-8-%E5%AF%B9-HashMap-%E9%99%A4%E4%BA%86%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%98%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E5%8A%A8%EF%BC%9F"><span class="toc-text">JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HashMap-%E6%97%B6%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9F"><span class="toc-text">使用 HashMap 时，有哪些提升性能的技巧？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Hash-%E7%A2%B0%E6%92%9E%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%EF%BC%9F"><span class="toc-text">什么是 Hash 碰撞？怎么解决哈希碰撞？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%9A%84-CopyOnWriteArrayList-%E5%92%8C-Collections-synchronizedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-HashMap-%E5%92%8C-Hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中的 HashMap 和 Hashtable 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-HashSet-%E5%92%8C-HashMap-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中的 HashSet 和 HashMap 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-LinkedHashMap-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的 LinkedHashMap 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-TreeMap-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的 TreeMap 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-IdentityHashMap-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的 IdentityHashMap 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-WeakHashMap-%E6%98%AF%E4%BB%80%E4%B9%88-%EF%BC%9F"><span class="toc-text">Java 中的 WeakHashMap 是什么 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-ConcurrentHashMap-1-7-%E5%92%8C-1-8-%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B2%92%E5%BA%A6"><span class="toc-text">2.锁的类型与粒度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">3. 扩容机制：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84-get-%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%8A%A0%E9%94%81%EF%BC%9F"><span class="toc-text">Java 中 ConcurrentHashMap 的 get 方法是否需要加锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E7%9A%84-ConcurrentHashMap-%E4%B8%8D%E6%94%AF%E6%8C%81-key-%E6%88%96-value-%E4%B8%BA-null%EF%BC%9F"><span class="toc-text">为什么 Java 的 ConcurrentHashMap 不支持 key 或 value 为 null？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-CopyOnWriteArrayList-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的 CopyOnWriteArrayList 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87-ConcurrentModificationException-%E9%94%99%E8%AF%AF%E5%90%97%EF%BC%9F%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">你遇到过 ConcurrentModificationException 错误吗？它是如何产生的？</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By geqian's Blog🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20230913" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20230913号"><img src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/20230913.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 geqianの学习笔记 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/杂项/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 geqianの杂项 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 geqianの项目笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/AI/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 geqianのAI大模型 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 geqianの算法学习笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 geqianの面试 (19)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/JUC/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🌏 geqianのJUC (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/JVM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍜 geqianのJVM (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/云原生/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🔐 geqianの云原生相关 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/MQ/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📱 geqianの消息队列 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🏛️ geqianの前端工程 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/mybatis-mybatis-plus/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎨 geqianのmybatis系列 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/微服务/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🗺️ geqianのSpringCloud系列 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/SSM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📖 geqianのSSM+SpringBoot系列 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/ruoyi/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📞 geqianの若依框架 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/mysql/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">❓ geqianのmysql (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/Redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💖 geqianのRedis (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://itgeqian.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/71.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/21.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/71.html&quot;);" href="javascript:void(0);" alt="">JVM面试题</a><div class="blog-slider__text">我对JVM的相关理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/71.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/%E5%8F%A4%E9%A3%8E.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt="">速通Spring AI Alibaba </a><div class="blog-slider__text">速通Spring AI Alibaba 完结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/27.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt="">GQ Video单服务版本记录</a><div class="blog-slider__text">GQ Video单服务版本记录（完整记录GQ Video从0到1的全记录）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/35.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt="">Mysql相关面试题</a><div class="blog-slider__text">我对mysql的相关理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/31.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt="">javase+集合相关面试题</a><div class="blog-slider__text">我对java基础和集合类的相关理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/22.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt="">JUC面试题</a><div class="blog-slider__text">我对JUC的理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>