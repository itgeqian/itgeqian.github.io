<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC面试题 | geqian's Blog🍭</title><meta name="keywords" content="JUC"><meta name="author" content="geqian's Blog🍭"><meta name="copyright" content="geqian's Blog🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="我对JUC的理解">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC面试题">
<meta property="og:url" content="https://itgeqian.github.io/posts/68.html">
<meta property="og:site_name" content="geqian&#39;s Blog🍭">
<meta property="og:description" content="我对JUC的理解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/22.jpg">
<meta property="article:published_time" content="2025-10-01T00:19:03.000Z">
<meta property="article:modified_time" content="2025-10-05T03:42:00.000Z">
<meta property="article:author" content="geqian&#39;s Blog🍭">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/22.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://itgeqian.github.io/posts/68"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-05 11:42:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><script src="https://cdn.jsdelivr.net/npm/echarts@6/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="geqian's Blog🍭" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.png" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">geqian's Blog🍭</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">JUC面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2025-10-01T00:19:03.000Z" title="发表于 2025-10-01 08:19:03">2025-10-01</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-05T03:42:00.000Z" title="更新于 2025-10-05 11:42:00">2025-10-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC面试题"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="GQ-JUC">GQ JUC</h1>
<h2 id="JUC">JUC</h2>
<h3 id="进程、线程、协程的区别">进程、线程、协程的区别</h3>
<p>进程负责“资源”，线程负责“执行”，协程负责“更轻量的执行方式”。</p>
<h4 id="进程是什么？（资源隔离-独立内存）">进程是什么？（资源隔离+独立内存）</h4>
<ul>
<li>进程<strong>就是一个程序的运行实例</strong>，<strong>比如你打开一个微信，就是一个进程</strong>。</li>
<li><strong>每个进程有自己独立的内存空间、文件句柄</strong>等资源，<strong>是操作系统中资源分配的最小单位</strong>。</li>
<li>不同进程之间互不影响，因此<strong>稳定性高，但创建和切换成本大</strong>。</li>
</ul>
<h4 id="线程是什么？（执行单元-更轻量）">线程是什么？（执行单元+更轻量）</h4>
<p><strong>线程是进程内部的“执行流”，一个进程可以有多个线程</strong>。<br>
<strong>线程之间共享同一个进程的内存</strong>，因此通信非常方便，但安全性要靠加锁保证。<br>
线程是<strong>CPU 调度的最小单位</strong>，切换比进程轻量，但仍需要 OS 参与调度。</p>
<h4 id="协程是什么？（用户态、极轻、高并发）">协程是什么？（用户态、极轻、高并发）</h4>
<p><strong>协程是比线程更轻量的“用户态调度”的执行方式，不会被 OS 感知。</strong><br>
它把切换时机交给程序自己决定，而不是让 OS 抢占式调度，因此切换开销极低。<br>
常用于大量 I/O 任务，比如 Go 的 goroutine、Java 的虚拟线程。</p>
<ul>
<li>进程：资源独立、安全但重 → “房子”</li>
<li>线程：共享资源、切换轻 → “房子里的房间”</li>
<li>协程：极轻量、用户态调度 → “房间里的小隔断，不需要 OS 管”</li>
</ul>
<h4 id="执行成本对比">执行成本对比</h4>
<table>
<thead>
<tr>
<th>对比项</th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建成本</td>
<td>高</td>
<td>中</td>
<td>很低</td>
</tr>
<tr>
<td>切换成本</td>
<td>高（OS 切换）</td>
<td>中（OS 切换）</td>
<td>极低（用户态切换）</td>
</tr>
<tr>
<td>内存隔离</td>
<td>完全隔离</td>
<td>共享</td>
<td>共享，逻辑更轻</td>
</tr>
<tr>
<td>调度者</td>
<td>OS</td>
<td>OS</td>
<td>程序自身</td>
</tr>
</tbody>
</table>
<h4 id="小结">小结</h4>
<ul>
<li><strong>进程是操作系统分配资源的单位，每个进程有独立的内存，因此安全但切换成本高</strong>。</li>
<li><strong>线程是进程里的执行单元，共享进程资源，切换比进程快但需要同步锁来保证安全</strong>。</li>
<li><strong>协程更轻量，它在用户态调度，不需要 OS 参与，所以切换成本非常低，非常适合 I/O 密集的高并发场景，比如 Go 的 goroutine 或 Java 的虚拟线程</strong>。</li>
</ul>
<h4 id="什么是-Java-中的线程同步？">什么是 Java 中的线程同步？</h4>
<p>线程同步其实就是在多线程环境中，<strong>保证同一时刻只有一个线程能访问某个共享资源</strong>，<strong>避免多个线程同时操作同一个资源时出现数据不一致或竞争条件的问题。</strong></p>
<p>线程同步有很多方式，常用的包括 <strong>synchronized、ReentrantLock 和原子类</strong>，它们的<strong>主要目的是保证数据的一致性和线程间的协调。</strong></p>
<ul>
<li>synchronized：它可以锁定代码块或者方法，确保同一时刻只有一个线程能执行这个方法或代码块</li>
<li>ReentrantLock 也是一种很常用的同步工具，它提供了更高的灵活性，比如可以尝试加锁、定时加锁等</li>
<li>Java 还提供了 Atomic 类系列，比如 AtomicInteger、AtomicLong 等，这些类通过原子操作来保证线程安全，避免了锁的使用
<ul>
<li>原理是这些原子类通过<strong>硬件级别的原子操作</strong>来实现操作的原子性。</li>
</ul>
</li>
</ul>
<h3 id="并行与并发-同步与异步">并行与并发,同步与异步</h3>
<ul>
<li>同步:<strong>需要等待结果返回</strong>，才能继续运行</li>
<li>异步:<strong>不需要等待结果返回</strong>，就能继续运行</li>
<li>并行：在同一时刻，有多个指令在多个 CPU 上同时执行, <strong>同一时间同时做多件事情的能力</strong>。多个人做多件事。</li>
<li>并发：在同一时刻，有多个指令在单个 CPU 上交替执行, <strong>同一时间段处理多件事情的能力</strong>。一个人做多件事。</li>
</ul>
<h3 id="Java-中的线程安全是什么意思？">Java 中的线程安全是什么意思？</h3>
<p>线程安全指的是<strong>在多线程环境下，多个线程同时访问某个共享资源时，不会出现数据不一致或修改错误的情况</strong>。当一个类或方法是线程安全的时，多个线程可以并发访问它，不需要担心在执行过程中数据会被其他线程改变。它能够确保在执行的过程中，不会出现<strong>竞争条件、死锁</strong>等问题。</p>
<p><strong>为什么线程安全很重要？</strong></p>
<p>在多线程环境中，<strong>多个线程可能会同时对同一数据进行操作</strong>。如果没有合适的同步措施，可能会导致数据被意外修改，最终产生不一致的结果。线程安全可以避免这种情况，保证每个线程访问的数据都是正确和一致的。</p>
<h3 id="什么是协程？Java-支持协程吗？">什么是协程？Java 支持协程吗？</h3>
<p>协程其实<strong>是比线程更加轻量的执行单元</strong>，它允许在执行过程中暂停，然后恢复执行，像是在线程内做任务切换，但比线程效率更高。<br>
jdk19引入了虚拟线程，jdk21确认,可以认为是java对协程的一种实现。</p>
<p>通过虚拟线程，我们可以在同一个线程池里高效地管理成千上万个线程，这样就能大大提高并发性能，特别是在需要大量并发但每个任务执行时间短的场景下。</p>
<h3 id="线程的生命周期在-Java-中是如何定义的？">线程的生命周期在 Java 中是如何定义的？</h3>
<h4 id="从-Java-API-层面来描述的有六种状态">从 Java API 层面来描述的有六种状态</h4>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/hqsWVhAF_image-1282-1024x707_mianshiya.png" alt="image-1282-1024x707.png" width="100%" />
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/aHn58qBx_image_mianshiya.png" alt="image.png" width="100%" />
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/X7NwTGDu_Snipaste_2025-11-01_21-45-22_mianshiya.png" alt="Snipaste_2025-11-01_21-45-22.png" width="100%" />
<h4 id="从-操作系统-层面来描述有五种状态">从 操作系统 层面来描述有五种状态</h4>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/teERwW4V_Snipaste_2025-11-01_21-46-15_mianshiya.png" alt="Snipaste_2025-11-01_21-46-15.png" width="100%" />
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/g0PGz6c3_Snipaste_2025-11-01_21-46-35_mianshiya.png" alt="Snipaste_2025-11-01_21-46-35.png" width="100%" />
<h3 id="Java-中线程之间如何进行通信？">Java 中线程之间如何进行通信？</h3>
<p>在 Java 中，线程之间的通信通常是为了实现多个线程在共享资源上进行协作。主要的方式包括：</p>
<ol>
<li>共享变量</li>
</ol>
<p>多个线程可以通过访问共享变量来交换信息。为了确保线程安全，必须小心使用共享数据，避免线程间的竞争条件或数据不一致。<br>
2. 同步机制</p>
<p>常见的同步机制包括：</p>
<ul>
<li>synchronized：用 Java 中的 synchronized 关键字来保证同一时刻只有一个线程能访问共享资源。线程间通过 wait() 和 notify() 等方法进行通信。</li>
<li>ReentrantLock：提供了类似于 synchronized 的锁机制，允许线程在执行过程中对共享资源进行同步。</li>
<li>BlockingQueue：提供阻塞队列来控制生产者与消费者的消费模式。</li>
<li>CountDownLatch：允许一个或多个线程等待，直到其他线程完成某项操作。</li>
<li>CyclicBarrier：允许多个线程相互等待，直到某个条件满足才继续执行。</li>
<li>Semaphore：用于控制访问共享资源的线程数量，限制并发线程的数量。</li>
</ul>
<h3 id="Java-中如何创建多线程？">Java 中如何创建多线程？</h3>
<p>在Java中创建多线程有几种常见的方式：</p>
<ol>
<li>使用 Thread 类：<br>
通过继承 Thread 类，重写 run() 方法，并调用 start() 来启动线程。这是最基础的方式，但它不够灵活，<strong>任务和线程是绑定在一起的，无法重用任务。</strong></li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;Thread running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">MyThread</span> thread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 Runnable 配合 Thread：<br>
这种方法通过实现 Runnable 接口来<strong>分离任务和线程</strong>。创建一个 Runnable 实例，将其传递给 Thread 来启动线程。这种方式更灵活，任务可以被多个线程重用，且更适合与线程池等高级API一起使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用 FutureTask 配合 Callable：<br>
<strong>当线程需要返回结果时</strong>，使用 Callable 接口代替 Runnable，并配合 FutureTask 来执行任务。<strong>FutureTask 可以获取任务的返回结果，并且支持异常捕获</strong>。</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;<span class="built_in">Integer</span>&gt; task = <span class="literal">new</span> Callable&lt;<span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Integer</span> call() throws Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;<span class="built_in">Integer</span>&gt; futureTask = <span class="literal">new</span> FutureTask&lt;&gt;(task);</span><br><span class="line"><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>(futureTask);</span><br><span class="line"><span class="keyword">thread</span>.start();</span><br><span class="line"><span class="built_in">Integer</span> result = futureTask.get();  <span class="comment">// 阻塞等待结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用线程池 (ExecutorService)：<br>
<strong>使用 ExecutorService 管理线程池</strong>，可以方便地提交 Runnable 或 Callable 任务，适合处理大量并发任务而不需要手动管理线程。</li>
</ol>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">executor.submit<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">&quot;Running in thread pool&quot;</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">executor</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用 CompletableFuture：<br>
Java 8 引入了 CompletableFuture，提供了<strong>更方便的异步任务执行和任务间的依赖关系处理</strong>。<strong>它是基于线程池（默认使用 ForkJoinPool）实现的，可以链式调用不同的异步操作</strong>。</li>
</ol>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    System.out.println(<span class="string">&quot;Async task running&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span>.<span class="title">thenAccept</span><span class="params">(result -&gt; System.out.println(<span class="string">&quot;Task completed&quot;</span>))</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="总结：">总结：</h4>
<ul>
<li>如果只是简单的创建一个线程，可以直接使用 Thread 类。</li>
<li>如果想解耦任务和线程，更灵活且复用性强，推荐使用 Runnable 配合 Thread。</li>
<li>如果需要线程执行后有返回值，使用 Callable 和 FutureTask。</li>
<li>如果有大量并发任务，使用线程池来管理线程。</li>
<li>如果任务之间有依赖关系，使用 CompletableFuture 处理异步任务。</li>
</ul>
<h3 id="你了解-Java-线程池的原理吗？">你了解 Java 线程池的原理吗？</h3>
<p>线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p>
<p>线程池作用：</p>
<ul>
<li>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>
<li>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</li>
<li>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<p>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p>
<p>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p>
<p>线程池的工作原理可以分为几个关键步骤：</p>
<ul>
<li>核心线程数（corePoolSize）：这是线程池中最小的线程数量。即使没有任务，线程池也会维持这些线程处于空闲状态。</li>
<li>最大线程数（maximumPoolSize）：线程池可以创建的最大线程数量。当有大量任务同时到达时，线程池会创建新线程，直到达到最大线程数。</li>
<li>空闲时间（keepAliveTime）：空闲线程在一定时间内没有任务执行时，线程池会回收它们以节省资源。这个时间是可以调节的。</li>
<li>时间单位</li>
<li>工作队列（workQueue）：这是用于保存提交的任务的队列。如果线程池中所有核心线程都在忙碌，任务就会被放入队列等待。</li>
<li>线程工厂（ThreadFactory）：用来创建新线程的工厂，可以自定义线程的创建方式。</li>
<li>拒绝策略（RejectedExecutionHandler）：当线程池中的任务数量达到最大线程数且队列已满时，线程池会采取拒绝策略，<strong>通常包括丢弃任务、抛出异常或者让任务在其他地方执行</strong>。</li>
</ul>
<p>常见的线程池类型包括：</p>
<ul>
<li>FixedThreadPool：一个固定大小的线程池，适用于负载较为稳定的场景。</li>
<li>CachedThreadPool：可以根据需要创建新线程，但在空闲时会回收线程，适用于任务数量不确定，且任务执行时间短的情况。</li>
<li>ScheduledThreadPool：可以定期执行任务或延迟执行任务的线程池。</li>
<li>SingleThreadExecutor：只有一个线程的线程池，适用于串行执行任务的场景。</li>
</ul>
<p>总结来说，线程池是为了避免频繁创建和销毁线程的性能问题，同时也提供了灵活的线程管理和任务调度机制，适用于大规模并发处理的场景。</p>
<p>补充：拒绝策略</p>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/Is34VHXx_Snipaste_2025-11-02_20-27-12_mianshiya.png" alt="Snipaste_2025-11-02_20-27-12.png" width="100%" />
<h3 id="如何合理地设置-Java-线程池的线程数？">如何合理地设置 Java 线程池的线程数？</h3>
<p>对于如何合理地设置 Java 线程池的线程数，可以通过<strong>分析任务的类型</strong>来进行优化。通常，任务类型可以分为两类：<strong>CPU 密集型任务</strong>和<strong>I/O 密集型任务</strong>。</p>
<ol>
<li>
<p><strong>CPU 密集型任务</strong>：<strong>这些任务主要依赖 CPU 进行计算，如数学运算等</strong>。在这种情况下，线程数的设置应根据 CPU 核心数来决定。为了充分利用 CPU 的计算资源，线程池的核心线程数可以设置为 <strong>CPU 核心数 + 1</strong>，这样可以充分利用 CPU 的空闲时间，避免过多线程的竞争。</p>
</li>
<li>
<p><strong>I/O 密集型任务</strong>：这类任务大多依赖 I/O 操作，如文件读写、网络请求等。在进行 I/O 操作时，线程并不占用 CPU 资源，因此可以增加线程池的线程数。通常可以将线程数设置为 <strong>2 倍 CPU 核心数</strong>，因为大多数 I/O 操作会阻塞线程，这时可以充分利用 CPU 执行其他任务。</p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>对于 <strong>CPU 密集型</strong> 任务，线程数应该设置为 <strong>CPU 核心数 + 1</strong>，这样可以避免线程过多导致的上下文切换和 CPU 资源浪费。</li>
<li>对于 <strong>I/O 密集型</strong> 任务，线程数可以设置为 <strong>2 倍 CPU 核心数</strong>，这样可以充分利用线程池的线程而不造成过多阻塞。</li>
</ul>
<p>如果业务中同时有这两种类型的任务，推荐根据任务的比例来动态调整线程池的大小。</p>
<h3 id="Java-线程池有哪些拒绝策略？">Java 线程池有哪些拒绝策略？</h3>
<p>在 Java 中，线程池有四种拒绝策略：</p>
<ul>
<li>默认是 AbortPolicy，也就是<strong>当线程池满了，系统会抛出异常</strong>，提醒你有任务无法被处理。</li>
<li>CallerRunsPolicy 是<strong>让提交任务的线程（调用者线程）自己执行任务</strong>。适合你希望通过减缓任务提交的速度来避免系统过载的场景。</li>
<li>DiscardOldestPolicy 则会<strong>丢弃队列中最旧的任务</strong>，保留新的任务继续执行。如果你希望保留当前任务并丢弃掉早些提交的任务，这个策略就很合适。</li>
<li>DiscardPolicy 是最简单粗暴的，它会<strong>直接丢弃任务</strong>，不做任何处理，适合在高负载时只保留最重要的任务。</li>
</ul>
<h3 id="Java-并发库中提供了哪些线程池实现？它们有什么区别？">Java 并发库中提供了哪些线程池实现？它们有什么区别？</h3>
<p>在 Java 的并发库中，主要有五种常见的线程池实现，它们分别是：</p>
<ul>
<li>FixedThreadPool：这是一个<strong>固定大小的线程池</strong>。线程数是固定的，如果有任务来时，线程池会先检查当前是否有空闲线程，如果有就执行任务，如果没有，它会将任务排队等待。适合任务量稳定的场景。</li>
<li>CachedThreadPool：这个线程池<strong>可以动态调整线程数。线程池会根据任务需求创建新线程</strong>，如果现有的线程没有被使用，它会在60秒后自动回收。这种线程池适合处理大量短时间任务的场景，但如果任务量过多，可能会导致内存溢出（OOM）。</li>
<li>SingleThreadExecutor：这就是一个<strong>单线程池</strong>，它只会有一个线程来执行所有任务。如果一个任务执行失败，后续的任务也会被阻塞，直到当前任务完成。<strong>适用于需要确保任务按顺序执行的场景</strong>。</li>
<li>ScheduledThreadPool：这是一个<strong>支持定时任务的线程池</strong>。它可以定期或延迟执行任务，适用于定时执行任务或延时执行的场景。</li>
<li>WorkStealingPool：这个线程池是<strong>基于工作窃取算法设计</strong>的。它是<strong>从多个线程中窃取工作来优化任务执行</strong>，适用于任务之间相对独立，且负载不均匀的情况。</li>
</ul>
<p><strong>总结：如果你有一堆任务并且任务量比较大，固定线程池和缓存线程池更适合；如果任务量不大，但需要定时执行，使用 ScheduledThreadPool。如果任务之间有很强的顺序性，可以使用 SingleThreadExecutor。如果任务负载不均匀，WorkStealingPool 是一个不错的选择。</strong></p>
<h3 id="Java-线程池核心线程数在运行过程中能修改吗？如何修改？">Java 线程池核心线程数在运行过程中能修改吗？如何修改？</h3>
<p>在 Java 中，我们是可以动态地调整线程池的核心线程数的。可以通过调用 ThreadPoolExecutor 的 setCorePoolSize() 方法来修改核心线程数。需要注意的是，减少核心线程数时，空闲的多余线程不会立刻回收，只有等到它们一段时间没有任务执行后才会被回收。而且，这个修改不会影响正在执行的任务，所以它是即时生效的。</p>
<h3 id="Java-线程池中-shutdown-与-shutdownNow-的区别是什么？">Java 线程池中 shutdown 与 shutdownNow 的区别是什么？</h3>
<ul>
<li>shutdown() 用于优雅地关闭线程池，<strong>它会停止接受新任务，但会继续执行队列中已提交的任务</strong>，直到全部完成为止。</li>
<li>shutdownNow() 会<strong>立即尝试停止所有任务</strong>，返回当前尚未执行的任务列表，并<strong>尽可能通过中断线程来停止正在执行的任务</strong>。如果任务无法处理中断，它们仍然可能继续执行，直到任务完成。</li>
</ul>
<p>这两种方法主要的区别在于是否会强制中断正在执行的任务，shutdown() 是平稳退出，而 shutdownNow() 是立即中止。</p>
<h3 id="Java-线程池内部任务出异常后，如何知道是哪个线程出了异常？">Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？</h3>
<p>在Java的线程池中，如果线程执行的任务抛出异常，<strong>默认情况下线程池并不会主动告诉你是哪个线程出了问题</strong>，但我们有几种方式可以捕获这个异常信息。</p>
<ul>
<li>
<p>首先，如果你使用 ThreadFactory 来创建线程池，<strong>可以自定义 UncaughtExceptionHandler 来处理每个线程中的异常</strong>。这样，线程在遇到未处理的异常时，就会调用 UncaughtExceptionHandler，你可以在其中记录线程的异常信息。</p>
</li>
<li>
<p>其次，在线程任务执行时，我们可以使用 <strong>Future</strong>。当使用 submit() 提交任务时，我们可以通过返回的 Future 对象来检查任务是否执行成功，如果任务有异常，可以通过 get() 方法时候try-catch捕获异常。</p>
</li>
<li>
<p>最后，在<strong>run方法内部</strong>，我们还可以使用 <strong>try-catch</strong> 来捕获异常，避免任务因为异常直接失败。在捕获异常后，我们可以记录或者处理异常，也能确保任务不会导致线程池停止。</p>
</li>
</ul>
<p>总的来说，我们可以通过 ThreadFactory 来为每个线程设置异常处理器，使用 Future 对象来捕获任务异常，并在任务内部加入 try-catch 来处理异常，确保线程池中的任务都能被监控和管理。</p>
<h3 id="Java-中的-DelayQueue-和-ScheduledThreadPool-有什么区别？">Java 中的 DelayQueue 和 ScheduledThreadPool 有什么区别？</h3>
<p>在 Java 中，DelayQueue 和 ScheduledThreadPoolExecutor 都是用于处理延迟任务的工具，但它们的实现原理和使用场景有所不同。</p>
<ol>
<li>DelayQueue：</li>
</ol>
<p>DelayQueue 是一个<strong>阻塞队列</strong>，它<strong>基于元素的延迟时间来控制任务的执行顺序</strong>。每个元素都有一个指定的延迟时间，元素不会立刻被处理，只有在延迟时间到了之后，它才会从队列中被取出执行。</p>
<p>它通常与 ReentrantLock 和 Condition 配合使用，确保任务在合适的时间被执行。</p>
<ol start="2">
<li>ScheduledThreadPoolExecutor：</li>
</ol>
<p>这是一个专门<strong>用于执行定时任务和周期任务的线程池</strong>。它允许你<strong>定期执行任务或延迟执行任务</strong>，常用于周期性任务的调度。</p>
<p>ScheduledThreadPoolExecutor 提供了比 DelayQueue 更灵活的任务调度功能，比如支持固定延迟任务、定时执行等。</p>
<h3 id="什么是-Java-的-Timer？">什么是 Java 的 Timer？</h3>
<p>Java 中的 Timer 是用来<strong>定时执行任务的工具</strong>，通常和<strong>TimerTask</strong>搭配使用，TimerTask是需要执行的任务。你可以用 <strong>schedule() 来延时执行任务</strong>，或者用 <strong>scheduleAtFixedRate() 来做周期性任务</strong>。它内部有一个专门的线程去管理这些任务。</p>
<p>不过，<strong>Timer 是单线程的</strong>，如果任务的执行时间比预定的时间长，可能会影响后续任务的执行，造成任务延迟。因此在高并发场景下，Timer 可能不是最优选择，通常我们会推荐使用 <strong>ScheduledExecutorService 来替代 Timer</strong>，因为它提供了更高效的多线程任务调度。</p>
<h3 id="你了解时间轮（Time-Wheel）吗？有哪些应用场景？">你了解时间轮（Time Wheel）吗？有哪些应用场景？</h3>
<p>时间轮是一种高效的定时任务调度算法，<strong>它通过将时间切分为多个固定的时间槽，并将任务分配到这些时间槽中，来实现任务的定时执行</strong>。当时间轮转到某个槽时，槽内的任务就会执行。这个算法特别适合于需要处理大量定时任务的场景，因为它避免了频繁的时间比较，提升了效率。比如在高并发的网络服务中，时间轮可以用来优化定时任务的调度，减少系统的负担。</p>
<h3 id="你使用过哪些-Java-并发工具类？">你使用过哪些 Java 并发工具类？</h3>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/OqI0Cf8H_Snipaste_2025-11-04_14-15-17_mianshiya.png" alt="Snipaste_2025-11-04_14-15-17.png" width="100%" />
<h3 id="什么是-Java-的-Semaphore？">什么是 Java 的 Semaphore？</h3>
<p>在 Java 中，Semaphore（信号量）是一个用于控制访问共享资源的工具类。<strong>它通过维护一定数量的许可证来管理线程访问资源的权限</strong>，确保在任何时刻，只有限定数量的线程能够访问资源。线程需要先通过 acquire() 获取许可证才能访问资源，使用完毕后必须通过 release() 来释放许可证。它支持两种模式：<strong>公平模式</strong>，线程按照顺序获取许可，<strong>避免饥饿</strong>；<strong>非公平模式</strong>，则是线程可以抢先获取许可证，可能导致<strong>不公平的资源分配</strong>。</p>
<h3 id="什么是-Java-的-CyclicBarrier？">什么是 Java 的 CyclicBarrier？</h3>
<p>CyclicBarrier 是一种同步工具类，<strong>允许一组线程在执行某些任务时相互等待，直到所有线程都到达某个指定的“屏障点”时，才会继续执行</strong>。它通常用于需要协调多个线程按一定顺序执行的场景。</p>
<blockquote>
<p>工作原理：</p>
</blockquote>
<p>CyclicBarrier 内部维护<strong>一个计数器</strong>，表示需要等待的线程数。<strong>每当一个线程执行 await() 方法时，计数器就会减1，直到计数器的值为0，所有等待的线程才会被唤醒，继续执行。</strong></p>
<p>可以通过传入一个 Runnable 的 barrierAction 来定义屏障到达时要执行的操作，这个操作会在所有线程到达屏障后执行。</p>
<blockquote>
<p>应用场景：</p>
</blockquote>
<ul>
<li>并行任务协调：比如，多个线程执行某些计算任务，并且在每个阶段后需要等待其他线程，保证每个阶段都同步进行。</li>
<li>批量任务处理：在分布式计算或者并行任务处理时，可以用来协调多个线程的工作，确保所有线程都完成了某个阶段的工作后才进入下一个阶段。</li>
</ul>
<h3 id="什么是-Java-的-CountDownLatch？">什么是 Java 的 CountDownLatch？</h3>
<p>CountDownLatch 是一个同步辅助工具，属于 JUC（Java 并发工具包）的一部分，<strong>它允许一个线程等待多个线程完成某项任务</strong>。通过一个计数器来实现，每当一个线程完成工作时，就会减少一个数字，当计数器的值减到零时，所有等待的线程将被唤醒并继续执行。</p>
<p>主要功能：</p>
<ul>
<li>等待其他线程完成任务：通过 await() 方法，线程会等待其他线程完成其任务。</li>
<li>减少计数器：当某个线程完成工作时，调用 countDown() 方法将计数器的值减一。</li>
<li>所有线程完成时再执行：当计数器的值减到零时，所有等待的线程会被唤醒，继续执行。</li>
</ul>
<p>应用场景：</p>
<ul>
<li><strong>并行任务的协同工作</strong>：比如有多个线程并行执行任务，主线程需要等所有线程都完成后再继续执行。CountDownLatch 很适合这种场景，比如启动多个线程进行并行处理，主线程在所有线程完成任务后再进行合并处理。</li>
</ul>
<p>比较CountDownLatch 和 CyclicBarrier 的区别</p>
<ul>
<li>CyclicBarrier 是可以重用的，所有线程到达屏障后自动重置。</li>
<li>CountDownLatch 一次性使用，一旦计数器归零就不能再使用。</li>
</ul>
<h3 id="什么是-Java-的-StampedLock？">什么是 Java 的 StampedLock？</h3>
<p>StampedLock 是 Java 8 新增的一种锁机制，它通过<strong>引入乐观读锁提高了性能</strong>，特别适用于<strong>读多写少的场景</strong>。它有三种锁模式：写锁、悲观读锁和乐观读锁。<br>
写锁</p>
<ul>
<li>独占锁，类似于 ReentrantLock 的写锁。它确保其他线程不能获取到写锁或读锁。</li>
</ul>
<p>悲观读锁</p>
<ul>
<li>共享锁，允许多个线程同时获取读锁，但不允许有线程获取写锁。</li>
</ul>
<p>乐观读锁</p>
<ul>
<li>不加锁，允许线程在没有竞争的情况下进行快速读。只有在检测到写操作发生时，它才会回退到悲观读锁。</li>
</ul>
<p>最特别的是，StampedLock 还会返回一个时间戳，代表当前锁的状态，线程可以利用这个时间戳来判断锁是否还有效，从而决定是否继续执行操作。</p>
<h3 id="什么是-Java-的-CompletableFuture？">什么是 Java 的 CompletableFuture？</h3>
<p>在 Java 8 中，<strong>CompletableFuture 是为了简化异步编程而引入的工具</strong>。你可以把它想象成一个<strong>可以在后台执行任务的对象</strong>，它支持异步执行，也就是你可以启动一个任务，它会在后台进行计算，计算结果一旦出来，你可以拿到它做后续处理。</p>
<p>最核心的几个特性是：</p>
<ul>
<li><strong>异步执行</strong>：使用 runAsync() 或 supplyAsync() 方法，你可以<strong>让任务在后台异步执行，这样不会阻塞主线程</strong>。</li>
<li><strong>任务组合</strong>：你可以使用 thenApply() 或 thenAccept() 等方法<strong>在任务完成后进行处理，支持链式调用。</strong></li>
<li><strong>并行任务</strong>：CompletableFuture <strong>允许你同时执行多个任务</strong>，并且可以通过 .allOf() 来<strong>合并这些任务的结果</strong>。</li>
<li><strong>异常处理</strong>：如果异步任务执行过程中出错，你可以<strong>使用 exceptionally() 来处理异常</strong>，避免程序崩溃。</li>
</ul>
<p>CompletableFuture 的优势在于<strong>它让你可以轻松地处理异步操作，特别是当你需要执行多个任务并且希望它们能并行执行时，非常适合用它</strong>。而且，通过链式调用，你可以简化代码逻辑，不需要复杂的回调函数。&quot;</p>
<p>总结<br>
CompletableFuture 是<strong>处理异步编程非常强大的工具</strong>，它提供了各种方法来<strong>执行异步任务，管理结果，处理异常，并支持多个任务的并行执行</strong>，特别适合在<strong>需要高效处理并发任务的场景中使用</strong>。</p>
<h3 id="什么是-Java-的-ForkJoinPool？">什么是 Java 的 ForkJoinPool？</h3>
<p>ForkJoinPool 是 Java 7 引入的一个线程池，主要用来<strong>处理大规模的并行任务</strong>。它采用了“<strong>分而治之</strong>”的方式，<strong>把一个大任务分解成多个小任务进行并行处理</strong>，<strong>所有任务完成后再合并结果</strong>。它的工作方式是通过两个操作：<strong>fork 来分解任务</strong>，<strong>join 来合并结果</strong>。</p>
<p>ForkJoinPool 使用了<strong>工作窃取算法</strong>，ForkJoinPool是WorkStealingPool的底层，<strong>这意味着如果有线程空闲，它会去偷取其他线程没有完成的任务，从而提高并行度和资源利用率</strong>。常见的相关任务类是 RecursiveTask（有返回值的任务）和 RecursiveAction（无返回值的任务）。</p>
<p>这个池子<strong>特别适合用于需要大量并行处理的计算任务，比如大数据处理或者需要执行递归算法的场景</strong>。</p>
<h3 id="如何在-Java-中控制多个线程的执行顺序？">如何在 Java 中控制多个线程的执行顺序？</h3>
<p>在 Java 中，控制多个线程的执行顺序有多种方式，常用的方法包括：</p>
<ol>
<li>
<p><strong>CompletableFuture 的 <code>thenRun</code> 方法</strong>：</p>
<ul>
<li>如果你有多个任务（例如 T1、T2、T3），你可以使用 <code>thenRun</code> 方法来保证这些任务按顺序执行。每个任务会在上一个任务完成后才开始执行。这种方法适合于处理并发任务，并且保证顺序。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123; doTask1(); &#125;)</span><br><span class="line">    .thenRun(() -&gt; &#123; doTask2(); &#125;)</span><br><span class="line">    .thenRun(() -&gt; &#123; doTask3(); &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>synchronized + wait/notify</strong>：</p>
<ul>
<li>使用 <code>synchronized</code> 来加锁，结合 <code>wait</code> 和 <code>notify</code> 来控制线程间的执行顺序。<code>wait</code> 用于让一个线程暂停，直到收到其他线程的通知（<code>notify</code>）才继续执行。</li>
</ul>
</li>
<li>
<p><strong>ReentrantLock 配合 Condition 的 <code>await</code>、<code>signal</code>、<code>signalAll</code></strong>：</p>
<ul>
<li>通过 <code>ReentrantLock</code> 和 <code>Condition</code>，你可以更加细粒度地控制线程的执行顺序。例如，使用 <code>await</code> 使线程等待，直到其他线程通过 <code>signal</code> 或 <code>signalAll</code> 通知它们继续执行。</li>
</ul>
</li>
<li>
<p><strong>CountDownLatch</strong>：</p>
<ul>
<li><code>CountDownLatch</code> <strong>可以用来让多个线程等待直到其他线程完成指定的工作</strong>。通过调用 <code>countDown()</code> 来减少计数，直到计数为零，所有线程才会继续执行。</li>
</ul>
</li>
<li>
<p><strong>CyclicBarrier</strong>：</p>
<ul>
<li><code>CyclicBarrier</code> <strong>允许一组线程在一个公共点等待，直到所有线程都到达这个点后再继续执行</strong>。适用于并行处理多任务，确保每个线程都完成到达某个阶段后再继续。</li>
</ul>
</li>
<li>
<p><strong>Thread 类的 <code>join()</code> 方法</strong>：</p>
<ul>
<li><strong><code>join()</code> 方法可以让一个线程等待另一个线程完成后再执行</strong>。通过调用 <code>join()</code>，主线程可以等待其他线程执行完后再继续。</li>
</ul>
</li>
<li>
<p><strong>LockSupport 的 <code>park</code> 和 <code>unpark</code> 方法</strong>：</p>
<ul>
<li><code>LockSupport</code> 提供了更底层的控制方法，<code>park()</code> 用来挂起线程，<code>unpark()</code> 用来恢复线程的执行。</li>
</ul>
</li>
<li>
<p><strong>Semaphore</strong>：</p>
<ul>
<li><code>Semaphore</code> 控制并发的线程数量，适用于控制访问某些资源的线程数量。通过设置许可数来限制并发线程的数量。</li>
</ul>
</li>
<li>
<p><strong>ExecutorService 的单线程执行</strong>：</p>
<ul>
<li>如果不关心线程池中的线程，<code>ExecutorService</code> 提供了顺序执行任务的功能，可以将任务提交给一个单线程执行。</li>
</ul>
</li>
</ol>
<h4 id="小结：">小结：</h4>
<ul>
<li><strong>最简洁</strong>的方式是 <code>Thread.join()</code>，非常直接，适合顺序依赖的场景。</li>
<li>如果你需要更复杂的控制，比如多个线程并发执行后再同步，使用 <code>CountDownLatch</code> 或 <code>CyclicBarrier</code> 更合适。</li>
<li>你可以根据任务的复杂度选择适合的工具，比如 <code>ReentrantLock</code> 和 <code>Condition</code> 提供更细粒度的控制。</li>
</ul>
<h3 id="你使用过-Java-中的哪些阻塞队列？">你使用过 Java 中的哪些阻塞队列？</h3>
<p>Java 提供了几种常见的阻塞队列，主要用于在多线程环境下处理线程间的任务传递。常见的有：</p>
<ul>
<li><strong>ArrayBlockingQueue</strong>：这是一个<strong>基于数组实现</strong>的队列，容量固定。生产者往队列里放数据时，如果队列满了，就会被阻塞；消费者取数据时，如果队列空了，也会被阻塞。<strong>适用于生产者-消费者模型</strong>。</li>
<li><strong>LinkedBlockingQueue</strong>：这是<strong>基于链表实现</strong>的队列，<strong>可以是有界的也可以是无界的</strong>。它在队列满时阻塞生产者，在队列空时阻塞消费者。</li>
<li><strong>PriorityBlockingQueue</strong>：这个队列<strong>没有容量限制</strong>，且任务<strong>按优先级排队</strong>。<strong>优先级高的任务会先被处理</strong>，适合需要优先级调度的场景。</li>
<li><strong>DelayQueue</strong>：这是一个专门<strong>处理延迟任务的队列</strong>，<strong>只有当任务的延迟时间到达时，才能取出</strong>。这适合用在需要定时执行的任务中。</li>
<li><strong>SynchronousQueue</strong>：这个队列没有任何容量，每一个put操作必须等待一个take操作。因此，它常用于<strong>线程之间直接的任务传递</strong>。</li>
<li><strong>TransferQueue</strong>：它是<strong>在LinkedBlockingQueue的基础上新增了transfer方法的队列</strong>。put操作不会立即阻塞，直到有一个take操作时，队列才会执行传递任务。</li>
</ul>
<h3 id="你使用过-Java-中的哪些原子类？">你使用过 Java 中的哪些原子类？</h3>
<p>在多线程编程中，有时候我们需要对共享数据进行操作，这时<strong>为了避免线程冲突和数据不一致的问题，我们通常会使用 Java 中的原子类</strong>。它们通过内置的原子性操作来确保线程安全，避免了传统的加锁操作。</p>
<p>最常用的原子类包括：</p>
<ul>
<li><strong>AtomicInteger</strong> 用来原子地增加或减少整数，比如在计数器等场景下；</li>
<li>AtomicLong 是 AtomicInteger 的长整型版本；</li>
<li>AtomicBoolean 用于处理布尔值，适用于类似于标志位的场景；</li>
<li><strong>AtomicReference</strong> 适用于<strong>引用类型的数据</strong>，能保证在多线程环境中更新对象的引用；</li>
<li><strong>AtomicStampedReference 则解决了 ABA 问题，它通过添加一个版本号来避免由于值相同导致的误判断。</strong></li>
<li>如果需要对数组中的每个元素进行类似的原子操作，可以使用 AtomicIntegerArray 和 AtomicLongArray。</li>
</ul>
<h3 id="你使用过-Java-的累加器吗？">你使用过 Java 的累加器吗？</h3>
<p>前提：为什么需要累加器？</p>
<p>AtomicLong 在并发很高时，所有线程都会去竞争同一个变量的 CAS 操作，导致严重的总线争用（CPU cache contention），性能急剧下降。</p>
<p>什么是java中的累加器？</p>
<p>在 Java 中，“累加器”通常指的是 LongAdder 和 DoubleAdder 这两个类。</p>
<p>它们是 JDK 1.8 引入的，目的是在高并发场景下提升计数性能，是对传统 AtomicLong、AtomicDouble 的优化。</p>
<p>LongAdder和DoubleAdder它们内部通过维护多个分段计数单元（Cell），让不同线程通过CAS更新不同的单元，最后再汇总求和，从而降低 CAS 冲突，提升性能。</p>
<h3 id="什么是-Java-的-CAS（Compare-And-Swap）操作？">什么是 Java 的 CAS（Compare-And-Swap）操作？</h3>
<p>CAS，全称是 Compare And Swap（比较并交换），是一种<strong>实现并发中原子操作的机制</strong>。</p>
<p>在修改一个变量时，CAS 会：</p>
<p>1.先读取变量当前的值（内存值）；<br>
2.与期望值比较；</p>
<ul>
<li>2.1如果相等，则将变量更新为新值；</li>
<li>2.2如果不相等，说明其他线程修改过该值，则更新失败，通常会选择自旋重试。</li>
</ul>
<p>CAS 的<strong>底层是由 CPU 的原子指令</strong>（如 x86 的 CMPXCHG） 实现的，<strong>整个过程是不可中断的</strong>，因此能保证操作的原子性。</p>
<h4 id="CAS-的优点">CAS 的优点</h4>
<ul>
<li><strong>无锁并发</strong>：<strong>在不使用传统锁的情况下，也能保证线程安全</strong>，提高并发性能。</li>
<li><strong>原子性保障</strong>：<strong>借助硬件级别的指令支持</strong>，确保修改操作不会被打断。</li>
</ul>
<h4 id="CAS-的缺点与解决方案">CAS 的缺点与解决方案</h4>
<p>1.ABA 问题</p>
<ul>
<li>问题：一个变量从 A → B → A，CAS 检查时发现值没变，但实际上经历了变化。</li>
<li>解决：使用版本号机制，如AtomicStampedReference，在 CAS 时同时比较值和版本号。</li>
</ul>
<p>2.自旋开销大</p>
<ul>
<li>问题：如果多个线程频繁失败，会导致长时间自旋，浪费 CPU 资源。</li>
<li>解决：在一些高并发组件（如 SynchronousQueue）中限制自旋次数或结合锁机制使用。</li>
</ul>
<blockquote>
<p>CAS+锁这一套组合挺常见比如CourrentHashMap就是这样实现的，CAS 用于无锁写入，如果冲突严重再退化为锁定特定桶的头结点。</p>
</blockquote>
<p>3.只能操作一个共享变量<br>
问题：CAS 只能针对单一变量进行原子操作。<br>
解决：使用 AtomicReference 将多个变量封装为一个对象，实现复合 CAS。</p>
<h4 id="总结一句话">总结一句话</h4>
<p>CAS 是一种基于 CPU 原子指令的无锁机制，通过比较内存值和预期值，一致则更新，否则重试。</p>
<p>它的优点是高并发、无锁和线程安全，但缺点是可能出现 ABA问题、自旋开销大、无法操作多个变量，可以通过版本号或 AtomicReference 来优化</p>
<h3 id="说说-AQS-吧？">说说 AQS 吧？</h3>
<p>一.AQS 是什么</p>
<p>AQS，全称 AbstractQueuedSynchronizer（抽象队列同步器），是 JUC（java.util.concurrent）包中构建锁和同步器的基础框架。</p>
<p>AQS起到了一个抽象、封装的作用，将一些排队、入队、加锁、中断等方法提取出来，便于其他相关JUC锁的使用，具体加锁时机、入队时机等都需要实现类自己控制(它通过统一的同步状态管理和队列机制，简化了各种同步器（如锁、信号量、栅栏）的实现)。</p>
<p>二.AQS 的核心思想</p>
<p>AQS 通过维护一个同步状态变量（state）和一个FIFO 等待队列，来管理多个线程对共享资源的竞争。</p>
<ol>
<li>同步状态（state）</li>
</ol>
<ul>
<li>
<p>是一个 volatile int 变量，表示资源的占用情况。</p>
</li>
<li>
<p>对于独占锁：state = 0 表示未加锁，state = 1 表示已加锁。</p>
</li>
<li>
<p>对于共享锁：state 表示可同时获取锁的线程数（例如 Semaphore 的剩余许可数）。</p>
</li>
<li>
<p>等待队列（FIFO）</p>
</li>
<li>
<p>当线程获取锁失败时，会被封装为一个 Node 节点加入队列尾部。</p>
</li>
<li>
<p>当锁被释放时，AQS 会唤醒队列中第一个等待线程尝试获取锁。</p>
</li>
<li>
<p>队列是一个基于 CLH（Craig, Landin, and Hagersten） 算法实现的双向链表结构，保证线程排队公平。</p>
</li>
</ul>
<p>三、AQS 的工作流程</p>
<ul>
<li>
<p>线程尝试获取锁 → 修改 state（CAS 操作）。</p>
</li>
<li>
<p>如果失败 → 封装为 Node 节点加入队列，进入等待状态。</p>
</li>
<li>
<p>当前持锁线程释放锁后 → AQS 唤醒队列中的下一个节点线程。</p>
</li>
</ul>
<p>这样，AQS 就实现了一个通用的“排队获取锁”机制。</p>
<p>四、AQS 的典型实现类</p>
<p>基于 AQS 的同步组件包括：</p>
<ul>
<li>
<p>独占模式：ReentrantLock</p>
</li>
<li>
<p>共享模式：Semaphore、CountDownLatch、ReentrantReadWriteLock</p>
</li>
<li>
<p>条件队列：Condition（基于 AQS 的条件队列实现）</p>
</li>
</ul>
<p>五.总结一句话（精简口述版）</p>
<p>AQS 是 JUC 中实现各种锁和同步工具的核心框架。</p>
<p>它通过一个 state 状态变量和一个 FIFO 队列来管理线程的竞争。</p>
<p>加锁失败的线程会进入队列排队，释放锁后再唤醒队首线程。</p>
<p>常见的实现类包括 ReentrantLock、Semaphore、CountDownLatch 等。</p>
<p>一句话记忆口诀：</p>
<p>AQS：<strong>一个 state + 一个队列，构建所有并发锁</strong>。</p>
<h3 id="Java-中-ReentrantLock-的实现原理是什么？">Java 中 ReentrantLock 的实现原理是什么？</h3>
<p>ReentrantLock 实现原理</p>
<p>一、ReentrantLock 是基于 AQS 的实现</p>
<p>ReentrantLock 是 Java 中基于 AQS（AbstractQueuedSynchronizer） 的锁实现。</p>
<p>它支持以下特性：</p>
<ul>
<li>
<p>可重入性：同一线程可以多次获取锁。</p>
</li>
<li>
<p>公平与非公平：支持公平锁和非公平锁的选择。</p>
</li>
<li>
<p>可中断：可以响应中断，避免死锁。</p>
</li>
</ul>
<p>二、ReentrantLock 的内部结构</p>
<p>内部通过一个state变量和两个队列（同步队列和等待队列）来实现</p>
<p>1.state 变量</p>
<p>ReentrantLock 使用一个 state（通常是一个整数）来记录锁的状态。</p>
<p>例如，state = 0 表示锁没有被占用，state &gt; 0 表示锁已被线程占用，state 值还表示该线程持有锁的次数。</p>
<ol start="2">
<li>同步队列（Sync Queue）</li>
</ol>
<p>用于存放所有等待获取锁的线程，是一个双向链表。线程在获取锁失败时会被加入同步队列，按照 FIFO 排队，直到锁可用。</p>
<p>3.等待队列（Condition Queue）</p>
<p>用于存放等待特定条件的线程，即使用 Condition 时会涉及到的队列，存放需要等待某些条件才能继续执行的线程。它是一个单向链表。</p>
<p>三、锁的公平性机制</p>
<ul>
<li>公平锁（Fair Lock）：</li>
</ul>
<p>当请求锁时，公平锁会判断当前线程是否是同步队列的第一个线程。如果是，它会尝试获取锁。如果不是，它会等到前面的线程释放锁后再尝试获取。公平锁避免了“饥饿”问题，保证线程按照请求的顺序获取锁。</p>
<ul>
<li>非公平锁（Non-fair Lock）：</li>
</ul>
<p>非公平锁则不会强制按照队列顺序获取锁，它会直接尝试获取锁，如果失败才会加入同步队列。这使得非公平锁获取锁的速度更快，但可能会导致一些线程长时间得不到锁（即“线程饥饿”问题）。</p>
<p>四、获取锁的过程</p>
<p>在 公平锁 中，获取锁时：</p>
<ul>
<li>
<p>首先判断当前线程是否为同步队列的第一个线程，或者同步队列是否为空。</p>
</li>
<li>
<p>如果是第一个线程，则尝试获取锁。</p>
</li>
<li>
<p>否则，当前线程会加入队列，等待前一个线程释放锁后再尝试。</p>
</li>
</ul>
<p>在 非公平锁 中，获取锁时：</p>
<ul>
<li>直接尝试获取锁，不做任何排队判断，如果获取失败，才加入同步队列进行排队。</li>
</ul>
<p>五、总结</p>
<p>ReentrantLock 是一个非常强大的锁，它不仅提供了可重入性，还通过 AQS 实现了灵活的线程排队机制。</p>
<p>通过选择 公平锁 或 非公平锁，可以根据具体场景优化性能。</p>
<p>精简口述版</p>
<p>ReentrantLock 是基于 AQS 实现的，支持可重入、可中断以及公平/非公平模式。</p>
<p>它通过一个 state 变量和两个队列（同步队列、等待队列）管理线程。同步队列用于排队获取锁的线程，等待队列则用于存放等待特定条件的线程。</p>
<p>公平锁会优先考虑队列中第一个线程，而非公平锁则直接尝试获取锁，效率更高，但可能导致线程饥饿。</p>
<h3 id="Java-的-synchronized-是怎么实现的？">Java 的 synchronized 是怎么实现的？</h3>
<p>一、synchronized 的实现原理</p>
<p>synchronized 是 Java 中最基础的同步手段，它依赖 JVM 内部的 Monitor（监视器锁） 来实现线程同步。</p>
<p>每个对象在 JVM 层面都与一个 Monitor 相关联，当线程获取对象锁时，实际上就是获取了这个对象的 Monitor。</p>
<p>同时，synchronized 的加锁信息存储在对象的 对象头（Object Header） 中。</p>
<p>对象头包含 Mark Word 字段，其中记录了锁的状态（无锁、偏向锁、轻量级锁、重量级锁等）以及线程 ID 等信息。</p>
<p>二、synchronized 在字节码层面的实现</p>
<p>1.修饰方法</p>
<p>当 synchronized 修饰方法时，编译器会在该方法的字节码中添加一个 ACC_SYNCHRONIZED 标志位。</p>
<ul>
<li>
<p>当线程调用该方法时，JVM 会自动尝试获取该方法所属对象的 Monitor。</p>
</li>
<li>
<p>如果获取成功，执行方法体；否则线程会阻塞等待。</p>
</li>
<li>
<p>方法执行完毕后，JVM 会自动释放锁。</p>
</li>
</ul>
<ol start="2">
<li>修饰代码块</li>
</ol>
<p>当 synchronized 修饰代码块时，编译后的字节码会在同步代码块前后生成：</p>
<ul>
<li>
<p>monitorenter（进入同步块，加锁）</p>
</li>
<li>
<p>monitorexit（退出同步块，释放锁）</p>
</li>
</ul>
<p>这两个字节码指令配合使用，确保线程执行完同步代码后锁能被正确释放。</p>
<p>三、synchronized 的锁优化机制</p>
<p>从 JDK 1.6 开始，JVM 对 synchronized 进行了多次性能优化，引入了锁的四种状态：</p>
<ul>
<li>无锁（Unlocked）</li>
<li>偏向锁（Biased Lock）</li>
<li>轻量级锁（Lightweight Lock）</li>
<li>重量级锁（Heavyweight Lock）</li>
</ul>
<p>锁会根据竞争情况在这几种状态之间自动升级，以提升并发性能。</p>
<p>四、总结一句话（精简口述版）</p>
<p>synchronized 是基于 JVM 实现的同步机制，通过对象的 Monitor（监视器锁） 来保证线程安全。</p>
<p>修饰方法时，会在方法标志中添加 ACC_SYNCHRONIZED 标志；</p>
<p>修饰代码块时，通过 monitorenter / monitorexit 字节码实现加锁和解锁。</p>
<p>另外，从 JDK1.6 起，JVM 还通过偏向锁、轻量级锁等机制对它进行了性能优化。</p>
<p>一句话口诀：</p>
<p>Monitor + Object Header + 字节码指令 = synchronized 的底层实现</p>
<h3 id="Synchronized-修饰静态方法和修饰普通方法有什么区别？">Synchronized 修饰静态方法和修饰普通方法有什么区别？</h3>
<p>synchronized 修饰静态方法：锁住的是类的 Class 对象，因此所有该类的实例共享同一把锁，多个线程调用同一个类的静态同步方法时会互斥执行。</p>
<p>synchronized 修饰实例方法：锁住的是当前对象实例，每个实例有自己独立的锁，不同实例之间可以并发执行同步方法；但同一个实例的多个线程调用实例方法时会互斥执行。</p>
<p>总结：</p>
<ul>
<li>
<p>synchronized 修饰 静态方法 时锁住的是 类级别的锁。</p>
</li>
<li>
<p>synchronized 修饰 实例方法 时锁住的是 实例级别的锁。</p>
</li>
</ul>
<h3 id="Java-中的-synchronized-轻量级锁是否会进行自旋？">Java 中的 synchronized 轻量级锁是否会进行自旋？</h3>
<p><strong>jdk8</strong>中轻量级锁 CAS失败了之后，会直接进入重量级锁膨胀过程。</p>
<p>重量级锁竞争失败会有自旋操作，轻量级锁没有这个动作。</p>
<h3 id="Synchronized-能不能禁止指令重排序？">Synchronized 能不能禁止指令重排序？</h3>
<ul>
<li>
<p>synchronized 本身并不能完全禁止指令重排序。但是它能够通过 内存屏障 保证 线程的可见性和有序性，在加锁和解锁操作时，JVM 会插入合适的内存屏障来保证语义上的顺序性。</p>
</li>
<li>
<p>volatile 更能保证禁止指令重排序，并且它保证变量的 可见性，但是 不能保证原子性，也无法像 synchronized 一样提供 互斥锁。</p>
</li>
</ul>
<p>总结:是否可以禁止指令重排序？</p>
<p>synchronized 能在一定程度上防止指令重排序，但不如 volatile 那么直接。</p>
<p>如果你需要更严格地禁止指令重排序，使用 volatile 更加合适。</p>
<h3 id="当-Java-的-synchronized-升级到重量级锁后，所有线程都释放锁了，此时它还是重量级锁吗？">当 Java 的 synchronized 升级到重量级锁后，所有线程都释放锁了，此时它还是重量级锁吗？</h3>
<ul>
<li>
<p>如果在重量级锁状态下，所有线程都释放了锁，那么该锁就会恢复为可用状态，也就是没有任何线程持有该锁(无锁状态)。</p>
</li>
<li>
<p>当下次有线程尝试获取锁时，JVM 会根据当前的线程竞争情况决定是否继续使用重量级锁，或者降级为轻量级锁甚至偏向锁。</p>
</li>
</ul>
<h3 id="什么是-Java-中的锁自适应自旋？">什么是 Java 中的锁自适应自旋？</h3>
<p>自适应锁是一种用来优化并发性能的锁机制，特别是在低竞争环境下。当多个线程争用同一个锁时，JVM 会首先尝试自旋，让线程在短时间内不断尝试获取锁，避免频繁的上下文切换。</p>
<ul>
<li>
<p>在锁竞争较轻的情况下，自旋会节省CPU资源，并且可以提高并发性能。</p>
</li>
<li>
<p>如果自旋失败，JVM 会根据当前的竞争情况动态调整自旋次数，避免线程一直在自旋而浪费过多的CPU时间。</p>
</li>
<li>
<p>自适应锁通过这种方式，减少了阻塞锁的开销，但如果线程竞争激烈，最终会转为重量级锁，并导致线程的阻塞和上下文切换。</p>
</li>
</ul>
<p>优点：</p>
<ul>
<li>
<p>在低竞争的环境中，避免了线程频繁的挂起和唤醒，提高了效率。</p>
</li>
<li>
<p>相比于传统的锁，能更有效地减少锁的竞争。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>自旋会浪费CPU资源，尤其在锁竞争非常激烈的情况下，线程会一直在自旋等待，反而会增加CPU的负担。</li>
</ul>
<h3 id="Synchronized-和-ReentrantLock-有什么区别？">Synchronized 和 ReentrantLock 有什么区别？</h3>
<p>1.实现机制：</p>
<ul>
<li>
<p>Synchronized 是 Java 中的关键字，基于 JVM 层面通过 Monitor（监视器锁） 实现同步。</p>
</li>
<li>
<p>ReentrantLock 是 java.util.concurrent 包下的类，基于 AQS（抽象队列同步器） 实现，通过自定义同步器来实现锁的获取和释放。</p>
</li>
</ul>
<p>2.锁的获取和释放：</p>
<ul>
<li>
<p>Synchronized 是隐式获取锁，线程进入同步代码块或方法时自动获取锁，执行完毕自动释放锁。</p>
</li>
<li>
<p>ReentrantLock 需要显式调用 lock() 获取锁，调用 unlock() 释放锁，灵活性更强。</p>
</li>
</ul>
<p>3.锁的公平性：</p>
<ul>
<li>
<p>Synchronized 默认是非公平锁，线程的获取顺序不一定按照请求顺序。</p>
</li>
<li>
<p>ReentrantLock 默认是非公平锁，也可以通过构造函数设置为公平锁，保证按照请求顺序获取锁，但可能会降低性能。</p>
</li>
</ul>
<p>4.锁的重入性：</p>
<ul>
<li>
<p>Synchronized 是可重入锁，同一个线程可以多次获取同一个锁。</p>
</li>
<li>
<p>ReentrantLock 也是可重入锁，通过内部计数器管理重入次数，直到重入次数为0时才真正释放锁。</p>
</li>
</ul>
<p>5.性能：</p>
<ul>
<li>
<p>Synchronized 在 JDK1.6 之前性能较差，但 JDK 1.6 之后进行了优化，支持偏向锁、轻量级锁等。</p>
</li>
<li>
<p>ReentrantLock 功能更强大，支持条件变量、读写锁等，适用于复杂的并发场景。</p>
</li>
</ul>
<h3 id="Volatile-与-Synchronized-的区别是什么？">Volatile 与 Synchronized 的区别是什么？</h3>
<p><code>volatile</code> 和 <code>synchronized</code> 都是 Java 中用于实现线程安全的机制，但是它们的工作原理和使用场景有很大的不同。</p>
<ol>
<li>
<p><strong><code>volatile</code> 变量：</strong></p>
<ul>
<li><code>volatile</code> <strong>用于保证某个变量的可见性</strong>。<strong>它能确保当一个线程修改了 <code>volatile</code> 变量的值后，其他线程能够立即看到这个更新</strong>。也就是说，<strong>它确保所有线程读取该变量时，会直接从主内存中读取，而不是从线程自己的缓存中读取</strong>。</li>
<li>但是，<code>volatile</code> 只<strong>保证了“可见性”，并不能保证“原子性”</strong>。比如你想执行 <code>i++</code> 这样的操作，虽然 <code>volatile</code> 会保证变量值的最新性，但由于这不是一个原子操作，多个线程同时修改同一个 <code>volatile</code> 变量时，仍然会出现竞争条件。</li>
</ul>
</li>
<li>
<p><strong><code>synchronized</code> 关键字：</strong></p>
<ul>
<li><code>synchronized</code> 是用来修饰方法或代码块的，它通过加锁的方式<strong>确保同一时刻只有一个线程可以执行该方法或代码块。这不仅保证了变量的可见性，还保证了操作的“原子性”</strong>。</li>
<li>使用 <code>synchronized</code> 会引起<strong>性能开销</strong>，因为它需要获取和释放锁。锁的获取和释放会导致线程阻塞，尤其是多个线程争用锁时，可能会发生上下文切换，影响性能。</li>
</ul>
</li>
</ol>
<p><strong>关键区别总结：</strong></p>
<ul>
<li><code>volatile</code> 主要保证变量的<strong>可见性</strong>，但不能保证<strong>原子性</strong>。</li>
<li><code>synchronized</code> 不仅保证变量的可见性，还能保证操作的<strong>原子性</strong>，但会导致线程的<strong>性能开销</strong>，因为它涉及到加锁和释放锁。</li>
</ul>
<h3 id="如何优化-Java-中的锁的使用？">如何优化 Java 中的锁的使用？</h3>
<p><strong>优化 Java 中锁的使用</strong></p>
<ul>
<li>首先要<strong>减少锁的持有时间</strong>。尽量缩小锁定范围，避免长时间占用锁资源。</li>
<li>其次，<strong>减少锁的粒度</strong>，可以通<strong>过加细粒度的锁</strong>来提高并发性，例如使用<strong>读写锁（ReadWriteLock）</strong> 来处理读多写少的场景。</li>
<li>最后我们要<strong>减少锁的使用</strong>：而在一些简单的并发场景中，我们可以用 <strong>CAS 操作或者原子类</strong>（比如 AtomicInteger）来代替传统的锁，避免不必要的性能损失。</li>
</ul>
<h3 id="你了解-Java-中的读写锁吗？">你了解 Java 中的读写锁吗？</h3>
<p><strong>读写锁</strong>（<code>ReadWriteLock</code>）是<strong>为了优化多线程环境下的读操作</strong>而设计的。Java 中的 <code>ReentrantReadWriteLock</code> 是实现该锁的一个主要工具。</p>
<ul>
<li><strong>读锁</strong>（Read Lock）：<strong>允许多个线程同时读取共享资源，只要没有线程在写入</strong>。这就避免了读线程之间的互斥，提升了系统的并发性。</li>
<li><strong>写锁</strong>（Write Lock）：是<strong>独占锁</strong>，<strong>在一个线程获取写锁后，其他所有读写操作都无法进行，直到该线程释放写锁</strong>。这保证了数据的一致性。</li>
</ul>
<p><strong>ReentrantReadWriteLock</strong> <strong>允许一个线程在获取写锁后，也可以重新获取它，这使得它支持递归锁（Reentrant）。而且，它还支持将读锁和写锁分开，极大提升了多线程读取时的效率。</strong></p>
<h4 id="总结：-2">总结：</h4>
<ul>
<li><strong>读锁和写锁分开</strong>，多个读线程可以并发访问，<strong>写线程必须等所有读线程完成后才能访问</strong>。</li>
<li><strong>适用场景</strong>：特别适合<strong>读多写少</strong>的场景，比如<strong>缓存、日志</strong>等高并发读取的系统。</li>
</ul>
<h3 id="什么是-Java-内存模型（JMM）">什么是 Java 内存模型（JMM）?</h3>
<p>Java 内存模型是 Java Memory Model（JMM），本身是一种抽象的概念，实际上并不存在，<strong>描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</strong>.</p>
<blockquote>
<p>为什么需要JMM?</p>
</blockquote>
<ul>
<li>屏蔽各种硬件和操作系统的内存访问差异，<strong>实现让 Java 程序在各种平台下都能达到一致的内存访问效果</strong></li>
<li>规定了线程和内存之间的一些关系</li>
</ul>
<p>JMM 主要关注三大特性：<strong>可见性、原子性和有序性</strong>。</p>
<ol>
<li>
<p><strong>可见性</strong>：<br>
<strong>保证一个线程对变量的修改，其他线程能立即看到</strong>。比如，使用 <strong><code>volatile</code></strong> 关键字可以保证一个线程修改变量后，其他线程能立刻从主内存中读取到修改后的值。</p>
</li>
<li>
<p><strong>原子性</strong>：<br>
<strong>保证对共享变量的操作是不可分割的</strong>，某个线程执行时，不会被其他线程打断。Java 的原子类（如 <code>AtomicInteger</code>）就确保了对变量的原子操作。</p>
</li>
<li>
<p><strong>有序性</strong>：</p>
</li>
</ol>
<ul>
<li>
<p><strong>保证指令的执行顺序不会被打乱，确保代码的执行顺序符合程序的设计逻辑</strong>。例如，<code>synchronized</code> 关键字能够确保同一时刻只有一个线程能够访问某个代码块，保证操作的顺序执行。</p>
</li>
<li>
<p>happens-before 原则：JMM 定义了 happens-before 规则，用于约束操作之间的有序性。如果一个操作 A happens-before 操作 B，那么 A 的结果对于 B 是可见的，且 A 的执行顺序在 B 之前。</p>
</li>
</ul>
<p>简而言之，JMM 就是一个<strong>为多线程提供规范和规则的机制</strong>，它保证了多个线程间的同步和内存一致性问题。</p>
<h3 id="什么是-Java-中的原子性、可见性和有序性？">什么是 Java 中的原子性、可见性和有序性？</h3>
<p><strong>可见性</strong>：</p>
<ul>
<li><strong>保证一个线程对变量的修改，其他线程能立即看到</strong>。比如，使用 **volatile **关键字可以保证一个线程修改变量后，其他线程能立刻从主内存中读取到修改后的值。</li>
</ul>
<p><strong>原子性</strong>：</p>
<ul>
<li><strong>保证对共享变量的操作是不可分割的，某个线程执行时，不会被其他线程打断</strong>。Java 的原子类（如 AtomicInteger）就确保了对变量的原子操作。</li>
</ul>
<p><strong>有序性</strong>：</p>
<ul>
<li><strong>保证指令的执行顺序不会被打乱，确保代码的执行顺序符合程序的设计逻辑</strong>。例如，synchronized 关键字能够确保同一时刻只有一个线程能够访问某个代码块，保证操作的顺序执行。</li>
<li><strong>happens-before</strong> 原则：JMM 定义了 happens-before 规则，用于约束操作之间的有序性。如果一个操作 A happens-before 操作 B，那么 A 的结果对于 B 是可见的，且 A 的执行顺序在 B 之前。</li>
</ul>
<h3 id="什么是-Java-的-happens-before-规则？">什么是 Java 的 happens-before 规则？</h3>
<p>happens-before 是 JMM 中用于规定 <strong>“内存可见性与执行顺序</strong>” 的<strong>逻辑关系</strong>。<br>
如果 A happens-before B，那么：</p>
<ul>
<li>A 的执行结果对 B 是可见的</li>
<li>A 一定发生在 B 之前</li>
</ul>
<p>happens-before 的 8 条规则（JSR-133 规定）</p>
<table>
<thead>
<tr>
<th>规则编号</th>
<th>描述</th>
<th>举例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>程序顺序规则：一个线程中语句按写的顺序执行</td>
<td><code>int x=1; int y=x+1;</code></td>
</tr>
<tr>
<td>②</td>
<td>监视器规则：解锁 happens-before 随后的加锁（同一锁对象）</td>
<td><code>synchronized(obj)</code> 块之间</td>
</tr>
<tr>
<td>③</td>
<td>volatile 规则：volatile 写 happens-before 随后的读</td>
<td><code>volatile boolean flag</code></td>
</tr>
<tr>
<td>④</td>
<td>线程启动规则：start () happens-before 线程内任何操作</td>
<td><code>main线程调用 t.start()</code></td>
</tr>
<tr>
<td>⑤</td>
<td>线程终止规则：线程内操作 happens-before 其他线程检测它结束</td>
<td><code>t.join()</code> 或 <code>!t.isAlive()</code></td>
</tr>
<tr>
<td>⑥</td>
<td>线程中断规则：interrupt () happens-before 被检测到中断</td>
<td><code>t.interrupt()</code> 后用 <code>isInterrupted()</code> 检测</td>
</tr>
<tr>
<td>⑦</td>
<td>对象终结规则：构造完成 happens-before finalize ()</td>
<td>Java GC 自动触发</td>
</tr>
<tr>
<td>⑧</td>
<td>传递性：A hb→B，B hb→C，则 A hb→C</td>
<td>A 设置值 → B 发信号 → C 读取所有结果</td>
</tr>
</tbody>
</table>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/lNVo2Sgh_Snipaste_2025-11-04_18-31-59_mianshiya.png" alt="Snipaste_2025-11-04_18-31-59.png" width="100%" />
<h3 id="什么是-Java-中的指令重排？">什么是 Java 中的指令重排？</h3>
<p>指令重排是现代<strong>处理器和编译器用来优化代码执行的一种手段</strong>，它通过改变指令的执行顺序来提高程序的性能。</p>
<blockquote>
<p>为什么要有指令重排这项优化呢？从 CPU 执行指令的原理来理解一下吧</p>
</blockquote>
<p>为什么 CPU 要重排？</p>
<p>为了提高性能，现代 CPU 实现了以下机制：</p>
<ol>
<li>指令流水线（Pipeline）</li>
</ol>
<p>五级流水线：取指令 → 指令译码 → 执行 → 访存 → 写回<br>
每条指令被分成多个阶段，这些阶段可以被多个指令<strong>并行执行</strong>。</p>
<p>这样做可以<strong>提高吞吐率</strong>（Throughput）。</p>
<ol start="2">
<li>超标量（SuperScalar）</li>
</ol>
<p>现代 CPU 拥有多个执行单元（如整数、浮点、加载单元）<br>
可以在一个时钟周期内<strong>执行多条指令</strong>，即 IPC &gt; 1（Instruction per Clock）</p>
<h4 id="指令重排的弊端">指令重排的弊端</h4>
<p>指令重排有时会导致<strong>并发程序中的问题，尤其是在多线程环境下</strong>。举个例子，<strong>假设有两个线程A和B，A执行某个任务后修改一个共享变量，B线程读取这个变量。如果没有适当的同步机制，由于指令重排，B可能会在A尚未修改变量时读取到一个不一致的值</strong>，这可能导致程序出现错误。</p>
<blockquote>
<p>JMM 如何应对重排？</p>
</blockquote>
<p>Java 内存模型（JMM）允许重排序，<strong>但通过 Happens-Before 规则和 volatile/synchronized 等机制来屏蔽 “坏的重排”</strong>。</p>
<h4 id="扩展-演示一下指令重排">扩展- 演示一下指令重排</h4>
<ol>
<li>诡异的结果</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> ready = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会觉得结果只有：</p>
<p>1：因为 ready == false<br>
4：因为 ready == true 且 num = 2<br>
但事实上，还可能出现一个诡异的结果：<code>r1  == 0</code></p>
<ol start="2">
<li>为什么会出现 r1 == 0？</li>
</ol>
<p>这是 指令重排（Instruction Reordering） 的锅：</p>
<p>actor2 看似顺序是：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">num</span> = <span class="number">2</span><span class="comment">;</span></span><br><span class="line"><span class="attr">ready</span> = <span class="literal">true</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>但实际上，JIT 编译器或 CPU 为了性能可能重排序为：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ready</span> = <span class="literal">true</span><span class="comment">;</span></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>线程交叉执行导致问题<br>
设想线程切换如下：</li>
</ol>
<table>
<thead>
<tr>
<th>时间</th>
<th>执行线程</th>
<th>执行内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>actor2</td>
<td><code>ready = true</code> ✅ 重排了</td>
</tr>
<tr>
<td>T2</td>
<td>actor1</td>
<td><code>if (ready)</code> 进入 if 分支</td>
</tr>
<tr>
<td>T3</td>
<td>actor1</td>
<td>读取 <code>num = 0</code>，返回 <code>0</code></td>
</tr>
<tr>
<td>T4</td>
<td>actor2</td>
<td><code>num = 2</code> 补上了</td>
</tr>
</tbody>
</table>
<p>此时：</p>
<ul>
<li>ready = true</li>
<li>num 还没来得及变成 2</li>
<li>所以 num + num = 0 + 0 = 0</li>
</ul>
<ol start="4">
<li>用 JCStress 工具验证这种微小并发问题</li>
</ol>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/EIyqlG3D_Snipaste_2025-11-04_18-49-45_mianshiya.png" alt="Snipaste_2025-11-04_18-49-45.png" width="100%" />
5. 如何解决？
<ul>
<li>方法一：使用 volatile</li>
</ul>
<p>修改代码为：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> ready = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li>volatile 具有 可见性 和 禁止重排序 的语义</li>
<li>它会在 ready = true 写操作前，确保之前所有写操作（包括 num = 2）都已完成</li>
<li>执行压测后，0 就不再出现了，说明问题彻底解决。</li>
</ul>
<p>总结：多线程环境下，不加 volatile 或同步机制，即使代码看起来顺序执行，也可能由于 “重排序” 导致结果诡异！</p>
<h3 id="Java-中的-final-关键字是否能保证变量的可见性？">Java 中的 final 关键字是否能保证变量的可见性？</h3>
<p>final 关键字确实<strong>能确保变量的值一旦被设置后不可再改变</strong>，但它<strong>不能保证变量在多个线程中的可见性</strong>。</p>
<ul>
<li>对于基本数据类型，它只能保证值不变；</li>
<li>对于引用类型的 final 变量，它只能保证引用指向的对象不可改变，但是对象内部的数据，其他线程仍然可能看不到最新的值。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YesFinalTest</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> a;  <span class="comment">// final 变量</span></span><br><span class="line">    <span class="type">int</span> b; <span class="comment">// 普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YesFinalTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        YesFinalTest testObj = <span class="keyword">new</span> <span class="built_in">YesFinalTest</span>();  <span class="comment">// 创建对象</span></span><br><span class="line">        testObj.b = <span class="number">3</span>; <span class="comment">// 允许修改</span></span><br><span class="line">        <span class="comment">// testObj.a = 4; // 不能修改，a 是 final 的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，a 是 final 变量，它一旦赋值就不可更改。而 b 是普通变量，它是可以修改的。<strong>如果在多线程中对这些变量进行操作，final 并不能保证在其他线程中 a 和 b 的值能及时可见</strong>，<strong>除非使用 volatile 或其他同步机制</strong>。</p>
<p>为了确保线程安全和数据可见性。通常我们需要额外使用 volatile 或 synchronized 来确保数据的一致性和可见性。</p>
<h3 id="为什么在-Java-中需要使用-ThreadLocal？">为什么在 Java 中需要使用 ThreadLocal？</h3>
<p>在 Java 中使用 ThreadLocal 主要是<strong>为了避免多线程环境下共享数据的安全问题</strong>。<br>
通常，多个线程同时访问共享资源时，如果没有适当的同步机制，就会导致线程安全问题。<strong>而 ThreadLocal 通过为每个线程提供一个独立的副本，避免了这种多线程争用共享资源的情况。</strong></p>
<p>ThreadLocal的好处如下：</p>
<ul>
<li><strong>避免竞争</strong>：ThreadLocal 是一种<strong>为每个线程提供独立副本的机制</strong>。每个线程在访问 ThreadLocal 变量时，会得到自己的副本，<strong>确保了数据隔离，避免了不同线程之间的竞争</strong>。</li>
<li><strong>高效</strong>：因为每个线程都有自己的副本，<strong>线程之间不需要进行同步</strong>（如 synchronized），<strong>从而提高了效率</strong>，特别是在高并发情况下。</li>
</ul>
<p><strong>适用场景</strong>：ThreadLocal <strong>非常适用于每个线程需要独立操作的数据</strong>。例如，<strong>数据库连接、会话信息</strong>等。使用 ThreadLocal 可以确保每个线程的数据独立，避免了共享资源带来的问题。</p>
<blockquote>
<p>ThreadLocal会造成什么问题</p>
</blockquote>
<p>ThreadLocal可能会造成内存泄漏的问题[<a target="_blank" rel="noopener" href="https://www.mianshiya.com/bank/1789249312885223425/question/1780933295085744130">https://www.mianshiya.com/bank/1789249312885223425/question/1780933295085744130</a>]</p>
<h3 id="Java-中的-ThreadLocal-是如何实现线程资源隔离的？">Java 中的 ThreadLocal 是如何实现线程资源隔离的？</h3>
<p>ThreadLocal 为每个线程提供了一个独立的 <strong>ThreadLocalMap</strong>，该 map 的<strong>键是 ThreadLocal 对象</strong>，<strong>值是存储在线程本地的具体数据</strong>。每个线程可以通过 ThreadLocal.get() 方法获取它自己的数据副本，其他线程无法直接访问到。</p>
<p>主要操作：</p>
<ul>
<li>set(value)：将线程本地的值存入 ThreadLocalMap 中，键是 ThreadLocal 对象，值是具体的值。</li>
<li>get()：根据当前线程获取到该线程对应的 ThreadLocalMap，进而访问其中存储的值。</li>
</ul>
<p>优点：</p>
<ul>
<li>线程安全：每个线程都有自己的副本，线程之间互不干扰，不会发生竞争。</li>
<li>简化线程处理：避免了显式的同步操作，减少了线程间的复杂性。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>ThreadLocal 适用于每个线程需要持有独立副本的情况，例如：数据库连接、Session信息、用户上下文等。</li>
</ul>
<h3 id="为什么-Java-中的-ThreadLocal-对-key-的引用为弱引用？">为什么 Java 中的 ThreadLocal 对 key 的引用为弱引用？</h3>
<p>在 Java 中，ThreadLocal <strong>对于存储线程局部变量的 key 使用了弱引用</strong>。弱引用的主要作用是<strong>尽可能的避免内存泄漏</strong>，<strong>并允许 JVM 在内存紧张时回收不再使用的对象</strong>。</p>
<ul>
<li>防止内存泄漏：每个线程都有一个与之关联的 ThreadLocalMap，ThreadLocal 中的 key 被弱引用，这意味着当一个线程结束或不再使用某个 ThreadLocal 对象时，ThreadLocalMap 可以被垃圾回收器回收，避免了内存泄漏。</li>
<li>有效管理内存：使用弱引用，当线程本地存储的对象不再被使用时，JVM 会自动回收内存。弱引用的 ThreadLocal 可以在系统内存不足时有效释放资源。</li>
</ul>
<blockquote>
<p>为什么value不设为弱引用？</p>
</blockquote>
<p>我们不会把 value 也设置为弱引用，主要是<strong>为了保证线程能够稳定访问到自己的局部数据。如果 value 也使用弱引用的话，可能在垃圾回收时被回收掉，这样线程就无法正常访问自己的数据了</strong>。而且，ThreadLocal 本身就用弱引用管理 key，通过清理无效的 key 来避免内存泄漏，value 用强引用确保它在生命周期内都能被正确访问</p>
<h3 id="Java-中使用-ThreadLocal-的最佳实践是什么？">Java 中使用 ThreadLocal 的最佳实践是什么？</h3>
<p>在 Java 中使用 <code>ThreadLocal</code> 时，一些最佳实践包括：</p>
<ol>
<li>
<p><strong>避免滥用 <code>ThreadLocal</code>：</strong><br>
<code>ThreadLocal</code> <strong>适用于每个线程需要维护独立变量的场景</strong>，比如数据库连接、用户会话等。<strong>如果需要共享数据，<code>ThreadLocal</code> 不适用</strong>，应该使用其他线程安全的方式。</p>
</li>
<li>
<p><strong>线程结束后清理：</strong><br>
使用 <code>ThreadLocal</code> 时，<strong>一定要在任务完成后清理数据</strong>。可以通过调用 <code>remove()</code> 方法确保释放资源，<strong>避免因资源未清理导致内存泄漏</strong>。</p>
</li>
<li>
<p><strong>使用合适的生命周期：</strong><br>
<strong>确保 <code>ThreadLocal</code> 只在当前线程中有效，线程结束时清理资源</strong>。<strong>避免 ThreadLocal 被长时间占用</strong>，最好在任务执行完后及时清理。</p>
</li>
<li>
<p><strong>合理使用 <code>initialValue()</code>：</strong><br>
使用 <code>ThreadLocal</code> 时，可以通过 <code>withInitial()</code> 方法<strong>提供初始值</strong>，这样可以<strong>确保每个线程有默认的值，避免没有初始化的情况</strong>。</p>
</li>
<li>
<p><strong>避免静态存储大型对象：</strong><br>
<code>ThreadLocal</code> <strong>不应被用来存储大型对象</strong>，如数据库连接池等。因为每个线程都可能对这些数据进行修改，使用 <code>ThreadLocal</code> 存储这类资源并不合适，容易引发竞争条件。</p>
</li>
</ol>
<p>总的来说，<code>ThreadLocal</code> 的最佳实践是：<strong>确保只在需要时使用，并且及时清理资源，避免内存泄漏或不必要的内存占用</strong>。</p>
<h3 id="Java-中的-InheritableThreadLocal-是什么？">Java 中的 InheritableThreadLocal 是什么？</h3>
<p>InheritableThreadLocal 就是 ThreadLocal 的一种变种，<strong>允许子线程访问和继承父线程中的本地变量</strong>。</p>
<p><strong>一般来说，如果你需要在父线程和子线程之间共享一些数据，且希望子线程能够访问父线程设置的值，可以使用 InheritableThreadLocal</strong>。</p>
<p>它会在创建子线程时，将父线程中 InheritableThreadLocal 的值传递给子线程。<strong>需要注意的是，子线程的修改不会影响父线程的值，而且父线程的值也不会被子线程修改</strong>。</p>
<h3 id="ThreadLocal-的缺点？">ThreadLocal 的缺点？</h3>
<ul>
<li>
<p>首先是内存泄漏的问题。ThreadLocal 对象在每个线程中有独立的副本，<strong>如果我们没有显式地使用 remove() 清除它们，这些线程局部的变量就不会被及时回收，可能会导致内存泄漏</strong>，尤其是在有大量线程的情况下。</p>
</li>
<li>
<p>其次是性能问题。如果我们使用 ThreadLocal 来<strong>存储大量数据</strong>，或者在一些<strong>线程池中使用 ThreadLocal 变量</strong>，可能会遇到<strong>性能瓶颈</strong>。这是因为每次获取或者设置值时，<strong>ThreadLocal 都需要访问其内部的数据结构，而这可能导致一些性能损耗，特别是当出现 hash 冲突时，性能会进一步下降</strong>(线性探测法效率低）。</p>
</li>
<li>
<p>最后，如果使用不当，ThreadLocal 会带来不必要的复杂性。例如，处理不同线程间的共享数据时，可能需要更多的管理工作，<strong>而 ThreadLocal 更适合一些轻量级的线程局部存储场景</strong>。”</p>
</li>
</ul>
<h3 id="什么是-Java-的-TransmittableThreadLocal？">什么是 Java 的 TransmittableThreadLocal？</h3>
<p>TransmittableThreadLocal 是为了主要用于解决 <strong>ThreadLocal 在线程池中或跨线程的传递问题</strong>，<strong>它增强了 InheritableThreadLocal 的功能。通过捕获、重放、恢复三个步骤，它确保父线程的数据能够传递到子线程，从而避免了线程池中数据丢失的问题</strong>。</p>
<p>这就是为什么在涉及到线程池或多线程环境时，我们可以使用 TransmittableThreadLocal，它能够更好地保证线程间的数据共享和传递</p>
<blockquote>
<p>ThreadLocal、InheritableThreadLocal 和 TransmittableThreadLocal 的简要比较</p>
</blockquote>
<ul>
<li>ThreadLocal <strong>用于确保每个线程有自己的变量，并且这些变量不能被其他线程访问</strong>。它适用于每个线程都需要独立存储的数据，比如数据库连接或用户信息。</li>
<li>InheritableThreadLocal <strong>让子线程能够继承父线程的 ThreadLocal 数据，这对于处理父子线程之间的数据传递是很有用的，但它不会在后续的子线程操作中进行更新</strong>。</li>
<li>TransmittableThreadLocal 则扩展了 InheritableThreadLocal，<strong>支持跨线程池传递数据，它还可以在任务执行完成后清理数据，避免内存泄漏的问题</strong>。</li>
</ul>
<h3 id="Java-中-Thread-sleep-和-Thread-yield-的区别？">Java 中 Thread.sleep 和 Thread.yield 的区别？</h3>
<p>Thread.sleep() 和 Thread.yield() 都是用来控制线程执行行为的方法，但它们的底层机制和效果不同。</p>
<p>1.从线程状态上看：</p>
<ul>
<li>sleep() 会让线程进入 TIMED_WAITING（计时等待）状态，在指定时间内不会参与 CPU 调度。</li>
<li>yield() 只是让当前线程从 RUNNABLE（可运行）状态 暂时让出 CPU 执行权，但不会阻塞，下一次调度时可能马上又被选中执行。</li>
</ul>
<p>2.从 CPU 调度上看：</p>
<ul>
<li>sleep() 一定会让出 CPU 执行时间；</li>
<li>yield() 只是“建议”调度器让出 CPU，是否让出、让给谁，由 JVM 和操作系统调度策略决定。</li>
</ul>
<ol start="3">
<li>从异常机制上看：</li>
</ol>
<ul>
<li>sleep() 会显式抛出 InterruptedException，需要捕获或声明；</li>
<li>yield() 不会抛出任何异常。</li>
</ul>
<p>4.从优先级角度看：</p>
<ul>
<li>sleep() 不考虑线程优先级，直接暂停；</li>
<li>yield() 通常只会让给相同或更高优先级的线程。</li>
</ul>
<p>5.共同点：</p>
<p><strong>两者都不会释放已持有的锁</strong>。</p>
<p>（也就是说，如果在线程同步块里调用 sleep 或 yield，锁依旧被该线程占用。）</p>
<p>总结：</p>
<ul>
<li>sleep 是“强制暂停一段时间”；</li>
<li>yield 是“自愿让出一次 CPU 机会”；</li>
<li>sleep 会进入等待状态且抛异常，yield 只是回到就绪状态，不一定真的让出执行权。</li>
</ul>
<h3 id="Java-中-Thread-sleep-0-的作用是什么？">Java 中 Thread.sleep(0) 的作用是什么？</h3>
<p>Thread.sleep(0) 表示当前线程主动让出 CPU 的执行权，但不真正进入休眠。</p>
<p>它会触发一次线程调度，让系统有机会让其他同优先级或更高优先级的线程执行。</p>
<p>如果没有可运行的线程，调度器可能会重新选中自己执行。</p>
<p>可以理解为一种轻量级的线程切换，在某些系统上和 yield() 效果类似，但更“强制”一些。</p>
<h4 id="sleep-0-的应用：">sleep(0)的应用：</h4>
<p>在高性能多线程程序中，有时会用 sleep(0) 做线程调度优化，比如防止一个线程长时间占用 CPU，但这属于底层微调，一般开发中用得较少。</p>
<h4 id="sleep-0-与-yield-的对比">sleep(0) 与 yield()的对比:</h4>
<p>sleep(0) 与 yield() 的底层实现与调度策略不同：</p>
<ul>
<li>
<p>sleep(0) 调用的是系统级 sleep/nanosleep，会强制触发一次调度；</p>
</li>
<li>
<p>yield() 只是告诉调度器“我可以让出”，但调度器可以忽略这个请求。</p>
</li>
</ul>
<h3 id="Java-中的-wait、notify-和-notifyAll-方法有什么作用？">Java 中的 wait、notify 和 notifyAll 方法有什么作用？</h3>
<p><strong>这三个方法主要用于线程间的同步和通信，确保多线程之间不会相互干扰</strong>。</p>
<ul>
<li>首先，wait() 会让<strong>当前线程进入等待状态</strong>，<strong>释放锁</strong>，让其他线程可以使用该锁。</li>
<li>调用 notify() <strong>会唤醒一个在同一对象上等待的线程</strong>，</li>
<li>而 notifyAll() <strong>会唤醒所有等待的线程</strong>。</li>
</ul>
<p>这些方法<strong>都需要在 synchronized 块中使用</strong>，因为它们都涉及到共享资源的访问和修改。</p>
<p>简而言之，wait() 会让线程进入休眠并释放锁，notify() 唤醒一个等待的线程，而 notifyAll() 唤醒所有等待的线程。</p>
<h3 id="Java-中什么情况会导致死锁？如何避免？">Java 中什么情况会导致死锁？如何避免？</h3>
<p>死锁就是两个或多个线程互相等待对方持有的锁，导致都无法继续执行。</p>
<p>它产生必须满足四个条件：互斥、占有且等待、不可抢占、循环等待。</p>
<p>只要破坏其中任意一个条件就能避免死锁。</p>
<p>实际开发中常见做法是：</p>
<ul>
<li>
<p>保证加锁顺序一致；</p>
</li>
<li>
<p>对锁操作设置超时时间，避免无限等待；</p>
</li>
<li>
<p>尽量减小锁的粒度，降低死锁的风险；</p>
</li>
<li>
<p>必要时用 jstack 分析线程快照定位死锁。</p>
</li>
</ul>
<h4 id="补充：为什么“减小锁的粒度”有助于避免死锁？">补充：为什么“减小锁的粒度”有助于避免死锁？</h4>
<p>先理解死锁的本质：</p>
<p>死锁发生的根源在于多个线程同时争抢多个锁资源，并且形成循环等待。</p>
<p>如果锁的粒度太大，意味着：</p>
<ul>
<li>
<p>一个线程拿到的锁可能包含了多个关键资源；</p>
</li>
<li>
<p>另一个线程也需要访问其中部分资源时，也要等这把“大锁”；</p>
</li>
<li>
<p>多个线程间锁的依赖关系就复杂了，更容易形成循环等待链条。</p>
</li>
</ul>
<p>相反，如果我们降低锁的粒度（即让每个锁控制的范围更小）：</p>
<ul>
<li>
<p>各线程锁住的资源重叠减少；</p>
</li>
<li>
<p>同时持有多个锁的概率变小；</p>
</li>
<li>
<p>就不太容易出现“我等你、你等我”的循环依赖。</p>
</li>
</ul>
<p>结论：锁粒度小 → 资源竞争减少 → 同时持有多把锁的可能性低 → 死锁风险降低。</p>
<h3 id="Java-中-volatile-关键字的作用是什么？">Java 中 volatile 关键字的作用是什么？</h3>
<p>volatile可以用来修饰成员变量和静态成员变量，<strong>主要作用是保证变量的可见性和禁止指令重排优化</strong>。加了 volatile 之后<strong>线程不能从自己工作缓存中读取变量的值，必须去到主内存中获取变量的最新值</strong>。</p>
<blockquote>
<p>volatile 与 synchronized 的可见性对比</p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>volatile</code></th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>可见性</td>
<td>✅ 强制主内存交互</td>
<td>✅ 解锁前刷新主内存</td>
</tr>
<tr>
<td>原子性</td>
<td>❌</td>
<td>✅ 加锁保证互斥</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>低（重量级锁）</td>
</tr>
<tr>
<td>语义</td>
<td>轻量</td>
<td>阻塞 / 解阻塞</td>
</tr>
</tbody>
</table>
<h4 id="volatile-原理">volatile 原理</h4>
<p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写屏障 sfence</td>
<td>保证之前的写操作会刷新到主内存</td>
</tr>
<tr>
<td>读屏障 lfence</td>
<td>保证之后的读操作从主内存加载最新数据</td>
</tr>
</tbody>
</table>
<h4 id="如何保证可见性">如何保证可见性</h4>
<ul>
<li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">   num = <span class="number">2</span>;</span><br><span class="line">   ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile，写操作后插入写屏障</span></span><br><span class="line">   <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 读屏障</span></span><br><span class="line">   <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">   <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">       r.r1 = num + num;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       r.r1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 volatile ready，确保 actor2 的 num=2 先于 ready=true 被主内存可见；actor1 会在读 ready 之后拿到 num=2。</p>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/iJtGDzJL_image-1430_mianshiya.png" alt="image-1430.png" width="75%" />
<h4 id="如何保证有序性（禁止指令重排序）">如何保证有序性（禁止指令重排序）</h4>
<ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">   num = <span class="number">2</span>;</span><br><span class="line">   ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">   <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 读屏障</span></span><br><span class="line">   <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">   <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">       r.r1 = num + num;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       r.r1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/pdbuUtag_3_mianshiya.png" alt="3.png" width="75%" />
<p>还是那句话，<strong>不能解决指令交错</strong>：</p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
<p><strong>即volatile无法阻止线程间指令交错执行，它只控制当前线程的读写顺序，无法强制让别的线程“看不见/先执行”</strong></p>
<blockquote>
<p>volatile无法阻止线程间指令交错执行，它只控制当前线程的读写顺序，无法强制让别的线程“看不见/先执行”与volatile禁止重排序是否矛盾？</p>
</blockquote>
<p>不矛盾</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>代表术语</th>
<th>volatile 的作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 当前线程<strong>内部</strong>顺序</td>
<td>指令重排序（reordering）</td>
<td>禁止特定重排序 ✔️</td>
</tr>
<tr>
<td>❌ 多线程<strong>之间</strong>交叉执行</td>
<td>并发交叉 / 非同步执行</td>
<td>无法阻止 ❌</td>
</tr>
</tbody>
</table>
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/sqyMghdJ_4_mianshiya.png" alt="4.png" width="50%" />
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/booE4a2G_5_mianshiya.png" alt="5.png" width="50%" />
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/ZME2jOCp_6_mianshiya.png" alt="6.png" width="50%" />
<p>volatile 禁止 自身线程内的指令重排序，<strong>保证 “我写完作业再发信号”</strong><br>
volatile 无法阻止 线程之间的交错执行，<strong>不能保证 “别人不抢先读取信号”</strong></p>
<p>两句话不矛盾，分别针对：</p>
<ul>
<li>内部顺序保障（禁止重排）</li>
<li>外部同步保障（需要锁）</li>
</ul>
<h3 id="什么是-Java-中的-ABA-问题？">什么是 Java 中的 ABA 问题？</h3>
<p>ABA 问题</p>
<ul>
<li>问题：一个变量从 A → B → A，CAS 检查时发现值没变，但实际上经历了变化，从而导致错误的判断和操作</li>
<li>解决：使用版本号机制，在每次更新一个变量时,不仅更新变量的值,还更新一个版本号。如AtomicStampedReference，在 CAS 时同时比较值和版本号。</li>
</ul>
<h3 id="在-Java-中主线程如何知晓创建的子线程是否执行成功？">在 Java 中主线程如何知晓创建的子线程是否执行成功？</h3>
<p>主线程通常有几种方式来知道子线程是否成功执行。总结来说，常见的方式包括：</p>
<h4 id="1-使用-Thread-join-方法">1. 使用 <code>Thread.join()</code> 方法</h4>
<ul>
<li><strong>原理</strong>：<strong>当主线程调用子线程的 <code>join()</code> 方法时，它会阻塞等待直到子线程执行完毕</strong>。如果子线程正常执行结束，主线程会继续执行，否则如果子线程抛出异常，主线程可以捕获到这些异常。</li>
<li><strong>应用场景</strong>：这种方式<strong>适合于简单的线程等待和执行结果的检查</strong>。</li>
</ul>
<h4 id="2-使用-Callable-和-Future">2. 使用 <code>Callable</code> 和 <code>Future</code></h4>
<ul>
<li><strong>原理</strong>：<strong>使用 <code>Callable</code> 接口创建返回结果的任务</strong>，并<strong>通过 <code>Future.get()</code> 方法来获取子线程的执行结果</strong>。如果子线程执行成功，<strong><code>get()</code> 返回正常结果</strong>；如果抛出异常，<code>get()</code> 会抛出相应的异常。</li>
<li><strong>应用场景</strong>：这种方式<strong>更适合需要返回结果的任务</strong>，或者需要捕获子线程异常的场景。</li>
</ul>
<h4 id="3-使用回调机制">3. 使用回调机制</h4>
<ul>
<li><strong>原理</strong>：回调机制是<strong>通过主线程传递一个回调函数给子线程，子线程执行完任务后调用回调函数通知主线程</strong>。主线程可以通过这些回调函数来检查任务是否成功完成。</li>
<li><strong>应用场景</strong>：适用于<strong>复杂的多线程场景</strong>，可以在任务结束时获取执行状态。</li>
</ul>
<h4 id="4-使用-CountDownLatch-或其他-JUC-类">4. 使用 <code>CountDownLatch</code> 或其他 JUC 类</h4>
<ul>
<li><strong>原理</strong>：通过 <code>CountDownLatch</code> 等同步工具类，<strong>主线程可以等待子线程完成任务。当子线程完成任务时，会调用 <code>countDown()</code> 方法来通知主线程任务已完成</strong>。<strong>主线程通过 <code>await()</code> 方法等待直到所有子线程完成</strong>。</li>
<li><strong>应用场景</strong>：适用于等待多个子线程的场景。</li>
</ul>
<p>结合具体的业务需求选择合适的方案。例如，当只关心子线程是否完成任务时，可以使用 <code>join()</code>；当需要获取任务结果或者捕获异常时，推荐使用 <code>Callable</code> 和 <code>Future</code>。</p>
<h3 id="Java-创建线程池有哪些方式？">Java 创建线程池有哪些方式？</h3>
<p><strong>Java 创建线程池的方式</strong></p>
<ol>
<li>
<p><strong>使用 <code>Executors</code> 工具类</strong></p>
<ul>
<li>
<p>Java 提供了 <code>Executors</code> 工具类来方便地创建线程池。最常见的是 <code>Executors.newFixedThreadPool(int n)</code>，它创建一个固定大小的线程池。线程池中有固定数量的线程来执行任务，一旦任务完成，线程就会被复用。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>使用 <code>ThreadPoolExecutor</code> 直接创建线程池</strong></p>
<ul>
<li>
<p>如果需要更灵活的配置，可以使用 <code>ThreadPoolExecutor</code> 类直接创建线程池。它可以让你自定义线程池的参数，如核心线程数、最大线程数、线程空闲保持时间等。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>,                  <span class="comment">// corePoolSize</span></span><br><span class="line">    <span class="number">10</span>,                 <span class="comment">// maximumPoolSize</span></span><br><span class="line">    <span class="number">60</span>,                 <span class="comment">// keepAliveTime</span></span><br><span class="line">    TimeUnit.SECONDS,   <span class="comment">// TimeUnit</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>)  <span class="comment">// BlockingQueue</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>使用 <code>ForkJoinPool</code> 创建线程池</strong></p>
<ul>
<li>
<p><code>ForkJoinPool</code> 用于并行任务的执行，它在任务拆分和合并方面非常高效。它特别适合需要递归任务或任务能拆分的场景。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">forkJoinPool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Task</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>具体选择哪个方式取决于你的应用场景。</p>
<ul>
<li>如果需要简单的线程池，可以用 <code>Executors</code> 工具类；</li>
<li>如果需要更高的定制性，选择 <code>ThreadPoolExecutor</code>；</li>
<li>对于递归任务，<code>ForkJoinPool</code> 是一个很好的选择。</li>
</ul>
<h3 id="Java-线程安全的集合有哪些">Java 线程安全的集合有哪些?</h3>
<p><strong>Java 线程安全的集合</strong><br>
常见的线程安全集合包括：</p>
<ol>
<li>
<p><strong>Vector</strong></p>
<ul>
<li>类型：线程安全的动态数组</li>
<li>特点：每个方法都有锁，适用于多线程修改的场景。但由于性能较差，已经不推荐使用。</li>
</ul>
</li>
<li>
<p><strong>Hashtable</strong></p>
<ul>
<li>类型：线程安全的哈希表</li>
<li>特点：每个方法都有锁，适用于多线程共享的哈希表，但性能较低，已被 <code>ConcurrentHashMap</code> 替代。</li>
</ul>
</li>
<li>
<p><strong>ConcurrentHashMap</strong></p>
<ul>
<li>类型：线程安全的哈希表</li>
<li>特点：分段锁设计，支持高并发，适用于高并发环境，如缓存、分布式系统等。</li>
</ul>
</li>
<li>
<p><strong>CopyOnWriteArrayList</strong></p>
<ul>
<li>类型：线程安全的动态数组</li>
<li>特点：用于读多写少的场景，每次写操作时会复制整个数组，避免锁，适合监听集合等场景。</li>
</ul>
</li>
<li>
<p><strong>CopyOnWriteArraySet</strong></p>
<ul>
<li>类型：线程安全的集合</li>
<li>特点：基于 <code>CopyOnWriteArrayList</code> 实现，适合读多写少的场景。</li>
</ul>
</li>
<li>
<p><strong>BlockingQueue</strong></p>
<ul>
<li>类型：线程安全的队列</li>
<li>特点：用于生产者-消费者模式，支持阻塞操作，适用于多线程的队列操作。</li>
</ul>
</li>
<li>
<p><strong>ConcurrentSkipListMap 和 ConcurrentSkipListSet</strong></p>
<ul>
<li>类型：线程安全的 Map 和 Set</li>
<li>特点：基于跳表实现，支持高并发操作，适合需要顺序访问的集合操作。</li>
</ul>
</li>
<li>
<p><strong>LinkedBlockingQueue</strong></p>
<ul>
<li>类型：线程安全的阻塞队列</li>
<li>特点：支持高并发的队列操作，适用于任务队列等场景。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>JUC面试题</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://itgeqian.github.io/posts/68.html">https://itgeqian.github.io/posts/68.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>geqian's Blog🍭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-10-01</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-10-05</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>JUC</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1PAY.jpg" target="_blank"><img class="post-qr-code-img" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1PAY.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E6%94%AF%E4%BB%98%E5%AE%9DPAY.jpg" target="_blank"><img class="post-qr-code-img" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E6%94%AF%E4%BB%98%E5%AE%9DPAY.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/61.html"><img class="prev-cover" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/6.jpg" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker Desktop安装到D盘</div></div></a></div><div class="next-post pull-right"><a href="/posts/60.html"><img class="next-cover" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/%E5%8F%A4%E9%A3%8E.jpg" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">速通Spring AI Alibaba </div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/28.html" title="JUC并发编程中篇"><img class="cover" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/47.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-08-01</div><div class="title">JUC并发编程中篇</div></div></a></div><div><a href="/posts/27.html" title="JUC并发编程上篇"><img class="cover" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/46.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-07-28</div><div class="title">JUC并发编程上篇</div></div></a></div><div><a href="/posts/29.html" title="JUC并发编程下篇"><img class="cover" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/48.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-08-03</div><div class="title">JUC并发编程下篇</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GQ-JUC"><span class="toc-text">GQ JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC"><span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">进程、线程、协程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB-%E7%8B%AC%E7%AB%8B%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-text">进程是什么？（资源隔离+独立内存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83-%E6%9B%B4%E8%BD%BB%E9%87%8F%EF%BC%89"><span class="toc-text">线程是什么？（执行单元+更轻量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E6%9E%81%E8%BD%BB%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%89"><span class="toc-text">协程是什么？（用户态、极轻、高并发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%88%90%E6%9C%AC%E5%AF%B9%E6%AF%94"><span class="toc-text">执行成本对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">什么是 Java 中的线程同步？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-text">并行与并发,同步与异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">Java 中的线程安全是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9FJava-%E6%94%AF%E6%8C%81%E5%8D%8F%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">什么是协程？Java 支持协程吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9C%A8-Java-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%9F"><span class="toc-text">线程的生命周期在 Java 中是如何定义的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-Java-API-%E5%B1%82%E9%9D%A2%E6%9D%A5%E6%8F%8F%E8%BF%B0%E7%9A%84%E6%9C%89%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">从 Java API 层面来描述的有六种状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B1%82%E9%9D%A2%E6%9D%A5%E6%8F%8F%E8%BF%B0%E6%9C%89%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">从 操作系统 层面来描述有五种状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-text">Java 中线程之间如何进行通信？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">Java 中如何创建多线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">你了解 Java 线程池的原理吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%9C%B0%E8%AE%BE%E7%BD%AE-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F"><span class="toc-text">如何合理地设置 Java 线程池的线程数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">Java 线程池有哪些拒绝策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%B9%B6%E5%8F%91%E5%BA%93%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 并发库中提供了哪些线程池实现？它们有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%9C%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%83%BD%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-text">Java 线程池核心线程数在运行过程中能修改吗？如何修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD-shutdown-%E4%B8%8E-shutdownNow-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 线程池中 shutdown 与 shutdownNow 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E9%83%A8%E4%BB%BB%E5%8A%A1%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%87%BA%E4%BA%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-DelayQueue-%E5%92%8C-ScheduledThreadPool-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中的 DelayQueue 和 ScheduledThreadPool 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-Timer%EF%BC%9F"><span class="toc-text">什么是 Java 的 Timer？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E6%97%B6%E9%97%B4%E8%BD%AE%EF%BC%88Time-Wheel%EF%BC%89%E5%90%97%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">你了解时间轮（Time Wheel）吗？有哪些应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B-Java-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9F"><span class="toc-text">你使用过哪些 Java 并发工具类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-Semaphore%EF%BC%9F"><span class="toc-text">什么是 Java 的 Semaphore？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-CyclicBarrier%EF%BC%9F"><span class="toc-text">什么是 Java 的 CyclicBarrier？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-CountDownLatch%EF%BC%9F"><span class="toc-text">什么是 Java 的 CountDownLatch？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-StampedLock%EF%BC%9F"><span class="toc-text">什么是 Java 的 StampedLock？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-CompletableFuture%EF%BC%9F"><span class="toc-text">什么是 Java 的 CompletableFuture？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-ForkJoinPool%EF%BC%9F"><span class="toc-text">什么是 Java 的 ForkJoinPool？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-Java-%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">如何在 Java 中控制多个线程的执行顺序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87-Java-%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">你使用过 Java 中的哪些阻塞队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87-Java-%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9F"><span class="toc-text">你使用过 Java 中的哪些原子类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87-Java-%E7%9A%84%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%90%97%EF%BC%9F"><span class="toc-text">你使用过 Java 的累加器吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-CAS%EF%BC%88Compare-And-Swap%EF%BC%89%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">什么是 Java 的 CAS（Compare-And-Swap）操作？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">CAS 的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS-%E7%9A%84%E7%BC%BA%E7%82%B9%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">CAS 的缺点与解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D"><span class="toc-text">总结一句话</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-AQS-%E5%90%A7%EF%BC%9F"><span class="toc-text">说说 AQS 吧？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-ReentrantLock-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中 ReentrantLock 的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%9A%84-synchronized-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 的 synchronized 是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Synchronized 修饰静态方法和修饰普通方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-synchronized-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%98%AF%E5%90%A6%E4%BC%9A%E8%BF%9B%E8%A1%8C%E8%87%AA%E6%97%8B%EF%BC%9F"><span class="toc-text">Java 中的 synchronized 轻量级锁是否会进行自旋？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E8%83%BD%E4%B8%8D%E8%83%BD%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-text">Synchronized 能不能禁止指令重排序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93-Java-%E7%9A%84-synchronized-%E5%8D%87%E7%BA%A7%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%90%8E%EF%BC%8C%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E9%83%BD%E9%87%8A%E6%94%BE%E9%94%81%E4%BA%86%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%AE%83%E8%BF%98%E6%98%AF%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">当 Java 的 synchronized 升级到重量级锁后，所有线程都释放锁了，此时它还是重量级锁吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E9%94%81%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%EF%BC%9F"><span class="toc-text">什么是 Java 中的锁自适应自旋？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Synchronized 和 ReentrantLock 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile-%E4%B8%8E-Synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Volatile 与 Synchronized 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-Java-%E4%B8%AD%E7%9A%84%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">如何优化 Java 中的锁的使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3-Java-%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">你了解 Java 中的读写锁吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="toc-text">什么是 Java 内存模型（JMM）?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-text">什么是 Java 中的原子性、可见性和有序性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-happens-before-%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-text">什么是 Java 的 happens-before 规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="toc-text">什么是 Java 中的指令重排？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">指令重排的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-%E6%BC%94%E7%A4%BA%E4%B8%80%E4%B8%8B%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-text">扩展- 演示一下指令重排</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-final-%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E5%90%A6%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-text">Java 中的 final 关键字是否能保证变量的可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-Java-%E4%B8%AD%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-ThreadLocal%EF%BC%9F"><span class="toc-text">为什么在 Java 中需要使用 ThreadLocal？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-ThreadLocal-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 中的 ThreadLocal 是如何实现线程资源隔离的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD%E7%9A%84-ThreadLocal-%E5%AF%B9-key-%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%BA%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">为什么 Java 中的 ThreadLocal 对 key 的引用为弱引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E4%BD%BF%E7%94%A8-ThreadLocal-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中使用 ThreadLocal 的最佳实践是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-InheritableThreadLocal-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的 InheritableThreadLocal 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">ThreadLocal 的缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-TransmittableThreadLocal%EF%BC%9F"><span class="toc-text">什么是 Java 的 TransmittableThreadLocal？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-Thread-sleep-%E5%92%8C-Thread-yield-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中 Thread.sleep 和 Thread.yield 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-Thread-sleep-0-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中 Thread.sleep(0) 的作用是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-0-%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="toc-text">sleep(0)的应用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-0-%E4%B8%8E-yield-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">sleep(0) 与 yield()的对比:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-wait%E3%80%81notify-%E5%92%8C-notifyAll-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Java 中的 wait、notify 和 notifyAll 方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">Java 中什么情况会导致死锁？如何避免？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E2%80%9C%E5%87%8F%E5%B0%8F%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E2%80%9D%E6%9C%89%E5%8A%A9%E4%BA%8E%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">补充：为什么“减小锁的粒度”有助于避免死锁？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中 volatile 关键字的作用是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%8E%9F%E7%90%86"><span class="toc-text">volatile 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">如何保证可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%88%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-text">如何保证有序性（禁止指令重排序）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84-ABA-%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">什么是 Java 中的 ABA 问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Java-%E4%B8%AD%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E7%9F%A5%E6%99%93%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F%EF%BC%9F"><span class="toc-text">在 Java 中主线程如何知晓创建的子线程是否执行成功？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-Thread-join-%E6%96%B9%E6%B3%95"><span class="toc-text">1. 使用 Thread.join() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-Callable-%E5%92%8C-Future"><span class="toc-text">2. 使用 Callable 和 Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6"><span class="toc-text">3. 使用回调机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-CountDownLatch-%E6%88%96%E5%85%B6%E4%BB%96-JUC-%E7%B1%BB"><span class="toc-text">4. 使用 CountDownLatch 或其他 JUC 类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">Java 创建线程池有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Java 线程安全的集合有哪些?</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By geqian's Blog🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20230913" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20230913号"><img src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/20230913.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 geqianの学习笔记 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/杂项/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 geqianの杂项 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 geqianの项目笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/AI/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 geqianのAI大模型 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 geqianの算法学习笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 geqianの面试 (18)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/JUC/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🌏 geqianのJUC (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/JVM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍜 geqianのJVM (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/云原生/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🔐 geqianの云原生相关 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/MQ/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📱 geqianの消息队列 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🏛️ geqianの前端工程 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/mybatis-mybatis-plus/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎨 geqianのmybatis系列 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/微服务/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🗺️ geqianのSpringCloud系列 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/SSM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📖 geqianのSSM+SpringBoot系列 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/ruoyi/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📞 geqianの若依框架 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/mysql/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">❓ geqianのmysql (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/Redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💖 geqianのRedis (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://itgeqian.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/%E5%8F%A4%E9%A3%8E.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt="">速通Spring AI Alibaba </a><div class="blog-slider__text">速通Spring AI Alibaba 完结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/27.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt="">GQ Video单服务版本记录</a><div class="blog-slider__text">GQ Video单服务版本记录（完整记录GQ Video从0到1的全记录）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/35.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt="">Mysql相关面试题</a><div class="blog-slider__text">我对mysql的相关理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/31.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt="">javase+集合相关面试题</a><div class="blog-slider__text">我对java基础和集合类的相关理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/22.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt="">JUC面试题</a><div class="blog-slider__text">我对JUC的理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>