<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JVM面试题 | geqian's Blog🍭</title><meta name="keywords" content="JVM"><meta name="author" content="geqian's Blog🍭"><meta name="copyright" content="geqian's Blog🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="我对JVM的相关理解">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM面试题">
<meta property="og:url" content="https://itgeqian.github.io/posts/71.html">
<meta property="og:site_name" content="geqian&#39;s Blog🍭">
<meta property="og:description" content="我对JVM的相关理解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp">
<meta property="article:published_time" content="2025-10-07T00:19:03.000Z">
<meta property="article:modified_time" content="2025-10-20T03:42:00.000Z">
<meta property="article:author" content="geqian&#39;s Blog🍭">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://itgeqian.github.io/posts/71"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-20 11:42:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><script src="https://cdn.jsdelivr.net/npm/echarts@6/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="geqian's Blog🍭" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.png" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">geqian's Blog🍭</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">JVM面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2025-10-07T00:19:03.000Z" title="发表于 2025-10-07 08:19:03">2025-10-07</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-20T03:42:00.000Z" title="更新于 2025-10-20 11:42:00">2025-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2.7w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>84分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM面试题"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="GQ-JVM"><a href="#GQ-JVM" class="headerlink" title="GQ JVM"></a>GQ JVM</h1><h2 id="Java-中有哪些垃圾回收算法？"><a href="#Java-中有哪些垃圾回收算法？" class="headerlink" title="Java 中有哪些垃圾回收算法？"></a>Java 中有哪些垃圾回收算法？</h2><p>我简单介绍一下常见的几种垃圾回收算法，其实大多数 GC 算法都是基于两个 “祖宗级” 的思想演变而来的：一个是 “标记 - 清除” 算法，一个是 “复制” 算法。</p>
<h3 id="1-标记-清除（Mark-Sweep）："><a href="#1-标记-清除（Mark-Sweep）：" class="headerlink" title="1. 标记 - 清除（Mark-Sweep）："></a>1. <strong>标记 - 清除</strong>（Mark-Sweep）：</h3><p>先是标记阶段，将所有存活的对象进行标记。 再是清除阶段，从内存中删除没有被标记也就是非存活对象，这种方式实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/KZ8DUT8F_1_mianshiya.png" alt="1.png" width="75%" /></p>
<p>但<strong>问题是容易产生内存碎片</strong>，比如清掉很多小块内存后，剩下的零碎空间可能凑不出一个新对象需要的空间。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/H1HzHoc6_2_mianshiya.png" alt="2.png" width="75%" /></p>
<h3 id="2-复制（Copying）算法："><a href="#2-复制（Copying）算法：" class="headerlink" title="2. 复制（Copying）算法："></a>2. <strong>复制</strong>（Copying）算法：</h3><p>它的想法是：准备两块内存区域（From 空间和 To 空间），<strong>每次只用一块（From 空间）</strong>，在GC阶段把存活的对象从当前区域复制到另一块区域（From-&gt;To），然后整体清空原来的区域。这样做虽然避免了内存碎片的问题，但缺点是只能用一半的空间，浪费比较大。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/1Bk7BeDf_3_mianshiya.png" alt="3.png" width="100%" /></p>
<h3 id="3-标记-整理（Mark-Compact）算法："><a href="#3-标记-整理（Mark-Compact）算法：" class="headerlink" title="3. 标记 - 整理（Mark-Compact）算法："></a>3. 标记 - 整理（Mark-Compact）算法：</h3><p>也是先是标记阶段，将所有存活的对象进行标记。再是整理阶段，会把所有存活对象往内存的一边移动，然后清理掉后面的一大片空闲内存。这样既解决了碎片问题，又保留了内存的连续性。不过移动对象的成本较高，效率会稍低。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/23JLXr9n_4_mianshiya.png" alt="4.png" width="100%" /></p>
<h3 id="4-分代垃圾回收（Generational-GC）："><a href="#4-分代垃圾回收（Generational-GC）：" class="headerlink" title="4. 分代垃圾回收（Generational GC）："></a>4. 分代垃圾回收（Generational GC）：</h3><p>现代 JVM 一般都采用分代的方式，<strong>把堆内存分成 “年轻代” 和 “老年代”</strong>，不同代使用不同算法。</p>
<ul>
<li><strong>年轻代通常用 “复制” 算法，因为这里对象生命周期短、回收频繁</strong>；</li>
<li><strong>老年代则常用 “标记 - 清除” 或 “标记 - 整理”，因为对象通常存活时间较长，不适合频繁复制。</strong></li>
</ul>
<p>这个分代回收机制有个好处：<strong>程序中大部分对象都是朝生夕死，大部分新创建的对象很快就不再用，所以可以快速在年轻代清理掉，减少对整个堆的 Full GC 影响</strong>，从而<strong>提升应用的吞吐量</strong>和<strong>响应性能</strong>。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/waqcqgJI_5_mianshiya.png" alt="5.png" width="100%" /></p>
<p>总结：</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/OHSnDm05_6_mianshiya.png" alt="6.png" width="100%" /></p>
<h2 id="JVM-的-TLAB（Thread-Local-Allocation-Buffer）是什么？"><a href="#JVM-的-TLAB（Thread-Local-Allocation-Buffer）是什么？" class="headerlink" title="JVM 的 TLAB（Thread-Local Allocation Buffer）是什么？"></a>JVM 的 TLAB（Thread-Local Allocation Buffer）是什么？</h2><p><strong>TLAB 是 JVM 为每个线程在堆中新生代 Eden 区分配的一小块私有内存，用来快速分配对象</strong>。</p>
<ul>
<li>每个线程优先在自己的 TLAB 中分配对象，避免了多线程竞争共享堆的同步开销。</li>
<li>如果 TLAB 用完，就会重新申请新的；</li>
<li>大对象会直接在 Eden 区分配。</li>
</ul>
<p>简单来说，TLAB 就是让对象分配更快、更安全的一种线程本地优化机制。</p>
<h2 id="Java-是如何实现跨平台的？"><a href="#Java-是如何实现跨平台的？" class="headerlink" title="Java 是如何实现跨平台的？"></a>Java 是如何实现跨平台的？</h2><p>Java 实现跨平台的关键在于它的“<strong>编译一次，到处运行</strong>”的理念。简单来说，Java 源代码首先被编译成字节码文件（.class 文件），然后这些字节码文件通过 Java 虚拟机（JVM）在不同平台上进行解释和执行。JVM 是与平台相关的，每个操作系统或硬件平台都有一个特定的 JVM 实现。这样，无论在哪个平台上，只要有适配的 JVM，Java 程序就能运行。</p>
<p>总结</p>
<ol>
<li><p><strong>Java 编译成字节码（.class 文件），然后通过 JVM 在不同平台上执行。</strong></p>
</li>
<li><p><strong>每个操作系统或硬件平台都需要有特定的 JVM 实现。</strong></p>
</li>
<li><strong>JVM 让 Java 程序能够在任何平台上运行，而不需要重新编译。</strong></li>
</ol>
<h2 id="JVM-由哪些部分组成？"><a href="#JVM-由哪些部分组成？" class="headerlink" title="JVM 由哪些部分组成？"></a>JVM 由哪些部分组成？</h2><p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/0ThbrNql_10_mianshiya.png" alt="10.png" width="100%" /></p>
<ul>
<li>类加载子系统，负责加载、验证、解析、初始化class字节码文件。其核心就是类加载器。</li>
<li>运行时数据区，管理 JVM 使用到的内存。<ul>
<li>线程共享区<ul>
<li>堆：存放所有对象</li>
<li>方法区：存放类的元信息、常量池、静态变量</li>
</ul>
</li>
<li>线程私有区<ul>
<li>虚拟机栈：每个方法对应一个栈帧</li>
<li>本地方法栈：本地方法的栈</li>
<li>程序计数器：记录当前线程正在执行的字节码指令地址，确保线程切换后恢复到正确的这些位置  </li>
</ul>
</li>
</ul>
</li>
<li>执行引擎，分为<ul>
<li>解释器 解释执行字节码指令；</li>
<li>即时编译器 优化代码执行性能； </li>
<li>垃圾回收器 将不再使用的对象进行回收。</li>
</ul>
</li>
<li>本地接口，保存了本地已经编译好的方法，使用 C/C++ 语言实现。</li>
</ul>
<p>然后我们再理解型的记忆上述几个组成部分：</p>
<ol>
<li>首先需要准备编译好的 Java 字节码文件（即class文件）。</li>
<li>然后需要先通过一定方式（类加载器）将 class 文件加载到内存中（运行时数据区）。</li>
<li>又因为字节码文件是 JVM 定义的一套指令集规范，底层操作系统无法直接执行。</li>
<li>因此需要特定的命令解释器（执行引擎）将字节码翻译成特定的操作系统指令集交给 CPU 去执行。</li>
<li>这个过程中会需要调用到一些不同语言为 Java 提供的接口（例如驱动、地图制作等），这就用到了本地方法接口（Native Interface）。</li>
</ol>
<h2 id="编译执行与解释执行的区别是什么？JVM-使用哪种方式？"><a href="#编译执行与解释执行的区别是什么？JVM-使用哪种方式？" class="headerlink" title="编译执行与解释执行的区别是什么？JVM 使用哪种方式？"></a>编译执行与解释执行的区别是什么？JVM 使用哪种方式？</h2><p>编译执行：<br>定义：编译执行是将程序的<strong>源代码</strong>（如 Java 程序中的 .java 文件）<strong>在运行前由编译器转化为机器语言</strong>（通常是 .class 文件）。然后该机器代码直接在 CPU 上运行。</p>
<p>解释执行：<br>定义：<strong>解释执行是程序在运行时逐行由解释器将源代码转换为机器语言并执行</strong>。常见的解释型语言有 Python 和 Ruby。</p>
<h3 id="JVM-的方式："><a href="#JVM-的方式：" class="headerlink" title="JVM 的方式："></a>JVM 的方式：</h3><p>JVM 使用的是<strong>混合模式</strong>，结合了编译执行和解释执行的优点。<strong>Java 在运行时使用 解释执行 将字节码转化为机器码，并且采用 JIT（即时编译器） 技术，在程序运行过程中，JVM 会将经常使用的代码片段编译成机器码，从而提高性能</strong>。这种方式在启动时使用解释执行，而在运行过程中逐渐将热点代码编译为机器码，提高执行效率。</p>
<p>总结</p>
<ul>
<li>编译执行 提供了更高的执行效率，但缺乏跨平台性。</li>
<li>解释执行 更具跨平台能力，但执行效率较低。</li>
<li><strong>JVM 结合了两者的优势，初期使用解释执行，之后通过 JIT 编译器将热点代码编译为机器码，提升效率</strong>。</li>
</ul>
<h2 id="JVM-的内存区域是如何划分的？"><a href="#JVM-的内存区域是如何划分的？" class="headerlink" title="JVM 的内存区域是如何划分的？"></a>JVM 的内存区域是如何划分的？</h2><p>Java 虚拟机运行时数据区分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/UEvvDb2b_11_mianshiya.png" alt="11.png" width="100%" /></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Register）也叫 PC 寄存器，<strong>每个线程会通过程序计数器记录当前线程要执行的的字节码指令的地址</strong>。<br>主要有两个作用：</p>
<ul>
<li><strong>程序计数器可以控制程序指令的进行</strong>，实现分支、跳转、异常等逻辑。</li>
</ul>
<p align="center"><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/okv9yxL4_12_mianshiya.png" alt="12.png" width="70%" /></p>

<ul>
<li><strong>多线程执行情况下，Java 虚拟机需要通过程序计数器记录 CPU 切换前解释执行到那一句指令并继续解释运行。</strong></li>
</ul>
<p align="center"><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/e0b8bCi9_13_mianshiya.png" alt="13.png" width="70%" /></p>

<p><strong>简单理解就是：它就像一个小导航器，记录着当前线程正在执行哪一条字节码指令。每个线程都有自己的程序计算器，线程切换时它能帮我们恢复现场。</strong></p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><strong>Java 虚拟机栈采用栈的数据结构来管理方法调用中的基本数据</strong>，先进后出，每一个方法的调用使用一个栈帧来保存。每个线程都会包含一个自己的虚拟机栈，它的生命周期和线程相同。</p>
<p align="center"><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/TZDXPOvR_14_mianshiya.png" alt="14.png" width="70%" /></p>
栈帧主要包含三部分内容：

1、局部变量表，在方法执行过程中存放所有的局部变量。

<p align="center"><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/kkM7KzJL_15_mianshiya.png" alt="15.png" width="70%" /></p>
2、操作数栈，虚拟机在执行指令过程中用来存放临时数据的一块区域。

如下图中，iadd 指令会将操作数栈上的两个数相加，为了实现 i+1。最终结果也会放到操作数上。

<p align="center"><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/wfmE3Xfa_16_mianshiya.png" alt="16.png" width="70%" /></p>
3、帧数据，主要包含动态链接、方法出口、异常表等内容。

- 动态链接：方法中要用到其他类的属性和方法，这些内容在字节码文件中是以编号保存的，运行过程中需要替换成内存中的地址，这个编号到内存地址的映射关系就保存在动态链接中。
- 方法出口：方法调用完需要弹出栈帧，回到上一个方法，程序计数器要切换到上一个方法的地址继续执行，方法出口保存的就是这个地址。
- 异常表：存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。

### 本地方法栈
Java 虚拟机栈存储了 Java 方法调用时的栈帧，**而本地方法栈存储的是 native 本地方法的栈帧。**

在 Hotspot 虚拟机中，Java 虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。
<p align="center">
<img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/uvn65XV0_17_mianshiya.png" alt="17.png" width="120px" /></p>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>一般 Java 程序中堆内存是空间最大的一块内存区域。<strong>创建出来的对象都存在于堆上</strong>。</li>
<li>栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</li>
<li>堆是垃圾回收最主要的部分，堆结构更详细的划分与垃圾回收器有关。</li>
</ul>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/1yF4Rxo8_18_mianshiya.png" alt="18.png" width="100%" /></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是 Java 虚拟机规范中提出来的一个虚拟机概念，<strong>在 HotSpot 不同版本中会用永久代或者元空间来实现</strong>。方法区主要存放的是基础信息，包含：</p>
<p>1、每一个加载的类的元信息（基础信息）。<br>2、运行时常量池，保存了字节码文件中的常量池内容，避免常量内容重复创建减少内存开销。<br>3、字符串常量池，存储字符串的常量。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/XEw09ADC_20_mianshiya.png" alt="20.png" width="100%" /></p>
<h3 id="面试简要回答"><a href="#面试简要回答" class="headerlink" title="面试简要回答"></a>面试简要回答</h3><p>如果面试官问我：“你能说一下 JVM 的运行时数据区吗？”</p>
<p>答：当然可以。JVM 的运行时数据区，其实就是 JVM 在运行 Java 程序时会分配的一些内存区域，这些区域各自有不同的用途。整体上可以分成线程共享的和线程私有的两类。</p>
<p>线程共享的有两个：</p>
<ul>
<li><strong>堆（Heap）：</strong> 这是用来存储所有对象实例的地方，也是垃圾回收器的主要工作区域。对象被 new 出来之后都会放在这里。</li>
<li><strong>方法区（Method Area）：</strong> 这块区域里保存的是类的信息，比如类名、字段、方法、常量池这些。你可以理解成它更偏向“类”的元数据。</li>
</ul>
<p>线程私有的有三个：</p>
<ul>
<li><strong>程序计数器（PC Register）：</strong> 这就像一个小导航器，记录着当前线程正在执行哪一条字节码指令。每个线程都有自己的，线程切换时它能帮我们恢复现场。</li>
<li><strong>虚拟机栈（JVM Stack）：</strong> 每个线程也有自己的栈，它是方法调用的基础结构。每个方法执行时都会生成一个叫“栈帧”的东西，用来保存方法的局部变量、操作数、返回地址等。</li>
<li><strong>本地方法栈（Native Method Stack）：</strong> 它是专门用来支持 native 本地方法的，和 JVM 栈类似，只不过作用在本地方法上。</li>
</ul>
<p>另外还有一个特殊的区域叫 <strong>直接内存（Direct Memory）</strong>，它不是 JVM 管的，而是由操作系统直接管理的，常用于高性能 I/O，比如 NIO 中的 DirectByteBuffer。</p>
<p>所以总结下来就是：JVM 把内存分区做得很清楚，不同的区域负责不同的功能，有的线程共享，有的线程独占，目的就是为了更高效地管理对象和执行代码。</p>
<h2 id="JVM-方法区是否会出现内存溢出"><a href="#JVM-方法区是否会出现内存溢出" class="headerlink" title="JVM 方法区是否会出现内存溢出?"></a>JVM 方法区是否会出现内存溢出?</h2><h3 id="运行时数据区的哪些区域会出现内存溢出？"><a href="#运行时数据区的哪些区域会出现内存溢出？" class="headerlink" title="运行时数据区的哪些区域会出现内存溢出？"></a>运行时数据区的哪些区域会出现内存溢出？</h3><p>内存溢出指的是<strong>内存中某一块区域的使用量超过了允许使用的最大值</strong>，从而使用内存时因空间不足而失败，虚拟机一般会抛出指定的错误。<br><strong>在 Java 虚拟机中，只有程序计数器不会出现内存溢出的情况，因为每个线程的程序计数器只保存一个固定长度的地址</strong>。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/BHPkPgIT_21_mianshiya.png" alt="21.png" width="100%" /></p>
<h3 id="堆内存溢出："><a href="#堆内存溢出：" class="headerlink" title="堆内存溢出："></a>堆内存溢出：</h3><p><strong>堆内存溢出指的是在堆上分配的对象空间超过了堆的最大大小</strong>，从而导致的内存溢出。堆的最大大小使用 - Xmx 参数进行设置，如 - Xmx10m 代表最大堆内存大小为 10m。<br>溢出之后会抛出 OutOfMemoryError，并提示是 Java heap Space 导致的：</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/E3qwO46C_2_mianshiya.png" alt="2.png" width="100%" /></p>
<h3 id="栈内存溢出："><a href="#栈内存溢出：" class="headerlink" title="栈内存溢出："></a>栈内存溢出：</h3><p><strong>栈内存溢出指的是所有栈帧空间的占用内存超过了最大值</strong>，最大值使用 - Xss 进行设置，比如 - Xss256k 代表所有栈帧占用内存大小加起来不能超过 256k。<br>溢出之后会抛出 StackOverflowError：</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/eAo3nyqE_3_mianshiya.png" alt="3.png" width="100%" /></p>
<h3 id="方法区内存溢出："><a href="#方法区内存溢出：" class="headerlink" title="方法区内存溢出："></a>方法区内存溢出：</h3><p><strong>方法区内存溢出指的是方法区中存放的内容比如类的元信息超过了方法区内存的最大值</strong>，JDK7 及之前版本方法区使用永久代（-XX:MaxPermSize = 值）来实现，JDK8 及之后使用元空间（-XX:MaxMetaspaceSize = 值）来实现。</p>
<p>元空间溢出：</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/xX8PAzL4_4_mianshiya.png" alt="4.png" width="100%" /><br>永久代溢出：</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/bY5cploi_5_mianshiya.png" alt="5.png" width="100%" /></p>
<h3 id="直接内存溢出："><a href="#直接内存溢出：" class="headerlink" title="直接内存溢出："></a>直接内存溢出：</h3><p>直接内存溢出指的是申请的直接内存空间大小超过了最大值，使用 -XX:MaxDirectMemorySize = 值 设置最大值。</p>
<p>溢出之后会抛出 OutOfMemoryError：</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/LuT08D8b_6_mianshiya.png" alt="6.png" width="100%" /></p>
<h3 id="面试时简答："><a href="#面试时简答：" class="headerlink" title="面试时简答："></a>面试时简答：</h3><p>回答：</p>
<p>在 JVM 中，内存溢出通常指的是某一块区域的内存超过了它的最大限制，导致无法分配内存，抛出相应的异常。常见的内存区域和对应的异常现象如下：</p>
<ol>
<li>堆内存溢出（OutOfMemoryError: Java heap space）</li>
</ol>
<ul>
<li><strong>原因</strong>：堆内存用于存储对象，如果应用创建了大量对象，超过了最大堆内存限制，就会导致堆内存溢出。</li>
<li><strong>现象</strong>：抛出 OutOfMemoryError: Java heap space 异常。</li>
</ul>
<ol>
<li>栈内存溢出（StackOverflowError）</li>
</ol>
<ul>
<li><strong>原因</strong>：每个线程都有自己的栈内存，如果递归调用过深，栈空间会被耗尽，导致栈内存溢出。</li>
<li><strong>现象</strong>：抛出 StackOverflowError 异常。</li>
</ul>
<ol>
<li>方法区内存溢出</li>
</ol>
<ul>
<li><strong>原因</strong>：JDK7及之前的版本使用永久代（PermGen）存储类的元数据，JDK8及之后使用元空间（Metaspace）。如果加载的类太多，或者类的元信息过多，可能会导致方法区溢出。</li>
<li><strong>现象</strong>：抛出 OutOfMemoryError，JDK7及之前提示 PermGen space，JDK8及之后提示 Metaspace。</li>
</ul>
<ol>
<li>直接内存溢出（OutOfMemoryError: Direct buffer memory）</li>
</ol>
<ul>
<li><strong>原因</strong>：Java 使用 NIO 进行 I/O 操作时，分配直接内存（通过 ByteBuffer.allocateDirect()），如果直接内存超过了最大限制，会发生溢出。</li>
<li><strong>现象</strong>：抛出 OutOfMemoryError: Direct buffer memory 异常。</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>堆内存</strong>：溢出后抛出 OutOfMemoryError: Java heap space。</li>
<li><strong>栈内存</strong>：溢出后抛出 StackOverflowError。</li>
<li><strong>方法区</strong>：溢出后抛出 OutOfMemoryError，JDK7之前是 PermGen space，JDK8之后是 Metaspace。</li>
<li><strong>直接内存</strong>：溢出后抛出 OutOfMemoryError: Direct buffer memory。</li>
</ul>
<p>本题问的是JVM 方法区是否会出现内存溢出? 我们只需要回答方法区内存溢出的内容：</p>
<p>方法区会出现内存溢出，JDK7及之前的版本使用永久代（PermGen）存储类的元数据，JDK8及之后使用元空间（Metaspace）。如果加载的类太多，或者类的元信息过多，可能会导致方法区溢出。溢出后抛出 OutOfMemoryError，JDK7及之前提示 PermGen space，JDK8及之后提示 Metaspace。</p>
<h2 id="JVM-有那几种情况会产生-OOM（内存溢出）？"><a href="#JVM-有那几种情况会产生-OOM（内存溢出）？" class="headerlink" title="JVM 有那几种情况会产生 OOM（内存溢出）？"></a>JVM 有那几种情况会产生 OOM（内存溢出）？</h2><p>回答：</p>
<p>在 JVM 中，内存溢出通常指的是某一块区域的内存超过了它的最大限制，导致无法分配内存，抛出相应的异常。常见的内存区域和对应的异常现象如下：</p>
<ol>
<li>堆内存溢出（OutOfMemoryError: Java heap space）</li>
</ol>
<ul>
<li><strong>原因</strong>：堆内存用于存储对象，如果应用创建了大量对象，超过了最大堆内存限制，就会导致堆内存溢出。</li>
<li><strong>现象</strong>：抛出 OutOfMemoryError: Java heap space 异常。</li>
</ul>
<ol>
<li>栈内存溢出（StackOverflowError）</li>
</ol>
<ul>
<li><strong>原因</strong>：每个线程都有自己的栈内存，如果递归调用过深，栈空间会被耗尽，导致栈内存溢出。</li>
<li><strong>现象</strong>：抛出 StackOverflowError 异常。</li>
</ul>
<ol>
<li>方法区内存溢出</li>
</ol>
<ul>
<li><strong>原因</strong>：JDK7及之前的版本使用永久代（PermGen）存储类的元数据，JDK8及之后使用元空间（Metaspace）。如果加载的类太多，或者类的元信息过多，可能会导致方法区溢出。</li>
<li><strong>现象</strong>：抛出 OutOfMemoryError，JDK7及之前提示 PermGen space，JDK8及之后提示 Metaspace。</li>
</ul>
<ol>
<li>直接内存溢出（OutOfMemoryError: Direct buffer memory）</li>
</ol>
<ul>
<li><strong>原因</strong>：Java 使用 NIO 进行 I/O 操作时，分配直接内存（通过 ByteBuffer.allocateDirect()），如果直接内存超过了最大限制，会发生溢出。</li>
<li><strong>现象</strong>：抛出 OutOfMemoryError: Direct buffer memory 异常。</li>
</ul>
<ol>
<li><strong>线程数过多导致的内存溢出（Unable to Create New Native Thread）</strong></li>
</ol>
<ul>
<li><strong>原因</strong>：每个线程都需要找空间和一定的操作系统资源。如果创建过多线程而超出操作系统的资源限制，可能无法再创建新的线程，导致 OOM。</li>
<li><strong>现象</strong>：抛出 <code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 异常。</li>
<li><strong>解决方法</strong>：减少线程数，合理设置线程池的大小，避免无限制地创建线程。</li>
</ul>
<ol>
<li><strong>GC 执行耗时过长导致的 OOM（GC Overhead Limit Exceeded）</strong></li>
</ol>
<ul>
<li><strong>原因</strong>：当 JVM 在垃圾回收时花费的时间过多回收的内存不足以满足需求，JVM 会抛出 <code>GC Overhead Limit Exceeded</code> 错误，以避免长时间的垃圾回收循环。</li>
<li><strong>现象</strong>：抛出 <code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> 错误。</li>
<li><strong>解决方法</strong>：增加堆内存，优化内存管理，减少不必要的对象创建，或者调整垃圾回收策略。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>堆内存</strong>：溢出后抛出 OutOfMemoryError: Java heap space。</li>
<li><strong>栈内存</strong>：溢出后抛出 StackOverflowError。</li>
<li><strong>方法区</strong>：溢出后抛出 OutOfMemoryError，JDK7之前是 PermGen space，JDK8之后是 Metaspace。</li>
<li><strong>直接内存</strong>：溢出后抛出 OutOfMemoryError: Direct buffer memory。</li>
<li><strong>线程数过多</strong>：抛出 Unable to create new native thread。</li>
<li><strong>GC 执行耗时过长</strong>：抛出 GC Overhead Limit Exceeded。</li>
</ul>
<h2 id="Java-中堆和栈的区别是什么？"><a href="#Java-中堆和栈的区别是什么？" class="headerlink" title="Java 中堆和栈的区别是什么？"></a>Java 中堆和栈的区别是什么？</h2><ol>
<li>堆（Heap）：</li>
</ol>
<ul>
<li><strong>用于存储对象实例和数组</strong>。每次使用 new 关键字创建对象时，JVM 都会在堆内存中分配空间。</li>
<li><strong>堆内存是动态分配的，大小不固定。</strong></li>
<li><strong>对象的生命周期由垃圾回收器管理</strong>，垃圾回收会定期检查不再被引用的对象，并回收其占用的内存。</li>
<li><strong>抛出异常：OutOfMrmoryError。</strong></li>
<li><strong>是线程共享的</strong>。</li>
</ul>
<ol>
<li>栈（Stack）：</li>
</ol>
<ul>
<li><strong>用于存储局部变量、方法调用和方法中的引用</strong>（例如，方法参数）。</li>
<li><strong>每个线程都会有自己的栈内存，存储方法调用的信息</strong>（例如返回地址、局部变量等）。</li>
<li><strong>对象的生命周期和方法调用一致，方法结束时就释放</strong></li>
<li><strong>栈内存是静态分配的，并且大小在编译时就确定</strong>。</li>
<li><strong>抛出异常：StackOverflowError</strong></li>
</ul>
<p>简单理解：</p>
<ul>
<li>堆：就像是一个存储大量数据的大仓库，<strong>里面存放着所有创建的对象</strong>。它的<strong>空间是动态分配</strong>的，<strong>垃圾回收机制会帮忙清理不再使用的空间</strong>。</li>
<li>栈：每个线程都有一个小仓库，<strong>里面存放的是方法调用时的局部数据和地址</strong>。这个仓库很小，<strong>方法一结束就会自动清空</strong>。</li>
</ul>
<h2 id="什么是-Java-中的直接内存（堆外内存）？"><a href="#什么是-Java-中的直接内存（堆外内存）？" class="headerlink" title="什么是 Java 中的直接内存（堆外内存）？"></a>什么是 Java 中的直接内存（堆外内存）？</h2><p>直接内存并不在《Java 虚拟机规范》中存在，所以并<strong>不属于 Java 运行时的内存区域</strong>。在 JDK 1.4 中引入了 NIO 机制，<strong>由操作系统直接管理这部分内容</strong> ，是堆外内存，<strong>主要为了提升读写数据的性能</strong>。在网络编程框架如 Netty 中被大量使用。(Netty 使用了 Reactor 模型，主线程去负责链接，然后分发子任务给 Reactor 子线程)</p>
<p><strong>要创建直接内存上的数据，可以使用 ByteBuffer。</strong></p>
<ul>
<li>语法： ByteBuffer directBuffer = ByteBuffer.allocateDirect (size);</li>
</ul>
<p>与堆内存的区别：</p>
<ul>
<li>直接内存访问更快，减少了堆内存到直接内存之间的复制；</li>
<li>使用完需要用cleaner进行回收。jvm垃圾收集器不会进行回收。</li>
</ul>
<h2 id="什么是-Java-中的常量池？"><a href="#什么是-Java-中的常量池？" class="headerlink" title="什么是 Java 中的常量池？"></a>什么是 Java 中的常量池？</h2><p>常量池（Constant Pool）是一个<strong>用于存储常量值的内存区域</strong>，主要用于<strong>提高性能和节省内存</strong>。常量池中有两种类型的常量：</p>
<ul>
<li>运行时常量池</li>
<li>字符串常量池</li>
</ul>
<ol>
<li><p><strong>运行时常量池</strong>：</p>
<ul>
<li>这是 <strong>JVM 在运行时通过 Class 文件加载的常量池</strong>，它<strong>包含类和方法中的常量信息</strong>，包括常量字符串、字段、方法引用等。加载到 JVM 后，运行时常量池会通过类的加载过程进入 Java 方法区，直到 JVM 退出。</li>
</ul>
</li>
<li><p><strong>字符串常量池</strong>：</p>
<ul>
<li>这是<strong>专门用于存储字符串常量的区域</strong>，<strong>位于 Java 堆内存中</strong>。通过字符串的 <code>intern()</code> 方法，字符串常量会被存入常量池中。这样如果遇到相同的字符串，JVM 就可以直接使用已经存在的字符串，而不是重新创建一个新的字符串对象，从而节省内存。</li>
</ul>
</li>
</ol>
<h3 id="常量池的作用："><a href="#常量池的作用：" class="headerlink" title="常量池的作用："></a>常量池的作用：</h3><ul>
<li><strong>通过将常用的常量值（如字符串）存储在常量池中，避免重复创建相同的常量对象</strong>，从而提高性能和减少内存占用。</li>
</ul>
<h3 id="对比和优化："><a href="#对比和优化：" class="headerlink" title="对比和优化："></a>对比和优化：</h3><ul>
<li>字符串常量池的实现让字符串在内存中的管理变得更高效。当在代码中使用类似 <code>String s = &quot;Hello&quot;;</code> 的方式时，JVM 会首先检查常量池中是否有 “Hello” 这个字符串。如果没有，则将它添加进去；如果已经有了，就直接引用已有的对象。</li>
</ul>
<p>总的来说，常量池不仅<strong>提升了 Java 应用的效率，还减少了内存的占用</strong>，<strong>特别是在大量使用常量字符串的场景中</strong>，优化显著。</p>
<h2 id="你了解-Java-的类加载器吗？"><a href="#你了解-Java-的类加载器吗？" class="headerlink" title="你了解 Java 的类加载器吗？"></a>你了解 Java 的类加载器吗？</h2><h3 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h3><p>它用于在运行时动态地将class字节码加载到内存中,以供JVM执行。</p>
<ul>
<li>启动类加载器 (Bootstrap ClassLoader)：<strong>这是最基本的类加载器，负责加载核心的 Java 类库</strong>，比如 rt.jar。它由 JVM 自身用 C++ 实现，因此不能直接在 Java 程序中访问。它是所有类加载器的父类加载器。</li>
<li>扩展类加载器 (Extension ClassLoader)：<strong>这个类加载器负责加载 lib/ext 目录下的类库</strong>，或者是由 java.ext.dirs 系统属性指定的路径下的类。它的主要任务是加载 Java 扩展的类库，比如一些第三方的库。</li>
<li>应用程序类加载器 (Application ClassLoader)：<strong>它负责加载应用程序的类路径下（classPath）的类</strong>（即 .class 文件）。通常我们直接使用 ClassLoader.getSystemClassLoader() 获取到的就是这个类加载器。它是用户自定义类加载器的默认父类加载器。</li>
<li>自定义类加载器(CustomizeClassLoader):自定义类继承ClassLoader,实现自定义类加载规则。</li>
</ul>
<h3 id="JDK-1-9-的变化"><a href="#JDK-1-9-的变化" class="headerlink" title="JDK 1.9 的变化"></a>JDK 1.9 的变化</h3><p>在 JDK 1.9 中，类加载器发生了一些变化。<strong>原本的扩展类加载器被重命名为 平台类加载器</strong> (PlatformClassLoader)。<strong>这个新的类加载器主要加载 JDK 平台本身的类库</strong>，<strong>属于 Java 平台模块系统的非核心模块</strong>，而不是 java.* 系列类。平台类加载器的引入是为了配合 JDK 9 的模块化特性。</p>
<h3 id="类加载器之间的关系"><a href="#类加载器之间的关系" class="headerlink" title="类加载器之间的关系"></a>类加载器之间的关系</h3><p>虽然有“双亲委派”的说法，<strong>但其实类加载器之间是通过组合关系来建立父子关系的</strong>。<strong>每个类加载器都有一个 parent 属性</strong>，表示它的父类加载器。当一个类加载器无法加载一个类时，它会委派给父类加载器去尝试加载。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>JDK 1.8 及之前：</p>
<ul>
<li>启动类加载器：加载核心 Java 类。</li>
<li>扩展类加载器：加载扩展库。</li>
<li>应用程序类加载器：加载用户类路径下的类。</li>
</ul>
</li>
<li><p>JDK 1.9 及以后：</p>
<ul>
<li>扩展类加载器被重命名为 平台类加载器，用于加载非核心模块，配合 Java 模块系统。</li>
</ul>
</li>
</ul>
<h2 id="什么是-Java-中的-JIT（Just-In-Time）"><a href="#什么是-Java-中的-JIT（Just-In-Time）" class="headerlink" title="什么是 Java 中的 JIT（Just-In-Time）?"></a>什么是 Java 中的 JIT（Just-In-Time）?</h2><p>JIT，全称 Just-In-Time，就是<strong>即时编译器</strong>。它的作用是——<strong>在程序运行时，把 Java 字节码动态编译成机器码，让代码执行得更快</strong>。</p>
<p>原理：</p>
<ol>
<li><strong>Java 一开始是解释执行的</strong>，也就是说，JVM 会一边解释字节码、一边执行，所以<strong>效率比较低</strong>。</li>
<li>但当 JVM 发现某些方法或代码块被频繁执行时，就会把它们<strong>标记为热点代码</strong>（Hotspot Code）</li>
<li>然后 JIT 编译器就会出手，<strong>把这段热点代码编译成机器码，并缓存起来</strong>。<strong>下次再执行的时候，直接运行机器码</strong>，不用再解释一遍，性能就接近 C++ 那种编译型语言了。</li>
</ol>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>比如有个循环执行上百万次，JVM 发现它很“热”，就会触发 JIT，把这段循环编译成本地机器指令。下次再跑这段循环时，几乎是“原生速度”在执行，快很多。</p>
<h3 id="JIT-编译优化做了什么？"><a href="#JIT-编译优化做了什么？" class="headerlink" title="JIT 编译优化做了什么？"></a>JIT 编译优化做了什么？</h3><p>JIT <strong>不只是把代码编译成机器码，还会做很多优化</strong>，比如：</p>
<ul>
<li>方法内联（Inlining）：<strong>把小方法的代码直接展开，减少方法调用开销</strong>。</li>
<li>逃逸分析（Escape Analysis）：<strong>判断对象是否只在一个线程中使用，JIT编译器根据对象的逃逸状态采用不同的优化策略，以提高Java程序的性能和效率。</strong></li>
<li>循环展开（Loop Unrolling）：<strong>减少循环判断次数</strong>，加快执行速度。</li>
<li><strong>锁消除、标量替换</strong>：进一步减少多线程锁竞争，提高性能。</li>
</ul>
<p>这些优化都是在运行时动态完成的，因此 JIT 会越“跑越快”。</p>
<h3 id="热点代码识别方式："><a href="#热点代码识别方式：" class="headerlink" title="热点代码识别方式："></a>热点代码识别方式：</h3><p>JIT 会通过两种方式识别热点：</p>
<ul>
<li>采样探测：周期性地检测哪些方法经常出现在栈顶；</li>
<li>计数器探测（HotSpot 采用）：统计方法被调用的次数或循环执行次数，超过阈值就触发编译。<h3 id="JIT-编译器类型"><a href="#JIT-编译器类型" class="headerlink" title="JIT 编译器类型"></a><strong>JIT 编译器类型</strong></h3></li>
</ul>
<p>JVM 里其实有两个 JIT 编译器：</p>
<ul>
<li>C1（Client）：启动快，适合客户端程序；</li>
<li>C2（Server）：优化更激进，适合服务器端应用。</li>
</ul>
<h3 id="JIT可能带来的问题："><a href="#JIT可能带来的问题：" class="headerlink" title="JIT可能带来的问题："></a>JIT可能带来的问题：</h3><p>虽然 JIT 能显著提高性能，但它也有一些潜在的副作用：</p>
<ol>
<li>首次执行慢（编译开销）：<br>热点代码第一次被编译时需要消耗 CPU 时间，会导致程序初期性能波动。</li>
</ol>
<p>➤ 解决方案：可以通过“<strong>预热机制</strong>”提前让热点代码运行几次，<strong>让 JIT 提前触发</strong>；或者使用 AOT（Ahead-Of-Time）提前编译。</p>
<ol>
<li>内存占用增加：<br>编译后的机器码会被缓存到内存中，代码越多、占用越大。</li>
</ol>
<p>➤ 解决方案：通过 JVM 参数（比如 -XX:ReservedCodeCacheSize）<strong>限制代码缓存大小</strong>。</p>
<ol>
<li>编译与执行争用 CPU 资源：<br>JIT 编译本身也会消耗 CPU，可能在高并发场景下带来瞬时抖动。</li>
</ol>
<p>➤ 解决方案：使用分层编译（Tiered Compilation），让 C1 先做轻量编译，C2 后做深度优化，平衡性能与稳定性。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JIT 就是即时编译器，它在 Java 程序运行时，把热点代码动态编译成本地机器码执行。<br>这样程序能越跑越快，性能接近 C++。<br>但它也有缺点，比如首次编译会导致启动慢、占 CPU 和内存，还可能因为过度优化而回退。<br>通常我们通过预热或分层编译（Tiered Compilation）来平衡性能和稳定性。</p>
<h2 id="JIT-编译后的代码存在哪？"><a href="#JIT-编译后的代码存在哪？" class="headerlink" title="JIT 编译后的代码存在哪？"></a>JIT 编译后的代码存在哪？</h2><p>JIT 编译后的机器码会被存放在 <strong>Code Cache（代码缓存区）</strong> 里。<br><strong>这个区域是 JVM 专门为即时编译器（JIT）准备的一块独立内存，用来存放编译生成的本地机器码。</strong></p>
<ul>
<li>需要注意的是，Code Cache <strong>不在堆内，也不在方法区（或元空间）里</strong>。</li>
<li>而 Code Cache 是另外一块独立的本地内存区域，JVM 会在里面缓存 JIT 编译后的机器码，方便后续直接执行。</li>
</ul>
<p>Code Cache 的大小和行为<strong>可以通过 JVM 参数来配置</strong>：</p>
<ul>
<li>-XX:InitialCodeCacheSize：设置初始大小</li>
<li>-XX:ReservedCodeCacheSize：设置最大容量</li>
<li>-XX:+PrintCodeCache：可以打印出当前 Code Cache 的使用信息</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><strong>JIT 编译后的机器码会被放在 JVM 的 Code Cache 区，这是一块独立于堆和元空间的本地内存，用来缓存编译后的机器码，提高执行效率</strong></p>
<h2 id="什么是-Java-的-AOT（Ahead-Of-Time）？"><a href="#什么是-Java-的-AOT（Ahead-Of-Time）？" class="headerlink" title="什么是 Java 的 AOT（Ahead-Of-Time）？"></a>什么是 Java 的 AOT（Ahead-Of-Time）？</h2><h3 id="什么是AOT"><a href="#什么是AOT" class="headerlink" title="什么是AOT?"></a>什么是AOT?</h3><p>AOT，全称 Ahead-Of-Time，就是<strong>提前编译</strong>。它和 JIT（即时编译）相反，JIT 是程序运行时才把字节码编译成机器码，<strong>而 AOT 是在程序运行之前，就提前把字节码编译成本地机器码</strong>。</p>
<h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>AOT 在编译阶段就会对 Java 字节码进行静态分析，然后生成目标平台能直接执行的机器码，也就是所谓的 Native Image（本地镜像）。<br>这样程序启动时就不需要 JVM 再去解释或即时编译，可以直接运行在操作系统上，启动非常快。</p>
<h3 id="AOT-的优势："><a href="#AOT-的优势：" class="headerlink" title="AOT 的优势："></a>AOT 的优势：</h3><ul>
<li>启动快：因为代码已经是<strong>机器码</strong>，不需要再运行时编译，特别适合快速启动的场景，比如云原生、Serverless、微服务。</li>
<li>内存占用更低：<strong>AOT 编译后的程序不再依赖完整 JVM</strong>，内存占用更少。</li>
<li><strong>冷启动性能好</strong>：省去了 JIT 的预热阶段，<strong>程序一启动就能达到高性能</strong>。</li>
</ul>
<h3 id="AOT-的缺点："><a href="#AOT-的缺点：" class="headerlink" title="AOT 的缺点："></a>AOT 的缺点：</h3><ul>
<li><strong>缺乏运行时优化</strong>：JIT 可以根据程序运行时的热点信息动态优化，而 AOT 生成的代码是静态的，<strong>长时间运行的程序性能可能不如 JIT</strong>。</li>
<li><strong>跨平台性差</strong>：编译后的机器码是平台相关的，<strong>不能像字节码那样“一次编译，到处运行”</strong>。</li>
<li><strong>灵活性差</strong>：像反射、动态代理、类加载等运行时特性会受到限制，编译时必须都能确定（也就是所谓的“封闭性假设”）。</li>
</ul>
<p>使用场景：<br>AOT 一般<strong>用在对启动速度敏感的场景</strong>，比如：</p>
<ul>
<li>云原生 / Serverless 应用</li>
<li>容器化环境、微服务、嵌入式系统</li>
<li>启动频繁、生命周期短的任务型服务</li>
</ul>
<h3 id="常见-AOT-工具："><a href="#常见-AOT-工具：" class="headerlink" title="常见 AOT 工具："></a>常见 AOT 工具：</h3><ul>
<li>GraalVM：目前最主流的 AOT 编译器，能把 Java 程序直接编译成本地可执行文件。</li>
<li>jaotc：Java 9 引入的官方 AOT 工具，但在生产中使用不多，更多是实验性质。</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>AOT 就是提前编译（Ahead-Of-Time），在程序运行前就把 Java 字节码编译成本地机器码。<br>这样程序启动更快、占用更少，非常适合微服务、云原生、Serverless 这种对启动速度要求高的场景。<br>但它缺点是少了 JIT 的运行时优化，性能长期表现可能不如 JIT，灵活性也更差。<br>常见实现是 GraalVM 的 native image。</p>
<h2 id="你了解-Java-的逃逸分析吗？"><a href="#你了解-Java-的逃逸分析吗？" class="headerlink" title="你了解 Java 的逃逸分析吗？"></a>你了解 Java 的逃逸分析吗？</h2><h3 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h3><p>逃逸分析（Escape Analysis）是 JVM 的一种<strong>编译优化技术</strong>，主要用来<strong>判断一个对象是否会逃出当前方法或线程的作用范围</strong>。如果不会逃逸，JVM 就能对它做一系列性能优化，比如<strong>栈上分配、锁消除、标量替换</strong>等。</p>
<h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><p>JVM 在 JIT 编译阶段，会静态分析对象的使用范围：</p>
<ul>
<li>如果<strong>对象只在当前方法内使用，不会被别的线程或外部引用到</strong>，就属于“<strong>不逃逸</strong>”；</li>
<li>如果<strong>对象作为参数传给别的方法，或被赋值给全局变量、返回给外部</strong>，那就是“<strong>发生了逃逸</strong>”。</li>
</ul>
<p>逃逸的本质，就是看<strong>一个对象的生命周期是否“跑出了”原来的作用域</strong>。</p>
<h3 id="根据逃逸范围分类："><a href="#根据逃逸范围分类：" class="headerlink" title="根据逃逸范围分类："></a>根据逃逸范围分类：</h3><ul>
<li><strong>方法逃逸</strong>（Arg Escape）：对象被当作参数传递到别的方法；</li>
<li><strong>线程逃逸</strong>（Global Escape）：对象被多个线程共享，比如赋给静态变量；</li>
<li><strong>无逃逸</strong>（No Escape）：对象完全只在当前方法中使用。</li>
</ul>
<h3 id="JVM-根据逃逸情况会做的三种优化："><a href="#JVM-根据逃逸情况会做的三种优化：" class="headerlink" title="JVM 根据逃逸情况会做的三种优化："></a>JVM 根据逃逸情况会做的三种优化：</h3><ul>
<li><strong>栈上分配</strong>：<ul>
<li>如果不逃逸，<strong>JVM 就能直接在栈上分配，而不是在堆上分配</strong>。这样分配速度快，还能减少 GC 压力。</li>
</ul>
</li>
<li>锁消除：<ul>
<li><strong>如果对象只在单线程内使用，那加的 synchronized 锁其实没意义，JVM 就能自动去掉</strong>。</li>
</ul>
</li>
<li>标量替换：<ul>
<li>如果对象不逃逸，JVM 可以<strong>把它的字段拆成独立的局部变量</strong>，甚至连对象本身都不创建。</li>
</ul>
</li>
</ul>
<h3 id="逃逸分析虽然很强，但也有一些问题："><a href="#逃逸分析虽然很强，但也有一些问题：" class="headerlink" title="逃逸分析虽然很强，但也有一些问题："></a>逃逸分析虽然很强，但也有一些问题：</h3><ul>
<li>它本身是个复杂的分析过程，会<strong>增加编译开销</strong>；</li>
<li>在某些复杂逻辑中，<strong>分析结果可能不明显</strong>，导致<strong>优化收益不如消耗</strong>；</li>
<li><strong>所以实际中，逃逸分析对短小高频方法特别有用，但对复杂代码可能收益有限</strong>。</li>
</ul>
<h3 id="常见-JVM-参数（了解即可）"><a href="#常见-JVM-参数（了解即可）" class="headerlink" title="常见 JVM 参数（了解即可）"></a>常见 JVM 参数（了解即可）</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+DoEscapeAnalysis</span>       <span class="comment"># 开启逃逸分析（默认开启）</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:-DoEscapeAnalysis</span>       <span class="comment"># 关闭逃逸分析</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+EliminateLocks</span>         <span class="comment"># 启用锁消除</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+EliminateAllocations</span>   <span class="comment"># 启用标量替换</span></span><br></pre></td></tr></table></figure>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>逃逸分析是 JVM 的一种优化技术，用来判断一个对象会不会‘逃出’当前方法或线程。<br>如果对象不会逃逸，JVM 就能做三种优化：<br>一是栈上分配，不用进堆，减少 GC；<br>二是锁消除，去掉没必要的同步；<br>三是标量替换，直接把对象拆成局部变量。<br>简单来说，它能让代码执行更快、内存占用更少，是 JIT 编译器很核心的优化手段。</p>
<h2 id="Java-中的强引用、软引用、弱引用和虚引用分别是什么？"><a href="#Java-中的强引用、软引用、弱引用和虚引用分别是什么？" class="headerlink" title="Java 中的强引用、软引用、弱引用和虚引用分别是什么？"></a>Java 中的强引用、软引用、弱引用和虚引用分别是什么？</h2><p>在 Java 中，引用分为<strong>强引用、软引用、弱引用和虚引用</strong>四种类型。<br>它们的区别在于——<strong>GC（垃圾回收器）是否以及何时会回收对象</strong>。<br>简单说：强软弱虚，引用越往后，GC 越容易回收。</p>
<h3 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h3><p>这是最常见、也是 Java <strong>默认的引用方式</strong>。<br><strong>只要一个对象有强引用存在，GC 永远不会回收它</strong>，即使内存不足也会宁可抛出OutOfMemoryError。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>最普通的 new 出来的对象就是强引用；</li>
<li>只要引用还在，GC 不会动它。</li>
</ul>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>[] arr = <span class="keyword">new</span> <span class="type">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是典型的强引用。比如在 HashMap 里，键和值默认就是强引用。</p>
<h3 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h3><p>软引用是“<strong>可有可无</strong>”的引用，常用于<strong>缓存</strong>。<br><strong>当系统内存不足时，GC 会优先清理掉软引用指向的对象，以避免 OOM</strong>,内存足够时，不会去管他</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对象不会立即回收，只有在内存紧张时才清理；</li>
<li>常用于实现缓存机制，比如图片缓存、对象缓存。</li>
</ul>
<h4 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;<span class="built_in">Object</span>&gt; softRef = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="built_in">Object</span>());</span><br></pre></td></tr></table></figure>
<p>Guava Cache 内部就使用了 SoftReference 来做内存友好的缓存</p>
<h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h3><p>弱引用比软引用更脆弱。<br><strong>只要 GC 运行，就会回收它，无论内存够不够</strong>。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>生命周期非常短；</li>
<li>常用于防止内存泄漏，比如 WeakHashMap、ThreadLocal。</li>
</ul>
<h4 id="举例：-2"><a href="#举例：-2" class="headerlink" title="举例："></a>举例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;<span class="built_in">Object</span>&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="built_in">Object</span>());</span><br></pre></td></tr></table></figure>
<p>像 WeakHashMap 中的 key 就是弱引用，当 key 没被外部引用后，会被自动回收，Entry 也随之清除。</p>
<h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h3><p>虚引用最弱，<strong>几乎不影响对象生命周期</strong>。<br><strong>它存在的意义不是访问对象，而是用来“感知对象何时被回收”</strong>。</p>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>不能通过虚引用获取对象；</li>
<li>通常配合 ReferenceQueue 使用，用于资源清理（比如文件句柄、DirectBuffer）。</li>
</ul>
<h4 id="举例：-3"><a href="#举例：-3" class="headerlink" title="举例："></a>举例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;<span class="built_in">Object</span>&gt; phantomRef =</span><br><span class="line">    <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> <span class="built_in">Object</span>(), <span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>当对象被回收后，虚引用会被放入队列中，方便开发者执行资源释放逻辑。</p>
<h3 id="对比表格"><a href="#对比表格" class="headerlink" title="对比表格"></a>对比表格</h3><div class="table-container">
<table>
<thead>
<tr>
<th>引用类型</th>
<th>生命周期</th>
<th>何时被 GC 回收</th>
<th>典型用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>最长</td>
<td>永不（除非引用断开）</td>
<td>普通对象引用</td>
</tr>
<tr>
<td>软引用</td>
<td>次长</td>
<td>内存不足时</td>
<td>缓存（如图片缓存）</td>
</tr>
<tr>
<td>弱引用</td>
<td>很短</td>
<td>一旦 GC 运行</td>
<td>防止内存泄漏（如 WeakHashMap）</td>
</tr>
<tr>
<td>虚引用</td>
<td>最短</td>
<td>几乎立即</td>
<td>跟踪回收状态、资源清理</td>
</tr>
</tbody>
</table>
</div>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>Java 里的引用分四种：强、软、弱、虚，强度依次减弱。<br>强引用是默认的，只要有它，对象就不会被回收；<br>软引用一般做缓存用，内存不够时才清理；<br>弱引用更弱，GC 一运行就回收，比如 WeakHashMap；<br>虚引用最弱，用来监听对象何时被回收，比如清理 DirectBuffer。<br>一句话总结：越往后越容易被回收。</p>
<h2 id="Java-中常见的垃圾收集器有哪些？"><a href="#Java-中常见的垃圾收集器有哪些？" class="headerlink" title="Java 中常见的垃圾收集器有哪些？"></a>Java 中常见的垃圾收集器有哪些？</h2><p>在JVM中，垃圾回收器是实现垃圾回收算法的具体工具，主要分为处理年轻代和老年代的回收器。除了G1，其他回收器一般需要成对使用。常见的垃圾回收器主要包括以下几类：</p>
<ol>
<li><p><strong>Serial 和 Serial Old</strong>：这是<strong>最基础的串行垃圾回收器，单线程工作</strong>。它适合资源受限的客户端程序，虽然简单但在多核系统下效率不高。</p>
</li>
<li><p><strong>ParNew 和 CMS (Concurrent Mark Sweep)</strong> ：ParNew <strong>是 Serial 的多线程版本</strong>，<strong>CMS 关注的是减少系统停顿时间，它能在用户线程运行的同时并发进行垃圾回收</strong>。不过 CMS 会有“浮动垃圾”、内存碎片以及退化成Full GC的问题。</p>
</li>
<li><p><strong>Parallel Scavenge 和 Parallel Old (PS + PO)</strong> ：<strong>这是 JDK8 默认使用的回收器组合</strong>，采用<strong>多线程方式</strong>，追求高吞吐量，适合后台批处理任务等场景。但它的暂停时间较长，不太适合对响应时间要求高的业务。</p>
</li>
<li><p><strong>G1 (Garbage First)</strong> ：<strong>G1 是 JDK9 之后的默认回收器</strong>，<strong>它可以同时处理年轻代和老年代，采用分区+并发回收机制</strong>，能很好地控制最大停顿时间。适合大内存的服务端应用，比如堆内存 6G 以上的场景。</p>
</li>
<li><p><strong>Shenandoah</strong>：由 RedHat 开发，<strong>主打低停顿</strong>，连“整理”这一阶段都可以并发执行，因此无论堆大小如何，停顿时间都可以非常低。</p>
</li>
<li><p><strong>ZGC</strong>：是<strong>更进一步的低延迟回收器</strong>，号称 STW 停顿不会超过 1ms，而且支持从几百兆到 16TB 的堆内存扩展，适合超大内存和延迟非常敏感的系统。</p>
</li>
</ol>
<p>总结一句话：<br>JDK8 之前推荐用 CMS 或 PS+PO，JDK9 之后推荐 G1；如果对延迟非常敏感，可以选择 Shenandoah 或 ZGC。</p>
<p><strong>对比一下 G1、Shenandoah 和 ZGC 这三款垃圾回收器</strong></p>
<p>G1、Shenandoah 和 ZGC 都是现代 Java 的低延迟 GC 回收器。</p>
<ul>
<li>G1 将堆划分为 Region，通过并发标记和 STW 压缩来减少 full GC，适合通用场景；</li>
<li>Shenandoah 实现了并发压缩，通过转发表解决引用更新问题，可将 GC 停顿控制在毫秒级；</li>
<li>ZGC 采用 colored pointer 技术，实现了全并发、几乎全程无停顿的 GC，停顿时间低于 1ms，适用于延迟极敏感的大型系统。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>回收器</th>
<th>一句话记住它</th>
</tr>
</thead>
<tbody>
<tr>
<td>G1 GC</td>
<td><strong>区域化管理，目标是均衡停顿和吞吐</strong></td>
</tr>
<tr>
<td>Shenandoah</td>
<td><strong>并发压缩，目标是最小停顿（MS 级）</strong></td>
</tr>
<tr>
<td>ZGC</td>
<td><strong>染色指针，全并发回收，目标是亚毫秒级停顿</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Java-中如何判断对象是否是垃圾？不同实现方式有何区别？"><a href="#Java-中如何判断对象是否是垃圾？不同实现方式有何区别？" class="headerlink" title="Java 中如何判断对象是否是垃圾？不同实现方式有何区别？"></a>Java 中如何判断对象是否是垃圾？不同实现方式有何区别？</h2><p>其实在 JVM 中，为了判断堆里的对象还能不能继续使用，主要用的是一种叫“可达性分析”的方法。</p>
<ul>
<li><p>早期也有一种方法叫“<strong>引用计数法</strong>”，就是每个对象维护一个<strong>计数器</strong>，<strong>每次被别的对象引用时加一，引用断了就减一。如果计数器变成 0，就说明没人再引用它了，可以回收了</strong>。这种方法实现简单、逻辑也直观，但有一个很大的问题：<strong>循环引用</strong>。<strong>比如对象 A 引用 B，B 也引用 A，虽然它们已经不再被程序其他地方引用，但它们互相指着对方，引用计数就永远不是 0</strong>，这样就会造成<strong>内存泄漏</strong>。</p>
</li>
<li><p>所以 Java 后来改用<strong>可达性分析算法</strong>（Reachability Analysis），这是一种从一组“<strong>GC Root</strong>”对象出发，看一个对象是不是还能被这些根对象“追踪”到的方式。<strong>如果一个对象从 GC Root 开始，一路沿着引用链可以走到，那说明它还在被用，就不能回收；反过来，如果走不到，就是“不可达”，可以回收</strong>。这种方法的好处是能很自然地处理掉循环引用的问题。</p>
<blockquote>
<p>什么是GC Root</p>
</blockquote>
</li>
</ul>
<p>GC Root 通常包括像：当前线程正在运行的方法栈、静态变量、类加载器、本地方法引用等。</p>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p><strong>重点记住“引用计数有循环引用问题”、“可达性分析是 Java 的选择”这两个点就够了。</strong></p>
<h2 id="为什么-Java-的垃圾收集器将堆分为老年代和新生代？"><a href="#为什么-Java-的垃圾收集器将堆分为老年代和新生代？" class="headerlink" title="为什么 Java 的垃圾收集器将堆分为老年代和新生代？"></a>为什么 Java 的垃圾收集器将堆分为老年代和新生代？</h2><p>Java 堆之所以要分为新生代（Young Generation）和老年代（Old Generation），<br><strong>核心目的是：优化 GC 性能。不同生命周期的对象放在一起回收效率太低，分代后可以“有针对性地清理”，大幅提升回收效率。</strong></p>
<h3 id="为什么要分代？"><a href="#为什么要分代？" class="headerlink" title="为什么要分代？"></a>为什么要分代？</h3><p>在 Java 程序运行过程中，对象的生命周期差异很大，有的“朝生夕死”，有的会长期存在。</p>
<p>绝大多数对象存活时间很短：例如临时变量、方法中的局部对象，往往用一次就没了。<br>→ 这些短命对象集中放在新生代，用轻量的算法快速清理。</p>
<p>少数对象生命周期很长：比如缓存、线程池、单例等，长期存在。<br>→ 这类对象被晋升到老年代，使用更稳定的算法回收，避免频繁扫描。</p>
<ul>
<li>即：不同“寿命”的对象放在不同区域，<strong>GC 时就能有针对性地处理，提升整体性能</strong>。</li>
</ul>
<h3 id="堆的分代结构"><a href="#堆的分代结构" class="headerlink" title="堆的分代结构"></a>堆的分代结构</h3><p>Java 堆（Heap）根据对象的生命周期分为三块：</p>
<ul>
<li>新生代（Young Generation）：存放新创建的对象；</li>
<li>老年代（Old Generation）：存放存活时间较长的对象；</li>
<li>永久代 / 元空间（Metaspace）：存放类元数据（方法、静态变量等）。</li>
</ul>
<h3 id="新生代结构"><a href="#新生代结构" class="headerlink" title="新生代结构"></a>新生代结构</h3><p>新生代又细分为三块：</p>
<ul>
<li>Eden 区：新对象优先分配在这里；</li>
<li>Survivor0（S0）和 Survivor1（S1）：两个 Survivor 区轮流使用。</li>
</ul>
<p>GC 时，Eden 区中还活着的对象会被复制到一个 Survivor 区，<br>当对象在多次 GC 后仍然存活，就会晋升（Promote）到老年代。<br>新生代一般采用 复制算法（Copying GC），清理速度快、内存碎片少，适合短生命周期对象。</p>
<h3 id="老年代的作用"><a href="#老年代的作用" class="headerlink" title="老年代的作用"></a>老年代的作用</h3><p>老年代用于存放长期存活或较大对象，GC 频率较低。<br><strong>通常采用 标记-清除（Mark-Sweep） 或 标记-整理（Mark-Compact） 算法。</strong><br>这类算法能最大限度地回收空间，但执行时间较长。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>Java 把堆分成新生代和老年代是<strong>为了提升 GC 效率</strong>。<br><strong>因为大部分对象‘朝生夕死’，只活一会儿，就放在新生代，用轻量算法快速清理。</strong><br><strong>而少量长期存在的对象，比如缓存和单例，会晋升到老年代，用更稳定的标记清除算法处理。</strong><br>这样既减少扫描范围，又能让 GC 更高效。</p>
<h2 id="为什么-Java-8-移除了永久代（PermGen）并引入了元空间（Metaspace）？"><a href="#为什么-Java-8-移除了永久代（PermGen）并引入了元空间（Metaspace）？" class="headerlink" title="为什么 Java 8 移除了永久代（PermGen）并引入了元空间（Metaspace）？"></a>为什么 Java 8 移除了永久代（PermGen）并引入了元空间（Metaspace）？</h2><p>Java 8 移除永久代（PermGen），引入元空间（Metaspace），<br>是为了解决<strong>PermGen 固定大小、易导致 OOM、GC 效率低等问题</strong>，让类元数据的存储更灵活高效。</p>
<h3 id="PermGen-的问题与局限"><a href="#PermGen-的问题与局限" class="headerlink" title="PermGen 的问题与局限"></a>PermGen 的问题与局限</h3><p>永久代是 HotSpot 虚拟机在 Java 7 及之前版本中用于存储<strong>类的元信息（类名、方法、常量池等）</strong> 的一块 JVM 内存区域。<br>但这种设计存在不少缺：</p>
<ul>
<li><strong>固定大小，不可动态扩展</strong><ul>
<li>永久代的大小需要在 JVM 启动时固定设置（通过 -XX:MaxPermSize），如果类加载过多（如动态加载、反射、大量 JSP），很容易触发 OutOfMemoryError: PermGen space。</li>
</ul>
</li>
<li><strong>存储内容复杂，容易混乱</strong><ul>
<li>PermGen <strong>既保存类信息，又存储静态变量、常量池等数据</strong>，不仅容易造成空间竞争，还让 GC 难以优化。</li>
</ul>
</li>
<li>GC 效率低<ul>
<li><strong>永久代的数据大多是长期存在的类元信息</strong>，GC 很难高效回收，<strong>容易频繁触发 Full GC</strong>，尤其在应用频繁加载类或热部署时问题更明显。</li>
</ul>
</li>
</ul>
<p><strong>一句话总结 PermGen 的痛点：固定大小 + 内存受限 + GC 慢 + 容易 OOM。</strong></p>
<h3 id="Metaspace-的改进与优势"><a href="#Metaspace-的改进与优势" class="headerlink" title="Metaspace 的改进与优势"></a>Metaspace 的改进与优势</h3><ol>
<li>使用本地内存（Native Memory）<br><strong>元空间不再使用 JVM 堆内存，而是使用本地内存</strong>。</li>
</ol>
<ul>
<li>理论上只受操作系统内存限制，更灵活、更不容易 OOM。</li>
</ul>
<ol>
<li>自动扩容</li>
</ol>
<ul>
<li>元空间可以根据类加载的实际需求<strong>自动增长大小</strong>，减少了手动设置内存的麻烦，同时降低了内存管理风险。</li>
</ul>
<ol>
<li><p>GC 效率更高<br><strong>元空间中的类元数据与堆分离，GC 在扫描堆对象时更轻量</strong>，同时降低 Full GC 频率，提高 JVM 性能。</p>
</li>
<li><p>跨平台与统一性<br>HotSpot 与 JRockit 在此之前实现不同，Java 8 将两者合并时选择了移除 PermGen，统一为 Metaspace。</p>
</li>
</ol>
<h3 id="如何调整元空间大小"><a href="#如何调整元空间大小" class="headerlink" title="如何调整元空间大小"></a>如何调整元空间大小</h3><p>虽然元空间可动态增长，但仍可通过参数手动控制：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:MetaspaceSize=</span>128M       <span class="comment"># 元空间初始大小</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:MaxMetaspaceSize=</span>512M    <span class="comment"># 元空间最大上限</span></span><br></pre></td></tr></table></figure>
<h3 id="表格对比"><a href="#表格对比" class="headerlink" title="表格对比"></a>表格对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>对比项</th>
<th>永久代（PermGen）</th>
<th>元空间（Metaspace）</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储位置</td>
<td>JVM 堆内存</td>
<td>本地内存（Native）</td>
</tr>
<tr>
<td>是否可扩展</td>
<td>否，大小固定</td>
<td>是，可根据需要自动扩展</td>
</tr>
<tr>
<td>常见问题</td>
<td>容易 OOM、GC 低效</td>
<td>更灵活，OOM 几率更低</td>
</tr>
<tr>
<td>JVM 版本</td>
<td>Java 7 及之前</td>
<td>Java 8 及之后</td>
</tr>
</tbody>
</table>
</div>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>Java 8 把永久代移除掉，换成元空间，<strong>主要是为了解决内存固定、OOM 和 GC 效率低的问题</strong>。<br>永久代的大小是固定的，类加载多了就容易溢出；<br>而元空间用的是<strong>本地内存</strong>，能根据需要<strong>自动扩展</strong>，管理更灵活，性能也更好。<br>同时它还降低了 Full GC 触发的概率，整体上让 JVM 的内存管理更稳定。</p>
<h2 id="为什么-Java-新生代被划分为-S0、S1-和-Eden-区？"><a href="#为什么-Java-新生代被划分为-S0、S1-和-Eden-区？" class="headerlink" title="为什么 Java 新生代被划分为 S0、S1 和 Eden 区？"></a>为什么 Java 新生代被划分为 S0、S1 和 Eden 区？</h2><p>Java 把新生代划分为 Eden、S0（Survivor 0）和 S1（Survivor 1） 三个区，<br>核心目的是：<strong>提高内存利用率</strong>，配合复制算法实现高效的 Minor GC（年轻代垃圾回收）。</p>
<h3 id="为什么要分区？"><a href="#为什么要分区？" class="headerlink" title="为什么要分区？"></a>为什么要分区？</h3><p>在 JVM 的新生代中，大多数对象“朝生夕死”，即生命周期很短。<br>JVM 使用 复制算法（Copying GC） 来高效清理这部分内存。<br>复制算法的基本思想是：</p>
<ul>
<li><p>每次只使用一半内存，当发生 GC 时，把存活的对象复制到另一半，然后一次性清理原区域。</p>
<p>这个方法非常高效，但有个问题：<br>如果只用两块区域，一块存放对象，一块作为复制目标，那每次只有 50% 的内存被使用，<strong>利用率太低</strong>。<br>于是，Java 采用了“三分法”：<strong>Eden + Survivor0（S0）+ Survivor1（S1）</strong>，在保证复制安全的前提下，<strong>把内存利用率从 50% 提高到了 90%</strong>。</p>
</li>
</ul>
<h3 id="分区结构与比例"><a href="#分区结构与比例" class="headerlink" title="分区结构与比例"></a>分区结构与比例</h3><p>默认情况下，新生代的比例为：Eden : S0 : S1 = 8 : 1 : 1<br>也就是说：</p>
<ul>
<li>Eden 占新生代的约 80%；</li>
<li>两个 Survivor 区各占约 10%。</li>
<li>内存利用率 = 90%，因为只有一个 Survivor 是备用区。<h3 id="GC时的工作流程"><a href="#GC时的工作流程" class="headerlink" title="GC时的工作流程"></a>GC时的工作流程</h3></li>
</ul>
<ol>
<li>新对象首先分配在 Eden 区。</li>
<li>当 Eden 区满时触发 Minor GC：</li>
</ol>
<ul>
<li>JVM 会把 Eden + 正在使用的 Survivor 区 中还存活的对象复制到另一个空闲的 Survivor 区。</li>
<li>Eden 和旧 Survivor 区会被清空。</li>
</ul>
<ol>
<li>两个 Survivor 区轮流使用（S0↔S1），达到“翻转”效果。</li>
<li>当对象在 Survivor 区经历多次 GC 后仍然存活，会晋升到 老年代（Old Gen）。</li>
</ol>
<p>整个过程称为 <strong>复制-清空-切换</strong>（Copy-Clear-Swap），保证了：</p>
<ul>
<li>快速分配（因为 Eden 连续分配，指针移动即可）；</li>
<li>无内存碎片（复制算法本身保证连续性）；</li>
<li>高内存利用率（90% 使用率）。</li>
</ul>
<h3 id="如果-Survivor-放不下怎么办？"><a href="#如果-Survivor-放不下怎么办？" class="headerlink" title="如果 Survivor 放不下怎么办？"></a>如果 Survivor 放不下怎么办？</h3><p><strong>当 Survivor 空间不足时，幸存的对象会直接晋升到老年代</strong>。<br>这就是所谓的“<strong>提前晋升</strong>（Premature Promotion）”，<br>频繁出现会导致 老年代压力增加、触发 Full GC，所以 Survivor 的合理大小非常重要。</p>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>新生代分成 Eden、S0 和 S1，是<strong>为了配合复制算法优化内存利用率</strong>。<br>对象先放在 Eden，GC 时把活着的对象复制到另一个 Survivor 区，两个 Survivor 轮流用。<br>这样只需要一块备用空间，就能让内存利用率达到 90%，同时避免内存碎片。<br>简单说，就是为了让年轻代的 GC 又快又省空间。</p>
<h2 id="什么是三色标记算法？"><a href="#什么是三色标记算法？" class="headerlink" title="什么是三色标记算法？"></a>什么是三色标记算法？</h2><p>三色标记算法是 JVM 并发垃圾回收中用来区分对象状态的算法。<br>它把对象分成三种颜色：<strong>白色表示没访问过、可能是垃圾；灰色表示正在扫描；黑色表示已经扫描完成的活对象</strong>。<br>GC 从根对象开始，把引用的对象标记成灰色，然后逐步转黑，最后剩下的白色对象就会被清除。<br>具体流程：</p>
<ol>
<li>所有对象初始为白色。</li>
<li>根对象被标为灰色 → 遍历它的引用。</li>
<li>遍历时发现其他对象 → 标为灰色。</li>
<li>被完全扫描完的灰色 → 转为黑色。</li>
<li>最终白色的对象无人引用 → GC 清除。</li>
</ol>
<ul>
<li>这个过程循环往复，直到堆中只剩黑色对象。<br>这种方式<strong>可以让 GC 和应用线程同时工作，减少停顿时间</strong>，在 CMS 和 G1 收集器里都用了它。</li>
</ul>
<h3 id="三色标记中可能出现漏标问题和多标问题"><a href="#三色标记中可能出现漏标问题和多标问题" class="headerlink" title="三色标记中可能出现漏标问题和多标问题"></a>三色标记中可能出现漏标问题和多标问题</h3><ul>
<li>漏标问题，就是说一个对象本来应该是黑色存活对象，但是没有被正确的标记上，导致被错误的垃圾回收掉了。</li>
<li>多标：就是这个对象原本应该被回收掉的白色对象，但是被错误的标记成了黑色的存活对象。从而导致这个对象没有被GC回收掉。<ul>
<li>多标的话，会产生<strong>浮动垃圾</strong>，这个问题一般都不太需要解决，因为这种垃圾一般都不会太多，另外在下一次GC的时候也都能被回收掉。</li>
</ul>
</li>
</ul>
<p>漏标问题解决方法：<br>具体的解决方式，在CMS和G1中也不太一样。<strong>CMS采用的是增量更新方案，G1则采用的是原始快照的方案。</strong></p>
<h2 id="Java-中的-young-GC、old-GC、full-GC-和-mixed-GC-的区别是什么？"><a href="#Java-中的-young-GC、old-GC、full-GC-和-mixed-GC-的区别是什么？" class="headerlink" title="Java 中的 young GC、old GC、full GC 和 mixed GC 的区别是什么？"></a>Java 中的 young GC、old GC、full GC 和 mixed GC 的区别是什么？</h2><p>Java 中的 GC 根据回收范围不同，可以分为 Young GC（Minor GC）、Old GC（Major GC）、Full GC 和 Mixed GC。<br>它们的区别主要在于：<strong>回收区域不同、触发条件不同、执行代价不同</strong>。</p>
<h3 id="Young-GC（年轻代垃圾回收）又称Minor-GC-或-YGC"><a href="#Young-GC（年轻代垃圾回收）又称Minor-GC-或-YGC" class="headerlink" title="Young GC（年轻代垃圾回收）又称Minor GC 或 YGC"></a>Young GC（年轻代垃圾回收）又称Minor GC 或 YGC</h3><ul>
<li>作用范围：<ul>
<li>只回收 新生代（Eden + Survivor0 + Survivor1） 的对象。</li>
</ul>
</li>
<li>触发条件：<ul>
<li>当 Eden 区空间满了，无法再为新对象分配内存时触发。</li>
</ul>
</li>
<li>执行特性：<ul>
<li>新生代对象“朝生夕死”，大多数是短命对象； </li>
<li>回收速度快，采用复制算法（Copying GC）；</li>
<li>回收频率高但耗时短。</li>
</ul>
</li>
</ul>
<p><strong>一句话总结：Young GC 就像清理临时文件，清得勤但快。</strong></p>
<h3 id="Old-GC（老年代垃圾回收）又称Major-GC-或-OGC"><a href="#Old-GC（老年代垃圾回收）又称Major-GC-或-OGC" class="headerlink" title="Old GC（老年代垃圾回收）又称Major GC 或 OGC"></a>Old GC（老年代垃圾回收）又称Major GC 或 OGC</h3><ul>
<li>作用范围：<ul>
<li>只回收 老年代（Old Generation）。</li>
</ul>
</li>
<li>触发条件：<ul>
<li>老年代空间不足；</li>
<li>或新生代晋升的对象太多，挤爆老年代。</li>
</ul>
</li>
<li>执行特性：<ul>
<li>对象存活时间长，数量多；</li>
<li>通常使用 标记-清除（Mark-Sweep）或标记-整理（Mark-Compact）算法；</li>
<li>执行频率低，但时间更长。</li>
</ul>
</li>
</ul>
<p><strong>一句话总结：Old GC 是大扫除，执行慢，但必要时得做</strong>。</p>
<p>Full GC（全堆垃圾回收）</p>
<ul>
<li>作用范围：<ul>
<li>同时回收 新生代 + 老年代 + 方法区（Metaspace）。</li>
</ul>
</li>
<li>触发条件：<ul>
<li>老年代空间不足，且 old GC 后仍无法释放足够内存；</li>
<li>永久代或者元空间不足；</li>
<li>手动调用 System.gc()；</li>
<li>年轻代晋升到老年代失败。</li>
</ul>
</li>
<li>执行特性：<ul>
<li>会暂停所有应用线程（Stop-The-World）；</li>
<li>耗时最长，对系统性能影响最大；</li>
<li>通常需要尽量避免。<br><strong>一句话总结：Full GC 是“系统级停机维护”，代价最高，非不得已别触发。</strong></li>
</ul>
</li>
</ul>
<h3 id="Mixed-GC（混合垃圾回收）"><a href="#Mixed-GC（混合垃圾回收）" class="headerlink" title="Mixed GC（混合垃圾回收）"></a>Mixed GC（混合垃圾回收）</h3><ul>
<li>出现版本：<ul>
<li>仅存在于 G1（Garbage First）收集器 中。</li>
</ul>
</li>
<li>作用范围：<ul>
<li>同时回收 整个新生代 + 部分老年代（不是全老年代）。</li>
</ul>
</li>
<li>触发条件：<ul>
<li>G1 在执行一定次数的 Young GC 后，老年代占用比例达到阈值（默认约 45%）时触发。</li>
<li>执行特性：</li>
<li>回收效率高；</li>
<li>通过选取“回收收益高的 Region”进行混合回收；</li>
<li>可控制停顿时间，减少 全堆垃圾回收 频率。</li>
</ul>
</li>
</ul>
<p><strong>一句话总结：Mixed GC 是 G1 的“智能混合回收”，在性能与停顿之间做平衡。</strong></p>
<h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h3><div class="table-container">
<table>
<thead>
<tr>
<th>GC 类型</th>
<th>回收范围</th>
<th>触发条件</th>
<th>执行频率</th>
<th>影响程度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Young GC</strong></td>
<td>新生代</td>
<td>Eden 区满</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td><strong>Old GC</strong></td>
<td>老年代</td>
<td>老年代满 / 晋升太多</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td><strong>Full GC</strong></td>
<td>新生代 + 老年代 + 元空间</td>
<td>堆内存或元空间不足 / System.gc()</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>Mixed GC</strong></td>
<td>新生代 + 部分老年代（G1）</td>
<td>G1 老年代占用率超阈值</td>
<td>中</td>
<td>中偏低</td>
</tr>
</tbody>
</table>
</div>
<h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>Java 的 GC 主要分四种：</p>
<ul>
<li>Young GC 回收新生代，触发快、耗时短；</li>
<li>Old GC 回收老年代，频率低但耗时长；</li>
<li>Full GC 是全堆回收，最耗时，一般要尽量避免；</li>
<li>Mixed GC 是 G1 独有的，它会同时回收新生代和部分老年代，在性能和停顿时间之间取得平衡。</li>
</ul>
<h2 id="什么条件会触发-Java-的-young-GC？"><a href="#什么条件会触发-Java-的-young-GC？" class="headerlink" title="什么条件会触发 Java 的 young GC？"></a>什么条件会触发 Java 的 young GC？</h2><ul>
<li>当 Eden 区空间满了</li>
<li>无法再为新对象分配内存时</li>
<li>部分垃圾回收器在Full GC之前先youngGC</li>
</ul>
<h2 id="什么情况下会触发-Java-的-Full-GC？"><a href="#什么情况下会触发-Java-的-Full-GC？" class="headerlink" title="什么情况下会触发 Java 的 Full GC？"></a>什么情况下会触发 Java 的 Full GC？</h2><ul>
<li>老年代空间不足，且 old GC 后仍无法释放足够内存；</li>
<li>永久代或者元空间不足；</li>
<li>手动调用 System.gc()；</li>
<li>年轻代晋升到老年代失败。</li>
</ul>
<h2 id="什么是-Java-的-PLAB？"><a href="#什么是-Java-的-PLAB？" class="headerlink" title="什么是 Java 的 PLAB？"></a>什么是 Java 的 PLAB？</h2><p>PLAB <strong>是 JVM 在垃圾回收时的一种优化机制</strong>，主要<strong>用在对象从新生代晋升到老年代的过程中</strong>。<br><strong>GC 是多线程执行的，为了避免多个线程同时去申请老年代空间而竞争，JVM 给每个 GC 线程分配了一块本地缓冲区，也就是 PLAB。</strong><br><strong>线程在晋升对象时直接在自己的 PLAB 中分配，速度更快，也避免了锁冲突。</strong></p>
<h3 id="TLAB-vs-PLAB"><a href="#TLAB-vs-PLAB" class="headerlink" title="TLAB vs PLAB"></a>TLAB vs PLAB</h3><p>简单来说，<strong>TLAB 是运行时线程分配对象的缓冲区，加快对象创建。</strong>，<strong>PLAB 是 GC 时晋升对象的缓冲区，加快垃圾回收。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比项</th>
<th><strong>TLAB</strong></th>
<th><strong>PLAB</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>所属阶段</td>
<td>正常运行时</td>
<td>垃圾回收时</td>
</tr>
<tr>
<td>使用线程</td>
<td>应用线程（App Thread）</td>
<td>GC 工作线程</td>
</tr>
<tr>
<td>分配区域</td>
<td>新生代（Eden 区）</td>
<td>老年代（Old Generation）</td>
</tr>
<tr>
<td>作用目标</td>
<td>加速普通对象的创建</td>
<td>加速对象晋升的分配</td>
</tr>
<tr>
<td>优化点</td>
<td>避免线程同步</td>
<td>避免 GC 线程竞争</td>
</tr>
</tbody>
</table>
</div>
<h2 id="JVM-垃圾回收时产生的-concurrent-mode-failure-的原因是什么？"><a href="#JVM-垃圾回收时产生的-concurrent-mode-failure-的原因是什么？" class="headerlink" title="JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？"></a>JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？</h2><p>Concurrent Mode Failure（并发模式失败） 是<strong>在使用 CMS 垃圾回收器 时的一种失败现象</strong>，<br><strong>它表示 CMS 在并发回收阶段没来得及回收出足够的老年代空间</strong>，<br><strong>导致新对象或晋升对象无法分配，从而 退化为 Full GC</strong>，造成明显的性能抖动。</p>
<p>可以总结为一句话：</p>
<ul>
<li>“CMS 回收太慢，程序分配太快，老年代撑不住了。”</li>
</ul>
<p>更细地说主要有以下几类情况：</p>
<ol>
<li>老年代空间不足</li>
</ol>
<ul>
<li>当 CMS 正在并发回收时，如果老年代中没有足够的可用空间分配新对象或晋升对象，就会触发 concurrent mode failure。</li>
</ul>
<ol>
<li>对象晋升过快（晋升风暴）</li>
</ol>
<ul>
<li>年轻代晋升对象太多、太频繁，老年代来不及回收，空间被迅速吃光。</li>
</ul>
<ol>
<li>长生命周期对象过多</li>
</ol>
<ul>
<li>应用中存在大量长期存活的对象（缓存、连接池等），占满老年代，回收压力持续存在。</li>
</ul>
<ol>
<li>CMS 触发太晚</li>
</ol>
<ul>
<li>CMS 默认在老年代使用率达到约 92% 才启动（由参数XX:CMSInitiatingOccupancyFraction 控制），启动太迟可能回收不及，从而失败。</li>
</ul>
<ol>
<li>参数配置不合理 / 碎片过多</li>
</ol>
<ul>
<li>老年代空间碎片化严重（CMS 是标记-清除算法），可用内存虽多但无法连续分配大对象。</li>
</ul>
<h3 id="CMS-的工作原理简述"><a href="#CMS-的工作原理简述" class="headerlink" title="CMS 的工作原理简述"></a>CMS 的工作原理简述</h3><p>CMS 的工作流程分为四个阶段：</p>
<ol>
<li>初始标记（Initial Mark）：标记与 GC Roots 直接关联的对象。</li>
<li>并发标记（Concurrent Mark）：和应用线程并行，标记可达对象。</li>
<li>重新标记（Remark）：修正上一步漏标或错标的对象。</li>
<li><p>并发清除（Concurrent Sweep）：清理垃圾对象空间，与应用线程并发执行。</p>
<p>在并发清除阶段应用线程仍在运行，如果这时分配需求过高或清理不及时，就容易触发 concurrent mode failure。</p>
</li>
</ol>
<h3 id="常见的优化措施"><a href="#常见的优化措施" class="headerlink" title="常见的优化措施"></a>常见的优化措施</h3><ol>
<li>提早触发 CMS 回收</li>
</ol>
<ul>
<li>通过降低参数 -XX:CMSInitiatingOccupancyFraction（例如 70），</li>
<li>让 CMS 更早开始回收，留出充足的缓冲时间。</li>
</ul>
<ol>
<li>增加老年代空间</li>
</ol>
<ul>
<li>通过调大 -Xmx 或调整 -XX:NewRatio，为老年代分配更多空间。</li>
</ul>
<ol>
<li>减少晋升压力</li>
</ol>
<ul>
<li>调大年轻代空间（减少对象晋升频率）；</li>
<li>优化对象生命周期，减少短命对象进入老年代。</li>
</ul>
<ol>
<li>降低碎片影响</li>
</ol>
<ul>
<li>开启 -XX:+UseCMSCompactAtFullCollection，在 Full GC 时整理碎片；</li>
<li>或使用更现代的收集器（如 G1）。</li>
</ul>
<ol>
<li>监控与调优</li>
</ol>
<ul>
<li>通过 jstat -gcutil、-XX:+PrintGCDetails 等参数观察 CMS 触发频率和老年代使用情况。</li>
</ul>
<h3 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h3><p>Concurrent Mode Failure 是在<strong>使用 CMS 垃圾回收器时，老年代在并发回收阶段来不及回收出足够的空间</strong>，<strong>导致新对象或晋升对象无法分配，只能退化执行 Full GC 的情况</strong>。</p>
<ul>
<li>常见原因包括<strong>老年代空间太小、晋升太快、CMS 触发太晚或内存碎片严重</strong>。</li>
<li>优化可以通过<strong>提前触发 CMS、加大老年代空间、减少晋升频率或开启内存压缩</strong>来避免。</li>
</ul>
<h2 id="为什么-Java-中-CMS-垃圾收集器在发生-Concurrent-Mode-Failure-时的-Full-GC-是单线程的？"><a href="#为什么-Java-中-CMS-垃圾收集器在发生-Concurrent-Mode-Failure-时的-Full-GC-是单线程的？" class="headerlink" title="为什么 Java 中 CMS 垃圾收集器在发生 Concurrent Mode Failure 时的 Full GC 是单线程的？"></a>为什么 Java 中 CMS 垃圾收集器在发生 Concurrent Mode Failure 时的 Full GC 是单线程的？</h2><p>因为 CMS 在设计上<strong>只负责并发回收老年代</strong>，<strong>它的备用 Full GC 是由 Serial Old 收集器 执行的</strong>。<br>Serial Old 是单线程的，所以当 CMS 发生 Concurrent Mode Failure 时，JVM 会退化到单线程 Full GC。<br>这主要是历史原因：<strong>CMS 最初是为低延迟设计的，不追求并行性能</strong>，而后来开发资源又转向了 G1，因此没有为 CMS 的 Full GC 实现多线程版本。</p>
<h2 id="为什么-Java-中某些新生代和老年代的垃圾收集器不能组合使用？比如-ParNew-和-Parallel-Old"><a href="#为什么-Java-中某些新生代和老年代的垃圾收集器不能组合使用？比如-ParNew-和-Parallel-Old" class="headerlink" title="为什么 Java 中某些新生代和老年代的垃圾收集器不能组合使用？比如 ParNew 和 Parallel Old"></a>为什么 Java 中某些新生代和老年代的垃圾收集器不能组合使用？比如 ParNew 和 Parallel Old</h2><p><strong>不同的 GC 不能随意组合，是因为它们的底层框架和设计目标不同</strong>。<br>比如 ParNew 属于老的 GC 框架，而 Parallel Old 属于新的 Parallel 框架，<br>两者的数据结构、线程模型和内存管理逻辑都不兼容。</p>
<ul>
<li>就像汽车组装，ParNew 是日系引擎接口，Parallel Old 是美系变速箱接口，<br>连接口规格不同，插上去也跑不了。</li>
</ul>
<p>ParNew 只能和 CMS 或 Serial Old 搭配，而 Parallel Scavenge 只能和 Parallel Old 一起用。<br><strong>强行组合不仅会性能下降，还可能导致内存布局和晋升逻辑出错</strong>。</p>
<h2 id="JVM-新生代垃圾回收如何避免全堆扫描？"><a href="#JVM-新生代垃圾回收如何避免全堆扫描？" class="headerlink" title="JVM 新生代垃圾回收如何避免全堆扫描？"></a>JVM 新生代垃圾回收如何避免全堆扫描？</h2><p>新生代 GC 之所以不会“误删”被老年代引用的新生代对象，<br>是因为 JVM 使用了 <strong>写屏障</strong>（Write Barrier） + <strong>卡表</strong>（Card Table） 两个机制来跟踪这种引用关系。<br><strong>这样在 Minor GC 时，只需扫描标记过的“脏卡”，而不是整个老年代。</strong></p>
<h3 id="为什么会有“跨代引用”问题？"><a href="#为什么会有“跨代引用”问题？" class="headerlink" title="为什么会有“跨代引用”问题？"></a>为什么会有“跨代引用”问题？</h3><p>当 JVM 做 Minor GC（回收新生代）时，只扫描新生代对象。但如果有一个<strong>老年代对象 A 引用了新生代对象 B</strong>，而 GC 只扫描新生代范围，就可能<strong>误以为 B 没被引用，错误回收</strong>。</p>
<h3 id="解决方案：卡表（Card-Table）-写屏障（Write-Barrier）"><a href="#解决方案：卡表（Card-Table）-写屏障（Write-Barrier）" class="headerlink" title="解决方案：卡表（Card Table）+ 写屏障（Write Barrier）"></a>解决方案：卡表（Card Table）+ 写屏障（Write Barrier）</h3><p>JVM 为了解决这个问题，引入了两个关键机制</p>
<ol>
<li>写屏障（Write Barrier）</li>
</ol>
<ul>
<li>是在“引用写入操作”时触发的一段特殊逻辑。</li>
<li>当老年代对象要引用一个新生代对象时，写屏障机制会自动记录这次跨代引用。</li>
<li>类似 Spring AOP 的“切面”，在赋值语句时自动插入监控逻辑。<br>例如：</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">oldObj.field</span> = youngObj<span class="comment">; </span></span><br></pre></td></tr></table></figure>
<p>执行这行代码时，写屏障会被触发，<br>告诉 JVM：“兄弟，这个老年代对象引用了一个新生代对象。”</p>
<ol>
<li>卡表机制（Card Table）</li>
</ol>
<ul>
<li>JVM 将老年代的内存划分成许多小区域（称为卡页，Card）， 每个卡页一般对应 <strong>512 字节</strong>。</li>
<li><p>当某个卡页内的对象引用了新生代对象，JVM 会把该卡页对应的卡表项标记为“<strong>脏卡</strong>（Dirty Card）”。</p>
<p>所以：</p>
</li>
<li>“卡表”其实是一个字节数组；</li>
<li>0 表示“干净”（没跨代引用），非 0 表示“脏”（存在跨代引用）。</li>
</ul>
<h3 id="Minor-GC-时的工作流程"><a href="#Minor-GC-时的工作流程" class="headerlink" title="Minor GC 时的工作流程"></a>Minor GC 时的工作流程</h3><p>当触发 Minor GC 时：</p>
<ol>
<li>扫描卡表，找到所有标记为“脏卡”的老年代区域。</li>
<li>只扫描这些脏卡中的对象，检查是否引用了新生代对象。</li>
<li>把这些被引用的新生代对象标记为存活对象，<br>确保它们不会被错误回收。</li>
</ol>
<p>因此：</p>
<blockquote>
<p>JVM 不需要扫描整个老年代，只需关注少量脏卡，大大提高了 GC 效率，同时避免了“误删对象”的风险。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>机制</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>写屏障</strong></td>
<td>拦截引用写操作，检测跨代引用发生的时刻</td>
</tr>
<tr>
<td><strong>卡表</strong></td>
<td>记录老年代哪些内存区域存在跨代引用</td>
</tr>
<tr>
<td><strong>Minor GC 时扫描脏卡</strong></td>
<td>保证被老年代引用的新生代对象不会被错误回收</td>
</tr>
</tbody>
</table>
</div>
<p>优点：</p>
<ul>
<li>避免全堆扫描</li>
<li>减少 GC 停顿时间</li>
<li>确保引用正确性<h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3>新生代 GC 之所以不会误删被老年代引用的对象，是因为 JVM 在对象赋值时会触发 <strong>写屏障</strong>机制，自动记录老年代引用新生代的情况。</li>
</ul>
<p>JVM 会把这些内存区域在 <strong>卡表</strong> 中标记为‘脏卡’，下次 Minor GC 时只需扫描这些脏卡，就能找到所有跨代引用，避免错误回收并提高效率。</p>
<h2 id="Java-的-CMS-垃圾回收器和-G1-垃圾回收器在记忆集的维护上有什么不同？"><a href="#Java-的-CMS-垃圾回收器和-G1-垃圾回收器在记忆集的维护上有什么不同？" class="headerlink" title="Java 的 CMS 垃圾回收器和 G1 垃圾回收器在记忆集的维护上有什么不同？"></a>Java 的 CMS 垃圾回收器和 G1 垃圾回收器在记忆集的维护上有什么不同？</h2><p>CMS 和 G1 都需要记住跨代引用（防止老年代引用新生代对象被误回收），<br>但它们在“记忆集”的实现方式和粒度上完全不同：</p>
<ul>
<li><strong>CMS 用卡表（Card Table）实现，粒度粗，结构简单</strong>；</li>
<li><strong>G1 用记忆集（Remembered Set, RSet），粒度细到 Region 级，更精确但更复杂</strong>。</li>
</ul>
<p>CMS 的记忆集机制<br>CMS 使用 卡表（Card Table） 来记录跨代引用，<br>其实它就是一种“简化版的记忆集”，实现思路如下：</p>
<ol>
<li><p>原理：<br>当老年代对象引用了新生代对象时，触发 <strong>写屏障</strong>（Write Barrier）。<br>JVM 会将老年代中对应的卡页（Card）标记为“<strong>脏卡</strong>（Dirty Card）”。</p>
</li>
<li><p>数据结构：</p>
</li>
</ol>
<ul>
<li>每个卡页对应约 512 字节的老年代内存；</li>
<li>卡表中一个字节标记一个卡页是否含有跨代引用。</li>
</ul>
<ol>
<li><p>GC 时行为：<br>Minor GC 扫描卡表中被标记为“脏卡”的部分，<br>只扫描这些区域，而不是整个老年代，从而避免全堆扫描。</p>
</li>
<li><p>特点总结：<br>优点 实现简单，开销小；<br>缺点 粒度粗，一张“脏卡”里可能包含多个无关对象，精度不高。</p>
</li>
</ol>
<h3 id="G1-的记忆集机制"><a href="#G1-的记忆集机制" class="headerlink" title="G1 的记忆集机制"></a>G1 的记忆集机制</h3><p>G1 的设计更复杂，它采用真正意义上的<strong>多层记忆集</strong>（Remembered Set, RSet）。</p>
<ol>
<li>原理：</li>
</ol>
<ul>
<li>G1 把堆划分为多个小的 Region（一般几 MB）。</li>
<li>每个 Region 都有自己的记忆集，用来记录“哪些其他 Region 中的对象引用了我”。</li>
<li>当某个对象在不同 Region 间发生引用时，写屏障会更新对应的 RSet。</li>
</ul>
<ol>
<li>数据结构：</li>
</ol>
<ul>
<li>每个 RSet 里维护的是一组“卡表条目（Card Table Entry）”，它指向引用该 Region 的其他 Region 的具体卡页。</li>
<li>这是一种“Region 粒度”的多对多关系映射。</li>
</ul>
<ol>
<li>GC 时行为：</li>
</ol>
<ul>
<li>G1 只扫描与目标 Region 的 RSet 有关联的 Region，这样可以做到非常精确的增量式回收。</li>
</ul>
<ol>
<li>特点总结：</li>
</ol>
<ul>
<li>优点： <ul>
<li>粒度细、定位精准；</li>
<li>支持 Region 之间的并发回收；</li>
</ul>
</li>
<li>缺点：<ul>
<li>维护成本更高，内存与 CPU 开销更大。</li>
</ul>
</li>
</ul>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th>对比项</th>
<th>CMS</th>
<th>G1</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>实现形式</strong></td>
<td>卡表（Card Table）</td>
<td>记忆集（Remembered Set）</td>
</tr>
<tr>
<td><strong>跟踪范围</strong></td>
<td>老年代 → 新生代</td>
<td>Region ↔ Region（任意方向）</td>
</tr>
<tr>
<td><strong>粒度</strong></td>
<td>卡页（约 512B）</td>
<td>Region 内卡页级（更细）</td>
</tr>
<tr>
<td><strong>精确度</strong></td>
<td>粗略</td>
<td>精确</td>
</tr>
<tr>
<td><strong>维护开销</strong></td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>优势</strong></td>
<td>简单、低延迟</td>
<td>可控回收、分区化并发效率高</td>
</tr>
</tbody>
</table>
</div>
<h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>CMS 用卡表来实现记忆集，只记录老年代引用新生代的情况，通过写屏障把对应区域标记为‘脏卡’，GC 时扫描这些脏卡即可，结构简单但粒度较粗。<br>而 G1 的记忆集是以 Region 为粒度的，每个 Region 都维护一个自己的 RSet，记录哪些其他 Region 有引用它，粒度更细更精准，<br>适合 G1 这种分区化、并发回收的设计，只是维护成本更高。</p>
<h2 id="为什么-G1-垃圾收集器不维护年轻代到老年代的记忆集？"><a href="#为什么-G1-垃圾收集器不维护年轻代到老年代的记忆集？" class="headerlink" title="为什么 G1 垃圾收集器不维护年轻代到老年代的记忆集？"></a>为什么 G1 垃圾收集器不维护年轻代到老年代的记忆集？</h2><p>G1 不维护年轻代到老年代的记忆集，因为年轻代每次 GC 都是整区回收，<br>所有年轻代 Region 都会被扫描，根本不需要额外记录年轻代引用老年代的对象。<br>而老年代引用年轻代的情况才需要维护记忆集，否则年轻代 GC 时可能误删对象。</p>
<h2 id="Java-中的-CMS-和-G1-垃圾收集器如何维持并发的正确性？"><a href="#Java-中的-CMS-和-G1-垃圾收集器如何维持并发的正确性？" class="headerlink" title="Java 中的 CMS 和 G1 垃圾收集器如何维持并发的正确性？"></a>Java 中的 CMS 和 G1 垃圾收集器如何维持并发的正确性？</h2><p>CMS 和 G1 在并发标记时都会遇到“引用关系可能变化”的问题，<br>为保证标记的正确性：</p>
<ul>
<li><strong>CMS 使用「增量更新（Incremental Update）」机制</strong>；</li>
<li><strong>G1 使用「SATB（Snapshot At The Beginning）」机制</strong>。</li>
</ul>
<p>这两种机制的目的，都是在“应用线程继续运行、对象引用不断变化”时，<br>仍能保证 GC 标记结果的正确性。</p>
<h3 id="为什么需要并发正确性机制？"><a href="#为什么需要并发正确性机制？" class="headerlink" title="为什么需要并发正确性机制？"></a>为什么需要并发正确性机制？</h3><p>在并发标记阶段，应用线程（Mutator）仍在运行，<br>对象之间的引用关系会持续变化，比如：</p>
<ul>
<li>对象 A 删除了对 B 的引用</li>
<li>对象 C 新增了对 D 的引用</li>
</ul>
<p>这会导致标记线程和应用线程看到的“对象图”不一致，<br>如果不处理，就可能：</p>
<ul>
<li>误删仍被引用的对象（错误回收）</li>
<li>或保留已经无用的对象（浮动垃圾）</li>
</ul>
<p>所以 CMS 和 G1 都必须用特殊机制来记录这些变化。</p>
<h3 id="CMS：增量更新（Incremental-Update）"><a href="#CMS：增量更新（Incremental-Update）" class="headerlink" title="CMS：增量更新（Incremental Update）"></a>CMS：增量更新（Incremental Update）</h3><h4 id="机制原理"><a href="#机制原理" class="headerlink" title="机制原理"></a>机制原理</h4><p>当一个“已标记的黑色对象”向“未标记的白色对象”建立引用时，CMS 会立刻把这个白色对象标记成灰色（表示后续还要扫描它）。</p>
<p>这相当于：</p>
<ul>
<li>“黑指白时，不让它漏标”<h4 id="核心思想：补充新增的引用关系。也就是说，只要有新的引用产生，CMS-会通过写屏障立即更新标记状态。"><a href="#核心思想：补充新增的引用关系。也就是说，只要有新的引用产生，CMS-会通过写屏障立即更新标记状态。" class="headerlink" title="核心思想：补充新增的引用关系。也就是说，只要有新的引用产生，CMS 会通过写屏障立即更新标记状态。"></a>核心思想：补充新增的引用关系。<strong>也就是说，只要有新的引用产生，CMS 会通过写屏障立即更新标记状态。</strong></h4></li>
</ul>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul>
<li>CMS 使用 写屏障（Write Barrier） 拦截引用更新操作。</li>
<li>当检测到黑对象引用白对象时，就把白对象加入重新扫描队列。</li>
<li>在 remark 阶段会重新检查这些对象，确保不会漏标。</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点 能保证标记阶段的完整性；</li>
<li>缺点 但容易产生“浮动垃圾”——即在 GC 标记后新创建但未扫描的对象。</li>
</ul>
<h3 id="G1：SATB（Snapshot-At-The-Beginning）"><a href="#G1：SATB（Snapshot-At-The-Beginning）" class="headerlink" title="G1：SATB（Snapshot At The Beginning）"></a>G1：SATB（Snapshot At The Beginning）</h3><h4 id="机制原理-1"><a href="#机制原理-1" class="headerlink" title="机制原理"></a>机制原理</h4><p>SATB（Snapshot At The Beginning） 的思路是：<br>“在并发标记开始那一刻，拍下堆的快照，哪怕引用关系之后改变，也以快照时的状态为准。”<br>也就是说：</p>
<ul>
<li>标记开始时认为“当时存活的对象都是活的”；</li>
<li>即使之后引用被删除，也不会立刻当作垃圾。</li>
</ul>
<h4 id="核心思想：保留旧的引用关系，防止误删对象。"><a href="#核心思想：保留旧的引用关系，防止误删对象。" class="headerlink" title="核心思想：保留旧的引用关系，防止误删对象。"></a>核心思想：保留旧的引用关系，防止误删对象。</h4><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul>
<li>在写屏障中，当对象引用被删除时，会把“被删除的旧引用”记录下来。</li>
<li>后续 GC 扫描这些记录，确保被删除的对象仍被视为“存活”。</li>
</ul>
<h4 id="G1-的实现细节"><a href="#G1-的实现细节" class="headerlink" title="G1 的实现细节"></a>G1 的实现细节</h4><p>G1 在每个 Region 里维护两个指针：</p>
<ul>
<li>prevTAMS（上一次标记的起点）</li>
<li>nextTAMS（本次标记的起点）</li>
</ul>
<p>在标记开始时，prevTAMS 到 Top 之间的对象被认为是存活的，<br>相当于捕捉了堆的一份“快照”。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点标记更精确，避免误删；</li>
<li>缺点可能暂时保留一些“实际上已无用”的对象（也就是浮动垃圾）。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比项</th>
<th>CMS（增量更新）</th>
<th>G1（SATB）</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心思路</td>
<td>更新新引用关系</td>
<td>保留旧引用关系</td>
</tr>
<tr>
<td>触发时机</td>
<td>新引用创建时</td>
<td>引用删除时</td>
</tr>
<tr>
<td>写屏障作用</td>
<td>记录新增引用</td>
<td>记录被删除引用</td>
</tr>
<tr>
<td>优点</td>
<td>不漏标新引用</td>
<td>不误删旧对象</td>
</tr>
<tr>
<td>缺点</td>
<td>会留下浮动垃圾</td>
<td>也会保留浮动垃圾，但控制更好</td>
</tr>
</tbody>
</table>
</div>
<h3 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h3><p>在并发标记阶段，对象引用关系可能不断变化。<br>为了保证标记结果的正确性，<strong>CMS 用的是 增量更新</strong>，它会在引用新增时立刻标记新对象，防止漏标。<br>而 <strong>G1 用的是 SATB</strong>（快照在最初），在标记开始时拍个快照，认为当时活着的对象都是存活的，<br>即使引用被删除也不会误删。<br>简单来说，<strong>CMS 记录新增的引用，G1 记录被删的引用</strong>，<br><strong>两者目的都是保证并发标记阶段的正确性</strong>。</p>
<h2 id="Java-G1-相对于-CMS-有哪些进步的地方"><a href="#Java-G1-相对于-CMS-有哪些进步的地方" class="headerlink" title="Java G1 相对于 CMS 有哪些进步的地方?"></a>Java G1 相对于 CMS 有哪些进步的地方?</h2><p>G1 是 CMS 的“下一代垃圾回收器”，<br>它在 <strong>内存布局、回收算法、停顿控制</strong> 和 <strong>大对象优化</strong> 等方面都有明显进步，<br>目标是：更可控、更高效、更适合多核和大内存环境。</p>
<h3 id="从内存管理机制来看"><a href="#从内存管理机制来看" class="headerlink" title="从内存管理机制来看"></a>从内存管理机制来看</h3><p>CMS 是传统的“分区制”，而 G1 把堆打碎成很多小块（Region），动态调整哪些块回收哪些保留，内存使用更灵活，也更容易做并行优化。</p>
<h3 id="从回收算法来看"><a href="#从回收算法来看" class="headerlink" title="从回收算法来看"></a>从回收算法来看</h3><p>CMS <strong>标记-清除算法</strong> 清完垃圾后容易留下碎片，就像地板上扫完灰但还乱，<br>而 G1 <strong>标记-整理算法</strong> 会顺便把对象挤一挤，像打包箱子那样整齐，所以几乎不会出现碎片问题。</p>
<h3 id="从停顿时间来看"><a href="#从停顿时间来看" class="headerlink" title="从停顿时间来看"></a>从停顿时间来看</h3><p><strong>CMS 的停顿不可控</strong>，有时候很短，有时候就卡几秒。<br>而 G1 可以<strong>设定“停顿目标”</strong>，GC 会自动规划任务，尽量让回收既高效又平稳。</p>
<h3 id="从大对象与跨代引用优化来看"><a href="#从大对象与跨代引用优化来看" class="headerlink" title="从大对象与跨代引用优化来看"></a>从大对象与跨代引用优化来看</h3><p>CMS 对大对象处理比较笨，可能直接塞进老年代，<strong>容易导致 老年代空间紧张、甚至 Full GC</strong><br>而 G1 是<strong>分块管理</strong>的，<strong>大对象单独放一个 Region</strong>，管理起来更灵活，不容易挤爆老年代。</p>
<h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><ul>
<li><strong>G1 不仅负责老年代，也能回收新生代</strong>，是一个 统一的垃圾收集器（不像 CMS 还要配合 ParNew）。</li>
<li>G1 的<strong>并行和并发设计更现代</strong>，在多核、大内存服务器上表现更稳定。</li>
</ul>
<h3 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h3><p>G1 相比 CMS 的最大进步有四点：<br>第一，G1 把堆划成很多小块（Region），内存更灵活不易碎片化；<br>第二，CMS 用标记清除，而 G1 用标记整理，几乎不会有内存碎片；<br>第三，G1 可以设置停顿目标，GC 会自动调度，用户体验更平滑；<br>最后，G1 对大对象和跨代引用处理更智能，也不需要搭配 ParNew，整体更适合大内存和多核环境。</p>
<h2 id="什么是-Java-中的-logging-write-barrier？"><a href="#什么是-Java-中的-logging-write-barrier？" class="headerlink" title="什么是 Java 中的 logging write barrier？"></a>什么是 Java 中的 logging write barrier？</h2><p>Logging Write Barrier（日志写屏障） 是一种<strong>在 Java GC 中用来记录对象引用变化的写屏障机制</strong>。<br><strong>它能让垃圾收集器在应用线程继续运行时，依然感知哪些引用被修改或删除，<br>从而保证并发标记的正确性</strong>（特别是 G1 的 SATB 和记忆集维护）。</p>
<h3 id="先理解写屏障（Write-Barrier）"><a href="#先理解写屏障（Write-Barrier）" class="headerlink" title="先理解写屏障（Write Barrier）"></a>先理解写屏障（Write Barrier）</h3><p>写屏障其实是一段 <strong>由 JVM 在引用赋值操作时插入的小代码</strong>。<br>当对象的引用字段发生改变（比如 a.field = b）时，写屏障就会被触发，执行一些额外逻辑。</p>
<p>常见的两种类型是：</p>
<ul>
<li><strong>Pre-Write Barrier（写前屏障）：在引用被覆盖前触发（记录旧值）</strong></li>
<li><strong>Post-Write Barrier（写后屏障）：在引用写入后触发（记录新值）</strong></li>
</ul>
<h3 id="Logging-Write-Barrier-是什么"><a href="#Logging-Write-Barrier-是什么" class="headerlink" title="Logging Write Barrier 是什么"></a>Logging Write Barrier 是什么</h3><p>Logging Write Barrier 本质上属于 “Post-Write Barrier” 的一种实现形式。<br>它的核心思想是：</p>
<ul>
<li>“<strong>每当引用变化时，把变化记录（log）下来，而不是立刻处理</strong>。”</li>
</ul>
<p>这些变化日志（log entries）会被放入专用队列（如 SATBMarkQueue），<br>等到合适时机再由 GC 线程批量处理。</p>
<p>这样做的好处是：</p>
<ul>
<li>避免频繁打断应用线程</li>
<li>降低同步开销</li>
<li>保证并发标记时引用关系的正确性</li>
</ul>
<h3 id="Logging-Write-Barrier-的工作原理"><a href="#Logging-Write-Barrier-的工作原理" class="headerlink" title="Logging Write Barrier 的工作原理"></a>Logging Write Barrier 的工作原理</h3><p>在 G1 的 SATB 模式下，当对象引用被覆盖（即旧引用要被删掉）时：</p>
<ol>
<li>触发写前屏障（Pre-Write Barrier）</li>
<li>JVM 检查当前是否处于并发标记阶段（mark_queue_set().is_active()）</li>
<li>如果是，就把“旧引用对象”入队到 SATBMarkQueue</li>
<li>后续由 GC 线程异步扫描这些队列，确保被删除的对象仍能被正确标记</li>
</ol>
<p>换句话说：<br><strong>即使应用线程删除了某个对象引用，GC 也能通过日志知道“它原来是被引用过的”，<br>从而避免错误回收。</strong></p>
<h3 id="在不同-GC-中的用途"><a href="#在不同-GC-中的用途" class="headerlink" title="在不同 GC 中的用途"></a>在不同 GC 中的用途</h3><div class="table-container">
<table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>写屏障用途</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>G1 GC</strong></td>
<td>记录对象引用变化，用于 <strong>SATB 快照机制</strong> 和 <strong>记忆集（RSet）更新</strong></td>
<td>确保跨 Region 引用关系正确</td>
</tr>
<tr>
<td><strong>CMS GC</strong></td>
<td>用于 <strong>增量更新（Incremental Update）</strong>，标记新增引用</td>
<td>防止漏标新引用对象</td>
</tr>
<tr>
<td><strong>Shenandoah / ZGC</strong></td>
<td>用于 <strong>读屏障（Read Barrier）</strong>，配合指针重定位</td>
<td>保证并发压缩时引用有效性</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Logging-Write-Barrier-的意义"><a href="#Logging-Write-Barrier-的意义" class="headerlink" title="Logging Write Barrier 的意义"></a>Logging Write Barrier 的意义</h3><p>它解决了两个问题：<br>1.GC 与应用线程并发运行时，如何同步引用变化？</p>
<ul>
<li>通过日志异步记录，避免扫描全堆。</li>
</ul>
<p>2.如何保证标记结果不出错？</p>
<ul>
<li>在 SATB 中保存旧引用，防止误删对象；<br>在增量更新中记录新引用，防止漏标对象。</li>
</ul>
<p>小结<br>Logging Write Barrier 是 GC 用来记录对象引用变化的机制，它会在引用写入时，把旧或新的引用信息记录下来放入日志队列，比如 SATBMarkQueue。<br>这样垃圾收集器在并发标记时，就能知道哪些对象引用被修改或删除，避免误删或漏标。<br><strong>像 G1 用它来维护 SATB 快照和记忆集，CMS 用它来做增量更新</strong>，既保证正确性，又减少同步开销。</p>
<h2 id="Java-的-G1-垃圾回收流程是怎样的？"><a href="#Java-的-G1-垃圾回收流程是怎样的？" class="headerlink" title="Java 的 G1 垃圾回收流程是怎样的？"></a>Java 的 G1 垃圾回收流程是怎样的？</h2><p>G1 垃圾回收器的整个流程可以分为两个大阶段：</p>
<ul>
<li>并发标记（Concurrent Marking）</li>
<li>对象拷贝与整理（Evacuation）<br>其中标记阶段又包含 <strong>初始标记 → 并发标记 → 最终标记 → 清理</strong>四个子步骤。</li>
</ul>
<p><strong>简单说，G1 先“找出该回收的垃圾”，再“把存活的对象搬走”，实现高效、可控的 GC</strong>。</p>
<h3 id="一、初始标记（Initial-Mark，STW）"><a href="#一、初始标记（Initial-Mark，STW）" class="headerlink" title="一、初始标记（Initial Mark，STW）"></a>一、初始标记（Initial Mark，STW）</h3><ul>
<li>首先会暂停所有用户线程（Stop The World）；</li>
<li>从 GC Root 出发，标记第一层直接可达的对象；</li>
<li>因为只标记少量对象，停顿时间非常短；</li>
<li>这一步属于 SATB（Snapshot At The Beginning） 的起点阶段。</li>
</ul>
<p>这一步就像拍一张快照，先把根对象能直接触及的那一层标记起来，速度很快，停顿也短。</p>
<h3 id="二、并发标记（Concurrent-Mark）"><a href="#二、并发标记（Concurrent-Mark）" class="headerlink" title="二、并发标记（Concurrent Mark）"></a>二、并发标记（Concurrent Mark）</h3><ul>
<li>与应用线程并发进行，不会完全停顿；</li>
<li>从前面标记到的灰色对象开始，继续追踪并标记它们引用到的对象；</li>
<li>会标记出整个堆中所有可达的对象；</li>
<li>由于应用线程此时还在运行，引用关系可能变化，G1 使用 SATB 技术 保证正确性（在标记开始时拍快照，后续引用变化用日志记录）。</li>
</ul>
<p>这阶段是“大规模扫图”，GC 和程序一起跑；如果应用代码在过程中修改了引用，G1 用 SATB 机制保证不会漏标对象。</p>
<h3 id="三、最终标记（Final-Remark，STW）"><a href="#三、最终标记（Final-Remark，STW）" class="headerlink" title="三、最终标记（Final Remark，STW）"></a>三、最终标记（Final Remark，STW）</h3><ul>
<li>再次短暂停顿应用线程；</li>
<li>扫描并处理并发阶段残留的 SATB 队列，</li>
<li>把新创建或删除的引用关系补充上；</li>
<li>确保标记阶段的结果完全准确。</li>
</ul>
<p>这一步相当于“复核”，GC 停下来把并发阶段遗留的小细节都补上，保证标记结果没问题。</p>
<h3 id="四、清理阶段（Cleanup，STW）"><a href="#四、清理阶段（Cleanup，STW）" class="headerlink" title="四、清理阶段（Cleanup，STW）"></a>四、清理阶段（Cleanup，STW）</h3><ul>
<li>检查各个 Region 的存活对象数量；</li>
<li>对没有存活对象的 Region 进行释放；</li>
<li>更新统计信息，为下一次回收做准备。</li>
</ul>
<p>就像打扫完屋子后清点一下哪些房间是空的，空房间就直接回收释放。</p>
<h3 id="五、对象拷贝-转移（Evacuation，STW）"><a href="#五、对象拷贝-转移（Evacuation，STW）" class="headerlink" title="五、对象拷贝 / 转移（Evacuation，STW）"></a>五、对象拷贝 / 转移（Evacuation，STW）</h3><ul>
<li>这一阶段也是 STW（停顿的）；</li>
<li>根据前面标记的结果，挑选一批“垃圾多、收益高”的 Region 作为回收目标集合（CSet，Collection Set）；</li>
<li>把这些 Region 里的存活对象复制到新的 Region 中；</li>
<li>同时更新引用关系和卡表（Card Table）；</li>
<li>完成后释放原有的 Region 空间。</li>
</ul>
<p>最后这一步是“搬家”——GC 把活着的对象搬到新区域，把旧区的垃圾一起清掉，这样堆空间就重新整理干净了。</p>
<h3 id="G1-的并发调优参数"><a href="#G1-的并发调优参数" class="headerlink" title="G1 的并发调优参数"></a>G1 的并发调优参数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:MaxGCPauseMillis=&lt;n&gt;</code></td>
<td>设置最大停顿时间目标（比如 200ms），G1 会自动调整每次回收的工作量来满足这个目标。</td>
</tr>
<tr>
<td><code>-XX:G1HeapRegionSize=&lt;size&gt;</code></td>
<td>控制 Region 大小（默认 1MB~32MB），影响内存划分与扫描效率。</td>
</tr>
<tr>
<td><code>-XX:InitiatingHeapOccupancyPercent=&lt;p&gt;</code></td>
<td>设置老年代触发并发标记的阈值（默认 45%）。</td>
</tr>
<tr>
<td><code>-XX:G1MixedGCCountTarget=&lt;n&gt;</code></td>
<td>控制 mixed GC 阶段一次混合回收多少个 Region。</td>
</tr>
</tbody>
</table>
</div>
<p>小结：<br>G1 的垃圾回收过程分为五步：<br>先是 初始标记，快速标记 GC Roots 可达对象；<br>然后 并发标记，和程序一起运行，用 SATB 机制保证引用变化不出错；<br>接着 最终标记，补上并发阶段遗漏的部分；<br>之后是 清理，回收空 Region；<br>最后是 对象转移，把活的对象搬到新区域、释放旧区空间。<br>整个过程既保证高吞吐量，又能控制停顿时间，非常适合大内存场景。</p>
<blockquote>
<p>SATB<br>SATB 主要为了解决并发标记阶段可能产生的对象引用变化问题，SATB 宁可多标也不漏标，多标的大不了下一轮 GC 时再被回收（浮动垃圾），但漏标却会影响到程序的正常运行。</p>
</blockquote>
<h2 id="Java-的-CMS-垃圾回收流程是怎样的？"><a href="#Java-的-CMS-垃圾回收流程是怎样的？" class="headerlink" title="Java 的 CMS 垃圾回收流程是怎样的？"></a>Java 的 CMS 垃圾回收流程是怎样的？</h2><p>CMS 是一种以<strong>最小化停顿时间为目标</strong>的<strong>老年代垃圾收集器</strong>。<br>它通过“并发标记”和“并发清理”来减少 STW（Stop The World）时间，<br>整体流程可以分为 <strong>初始标记 → 并发标记 → 预清理 → 重新标记 → 并发清理 → 并发重置</strong> 六个主要阶段</p>
<h3 id="一、初始标记（Initial-Mark，STW）-1"><a href="#一、初始标记（Initial-Mark，STW）-1" class="headerlink" title="一、初始标记（Initial Mark，STW）"></a>一、初始标记（Initial Mark，STW）</h3><ul>
<li>暂停所有用户线程（STW）。</li>
<li>从 GC Roots 出发，标记直接可达的对象。</li>
<li>只扫描第一层引用，因此非常快。</li>
</ul>
<p>初始标记就是先从 GC Roots 开始，快速打个底，把能直接关联到的对象标记出来，这一步虽然是停顿的，但时间很短。</p>
<h3 id="二、并发标记（Concurrent-Marking）"><a href="#二、并发标记（Concurrent-Marking）" class="headerlink" title="二、并发标记（Concurrent Marking）"></a>二、并发标记（Concurrent Marking）</h3><ul>
<li>与应用线程并发执行，不会完全停顿。</li>
<li>从初始标记的对象开始，遍历整个对象图，找出所有可达对象。</li>
<li>这一阶段的标记可能会受应用线程继续运行影响（对象引用可能被修改）。</li>
</ul>
<p>接下来进入并发标记阶段，GC 和应用线程一起跑，后台遍历堆里的对象图，把所有活对象都标出来。</p>
<h3 id="三、预清理（Concurrent-Preclean）"><a href="#三、预清理（Concurrent-Preclean）" class="headerlink" title="三、预清理（Concurrent Preclean）"></a>三、预清理（Concurrent Preclean）</h3><ul>
<li>仍是并发执行。</li>
<li>CMS 会处理在并发标记过程中，由于用户线程继续运行而新产生的引用变化。</li>
<li>这一步的目的是尽量减少后续“重新标记”阶段的工作量。</li>
</ul>
<p>因为标记过程中程序还在运行，可能又改了些引用，所以这一步会提前把新变化的引用先处理掉，让后面停顿更短。</p>
<h3 id="四、重新标记（Remark，STW）"><a href="#四、重新标记（Remark，STW）" class="headerlink" title="四、重新标记（Remark，STW）"></a>四、重新标记（Remark，STW）</h3><ul>
<li>再次进入停顿（STW）。</li>
<li>扫描并修正并发阶段遗漏的标记信息，确保标记结果的准确性。</li>
<li>通常会用 多线程并行 来加速。</li>
</ul>
<p>这一步是“复核”阶段，GC 再次短暂停顿应用线程，把之前并发标记时漏掉的活对象都补标一下。</p>
<h3 id="五、并发清理（Concurrent-Sweep）"><a href="#五、并发清理（Concurrent-Sweep）" class="headerlink" title="五、并发清理（Concurrent Sweep）"></a>五、并发清理（Concurrent Sweep）</h3><ul>
<li>开始真正清理垃圾对象，释放内存。</li>
<li>清理过程与用户线程并发执行，不会停顿。</li>
<li>因为 CMS 使用的是 标记-清除算法，所以不会做内存整理（会留下碎片）。</li>
</ul>
<p>然后进入并发清理阶段，GC 在后台把标记为垃圾的对象清掉，这时程序照常运行。<br>不过 CMS 只是清理不会压缩，所以容易产生碎片。</p>
<h3 id="六、并发重置（Concurrent-Reset）"><a href="#六、并发重置（Concurrent-Reset）" class="headerlink" title="六、并发重置（Concurrent Reset）"></a>六、并发重置（Concurrent Reset）</h3><ul>
<li>清理完成后，CMS 会重置内部数据结构（如标记位图），为下一次 GC 做准备。</li>
<li>同样是并发执行，不会造成停顿。</li>
</ul>
<p>最后一步是收尾，清空标记信息，重置状态，为下一次回收做好准备。</p>
<h3 id="CMS-的两个典型问题"><a href="#CMS-的两个典型问题" class="headerlink" title="CMS 的两个典型问题"></a>CMS 的两个典型问题</h3><ul>
<li>浮动垃圾（Floating Garbage）<ul>
<li>因为清理阶段是并发的，可能在清理期间又产生新的垃圾，这部分垃圾只能留到下次回收。 </li>
</ul>
</li>
<li>内存碎片（Fragmentation）<ul>
<li>CMS 使用“标记-清除算法”，不会整理堆空间，久而久之会产生碎片，导致Promotion Failed（对象无法晋升到老年代）。</li>
</ul>
</li>
</ul>
<p>优化方式：</p>
<ul>
<li>-XX:+UseCMSCompactAtFullCollection → Full GC 时进行压缩。</li>
<li>-XX:CMSFullGCsBeforeCompaction → 每多少次 Full GC 后压缩一次。</li>
<li>-XX:CMSInitiatingOccupancyFraction=<n> → 调低触发阈值，提前启动回收，防止碎片过多。</li>
</ul>
<p> CMS 的缺点主要有两个：一个是清理时程序还在跑，会有浮动垃圾；<br>另一个是因为不压缩内存，会产生碎片，可能导致晋升失败。<br>可以通过参数配置，让它在 Full GC 时顺便压缩一下来解决。</p>
<h3 id="小结：-2"><a href="#小结：-2" class="headerlink" title="小结："></a>小结：</h3><p>CMS 的垃圾回收过程分六步：<br>先是<strong>初始标记，快速标记 GC Roots 直接关联的对象</strong>；<br>接着<strong>并发标记，后台扫描整个对象图</strong>；<br>然后<strong>预清理，处理新引用</strong>；<br>再进入<strong>重新标记阶段，短暂停顿修正遗漏</strong>；<br>接着<strong>并发清理，真正删除垃圾对象</strong>；<br>最后<strong>并发重置，为下次 GC 做准备</strong>。<br>它的优点是<strong>停顿时间短</strong>，缺点是容易有<strong>浮动垃圾</strong>和<strong>内存碎片</strong></p>
<h2 id="你了解-Java-的-ZGC（Z-Garbage-Collector）吗？"><a href="#你了解-Java-的-ZGC（Z-Garbage-Collector）吗？" class="headerlink" title="你了解 Java 的 ZGC（Z Garbage Collector）吗？"></a>你了解 Java 的 ZGC（Z Garbage Collector）吗？</h2><p>ZGC（Z Garbage Collector）是 Java 中的一款<strong>超低延迟、高可扩展性垃圾收集器</strong>，<br>它的目标是：<strong>让 GC 停顿时间不超过 1ms，无论堆多大</strong>（可达 16TB）。<br>非常适合<strong>对响应时间要求极高的场景</strong>，比如金融交易系统、在线游戏、实时计算等。</p>
<h3 id="ZGC-的核心特性"><a href="#ZGC-的核心特性" class="headerlink" title="ZGC 的核心特性"></a>ZGC 的核心特性</h3><ul>
<li>低延迟：每次 Stop-The-World 停顿都小于 1ms。</li>
<li>高并发：几乎所有阶段都是与应用线程并发执行。</li>
<li>超大堆支持：支持从几百 MB 到 16TB 的堆内存。</li>
<li>无碎片问题：采用并发压缩算法，回收后堆空间整洁无碎片。</li>
</ul>
<p>ZGC 的目标就是让 GC 延迟小到可以忽略不计，不管你堆是 1G 还是 10TB，<br>都能在 1ms 内完成暂停，非常适合对延迟特别敏感的系统。</p>
<h3 id="ZGC-的核心原理"><a href="#ZGC-的核心原理" class="headerlink" title="ZGC 的核心原理"></a>ZGC 的核心原理</h3><p>ZGC 之所以能实现低延迟，关键在于两项技术：</p>
<ol>
<li>读屏障（Load Barrier）</li>
</ol>
<ul>
<li>当线程读取对象引用时，会经过一层“读屏障”检查。</li>
<li>如果发现对象被移动过，屏障逻辑会自动更新引用地址，确保读到的是最新位置的对象。</li>
</ul>
<ol>
<li>着色指针（Colored Pointers）</li>
</ol>
<ul>
<li>ZGC 在 64 位指针中嵌入标记位（颜色位），用来记录对象的状态（是否标记、是否转移、是否重映射）。</li>
<li>不再需要额外的标记表，提高效率。</li>
</ul>
<p>G1 回收时对象转移必须停顿所有线程，而 ZGC 用<strong>读屏障 + 着色指针</strong>，让对象转移也能并发执行，这就是它能做到“超低停顿”的秘密。</p>
<h3 id="ZGC流程"><a href="#ZGC流程" class="headerlink" title="ZGC流程"></a>ZGC流程</h3><p>ZGC 的垃圾回收流程分为多个阶段，几乎都是并发完成的。</p>
<ol>
<li>初始标记（STW）</li>
</ol>
<ul>
<li>标记 GC Roots（线程栈、静态变量等）直接可达对象。</li>
<li>时间极短（&lt;1ms）。</li>
</ul>
<ol>
<li>并发标记</li>
</ol>
<ul>
<li>遍历对象图，标记所有可达对象。</li>
<li>用户线程在访问对象时如果发现对象未标记，会“顺带”帮忙标记（协同机制）。</li>
</ul>
<ol>
<li>并发处理</li>
</ol>
<ul>
<li>决定哪些内存页（ZPage）需要转移。</li>
<li>建立“旧地址 → 新地址”的映射表。</li>
</ul>
<ol>
<li>转移阶段（开始 + 并发）</li>
</ol>
<ul>
<li>初始转移（STW）：转移 GC Roots 直接引用的对象。</li>
<li>并发转移：后台将其他对象复制到新内存页（ZPage），并更新映射关系。</li>
<li>用户线程访问对象时，会通过读屏障自动更新引用地址。</li>
</ul>
<ol>
<li><p>第二次 GC（补全未完成转移）<br>ZGC 使用“双标记位机制” （Marked0 / Marked1）<br>区分当前和上次 GC 状态，保证不会重复转移或漏转。</p>
</li>
<li><p>并发问题处理机制</p>
</li>
</ol>
<p>如果用户线程和 GC 线程同时尝试转移对象，ZGC 会通过映射表判断是否已存在转移结果，<br>若存在则放弃重复操作，避免冲突。</p>
<blockquote>
<p>ZGC 的流程可以概括为：<br>“标记活对象 → 建立映射关系 → 并发搬家 → 用户线程自动帮忙修正引用”。<br>整个过程几乎没有明显停顿。</p>
</blockquote>
<h3 id="ZGC与-G1-的区别"><a href="#ZGC与-G1-的区别" class="headerlink" title="ZGC与 G1 的区别"></a>ZGC与 G1 的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>对比点</th>
<th>G1 GC</th>
<th>ZGC</th>
</tr>
</thead>
<tbody>
<tr>
<td>转移过程</td>
<td>必须 STW（停顿）</td>
<td>可并发进行</td>
</tr>
<tr>
<td>屏障类型</td>
<td>写屏障（Write Barrier）</td>
<td>读屏障（Load Barrier）</td>
</tr>
<tr>
<td>碎片问题</td>
<td>可能有碎片</td>
<td>并发压缩，无碎片</td>
</tr>
<tr>
<td>停顿时间</td>
<td>10ms ~ 100ms</td>
<td>&lt; 1ms</td>
</tr>
<tr>
<td>堆大小支持</td>
<td>几 GB ~ 几十 GB</td>
<td>可达 16TB</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>简单说，G1 是“低延迟”，ZGC 是“超低延迟”。<br>它几乎把 GC 的所有步骤都做成并发了。</p>
</blockquote>
<h3 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h3><p>ZGC 是 Java 的一款超低延迟垃圾回收器，能做到 GC 停顿不超过 1ms，支持从几百 MB 到 16TB 的堆内存。</p>
<p>它的核心是读屏障（Load Barrier）和着色指针（Colored Pointer），让对象转移过程也能并发执行，不用再 STW。</p>
<p>整个流程包括初始标记、并发标记、并发处理、并发转移和重映射，几乎全程并发，特别适合实时、高响应系统。</p>
<h2 id="JVM-垃圾回收调优的主要目标是什么？"><a href="#JVM-垃圾回收调优的主要目标是什么？" class="headerlink" title="JVM 垃圾回收调优的主要目标是什么？"></a>JVM 垃圾回收调优的主要目标是什么？</h2><p>JVM 垃圾回收调优的主要目标有两个：</p>
<ul>
<li>最短暂停时间（低延迟）</li>
<li>高吞吐量（高性能）</li>
</ul>
<p>这两者是 GC 调优的核心方向，但通常是此消彼长的，需要根据业务场景权衡取舍。</p>
<ul>
<li>最短暂停时间的目标就是<strong>让 GC 尽快干完活，别拖慢应用</strong>。比如我们希望每次 GC 只暂停几毫秒，让用户几乎感受不到卡顿。</li>
<li>高吞吐量的目标不是让 GC 更快结束，而是<strong>尽量少触发 GC</strong>，让 CPU 更多地去跑业务代码，而不是在收垃圾。</li>
</ul>
<h3 id="两者的权衡"><a href="#两者的权衡" class="headerlink" title="两者的权衡"></a>两者的权衡</h3><ul>
<li>低延迟和高吞吐量往往难以兼得。<ul>
<li>比如：每次 GC 停顿 100ms、每秒 GC 5 次（响应好但频繁）；</li>
<li>或者每次 GC 停顿 200ms、每秒 GC 2 次（吞吐高但延迟更大）。</li>
</ul>
</li>
<li>所以，调优时必须明确你的应用更关注响应速度还是处理效率。</li>
</ul>
<blockquote>
<p>调优的时候要先想清楚目标。<strong>如果你是支付系统，就追求低延迟</strong>；<br><strong>如果是离线计算任务，就追求高吞吐</strong>。两者很难两全。</p>
</blockquote>
<h3 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h3><p>JVM 垃圾回收调优的主要目标是两个：<br>一是减少 GC 停顿时间，提升系统的响应能力；<br>二是提高吞吐量，让程序在单位时间内处理更多业务。<br>一般低延迟系统更关注停顿时间，高并发或计算密集型系统更看重吞吐量，<br>两者通常需要平衡取舍。</p>
<h2 id="如何对-Java-的垃圾回收进行调优？"><a href="#如何对-Java-的垃圾回收进行调优？" class="headerlink" title="如何对 Java 的垃圾回收进行调优？"></a>如何对 Java 的垃圾回收进行调优？</h2><p>Java 垃圾回收调优的核心目标是：</p>
<p><strong>尽量让对象在年轻代就被回收掉，减少进入老年代的对象，从而降低 Full GC 的频率。</strong></p>
<ul>
<li>目标一：<strong>降低 Full GC 次数</strong>，Full GC 的停顿时间长，对性能影响大。所以调优的关键是让尽可能多的对象在年轻代就被清理掉，让老年代空间保持充足，避免频繁 Full GC。</li>
<li>目标二：<strong>提升年轻代回收效率</strong>，尽量让短命对象“生得快，死得也快”，在 Young GC 阶段直接回收，<strong>减少对象晋升到老年代的概率</strong>。</li>
</ul>
<h3 id="常见调优方法"><a href="#常见调优方法" class="headerlink" title="常见调优方法"></a>常见调优方法</h3><p>1.分析 GC 日志，找到瓶颈点<br>先别急着调参数，要先看 Young GC 和 Full GC 的触发频率、停顿时间、晋升速率、老年代使用量等关键指标。</p>
<p>2.调整年轻代与老年代的比例</p>
<ul>
<li>如果发现对象频繁晋升到老年代，就说明年轻代太小。</li>
<li>可以适当增大 -Xmn 或者调大 SurvivorRatio，让更多对象在年轻代被回收。<br>3.优化 Survivor 区大小</li>
<li>Survivor 太小会导致对象提前晋升老年代。</li>
<li>适当增大 Survivor 区，让短命对象在新生代多活几次 GC，被及时清理掉。</li>
</ul>
<p>4.避免频繁的 System.gc() 调用<br>有些第三方库可能会主动调用 System.gc() 导致频繁 Full GC。<br>可以通过参数 -XX:+DisableExplicitGC 禁用显式 GC 调用。</p>
<blockquote>
<p>具体调优要看 GC 日志，<br>如果 Young GC 后老年代涨得快，就说明晋升太多，要调大新生代或 Survivor；<br>如果频繁 Full GC，就要看看是不是老年代空间太小或者有内存泄漏。<br>另外别忘了关掉那些偷偷调 System.gc() 的库。</p>
</blockquote>
<p>举例</p>
<ul>
<li><p>情况一：Full GC 太频繁</p>
<ul>
<li>增大老年代空间；</li>
<li>优化 Survivor，减少晋升。</li>
</ul>
</li>
<li><p>情况二：Young GC 频繁且耗时</p>
<ul>
<li>调整 Eden 与 Survivor 比例；</li>
<li>调大新生代，让对象更集中回收。</li>
</ul>
</li>
<li><p>情况三：内存碎片或老年代膨胀</p>
<ul>
<li>考虑使用 G1 或 ZGC 这类具备压缩能力的收集器。</li>
</ul>
</li>
</ul>
<h3 id="小结-15"><a href="#小结-15" class="headerlink" title="小结"></a>小结</h3><p>调优垃圾回收的关键是让短命对象尽快在年轻代被清理掉，<br>减少老年代的压力，从而降低 Full GC 的频率。<br>一般我们会通过分析 GC 日志，观察 Young GC 和 Full GC 的次数、<br>晋升速率和内存占用，再去调整年轻代、Survivor 大小或者禁用 System.gc()。<br>核心思路其实就一句话：<strong>尽量在新生代把对象回收掉</strong>。</p>
<h2 id="常用的-JVM-配置参数有哪些？"><a href="#常用的-JVM-配置参数有哪些？" class="headerlink" title="常用的 JVM 配置参数有哪些？"></a>常用的 JVM 配置参数有哪些？</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>参数</th>
<th>作用说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内存相关参数</strong></td>
<td><code>-Xms</code></td>
<td>设置初始堆内存大小</td>
<td><code>-Xms512m</code></td>
</tr>
<tr>
<td></td>
<td><code>-Xmx</code></td>
<td>设置最大堆内存大小</td>
<td><code>-Xmx2g</code></td>
</tr>
<tr>
<td></td>
<td><code>-Xmn</code></td>
<td>设置年轻代大小</td>
<td><code>-Xmn512m</code></td>
</tr>
<tr>
<td></td>
<td><code>-XX:NewRatio</code></td>
<td>设置年轻代与老年代的比例</td>
<td><code>-XX:NewRatio=2</code></td>
</tr>
<tr>
<td></td>
<td><code>-XX:SurvivorRatio</code></td>
<td>设置 Eden 区与 Survivor 区比例</td>
<td><code>-XX:SurvivorRatio=8</code></td>
</tr>
<tr>
<td></td>
<td><code>-XX:MetaspaceSize</code></td>
<td>元空间初始大小</td>
<td><code>-XX:MetaspaceSize=128m</code></td>
</tr>
<tr>
<td></td>
<td><code>-XX:MaxMetaspaceSize</code></td>
<td>元空间最大大小</td>
<td><code>-XX:MaxMetaspaceSize=512m</code></td>
</tr>
<tr>
<td><strong>GC 相关参数</strong></td>
<td><code>-XX:+UseG1GC</code></td>
<td>启用 G1 垃圾收集器</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:+UseConcMarkSweepGC</code></td>
<td>启用 CMS 垃圾收集器</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:+UseParallelGC</code></td>
<td>启用并行 GC</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:MaxGCPauseMillis</code></td>
<td>设置最大 GC 停顿时间目标</td>
<td><code>-XX:MaxGCPauseMillis=200</code></td>
</tr>
<tr>
<td></td>
<td><code>-XX:GCTimeRatio</code></td>
<td>设置 GC 时间与应用执行时间的比例</td>
<td><code>-XX:GCTimeRatio=9</code></td>
</tr>
<tr>
<td><strong>性能调优参数</strong></td>
<td><code>-XX:+AggressiveOpts</code></td>
<td>开启积极优化选项</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:+UseCompressedOops</code></td>
<td>启用压缩指针（节省内存）</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:+DoEscapeAnalysis</code></td>
<td>启用逃逸分析</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:+UseBiasedLocking</code></td>
<td>启用偏向锁，减少锁竞争</td>
<td>—</td>
</tr>
<tr>
<td><strong>调试与监控参数</strong></td>
<td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td>
<td>OOM 时生成堆转储文件</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:HeapDumpPath</code></td>
<td>指定堆转储文件路径</td>
<td><code>-XX:HeapDumpPath=/tmp/heap.hprof</code></td>
</tr>
<tr>
<td></td>
<td><code>-XX:+PrintGC</code></td>
<td>打印 GC 基本信息</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:+PrintGCDetails</code></td>
<td>打印详细 GC 日志</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-Xloggc</code></td>
<td>设置 GC 日志输出路径</td>
<td><code>-Xloggc:/var/log/gc.log</code></td>
</tr>
<tr>
<td><strong>其他常用参数</strong></td>
<td><code>-Dfile.encoding</code></td>
<td>设置文件编码格式</td>
<td><code>-Dfile.encoding=UTF-8</code></td>
</tr>
<tr>
<td></td>
<td><code>-server</code></td>
<td>启用服务器模式（默认在 64 位 JDK）</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-client</code></td>
<td>启用客户端模式</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td><code>-XX:MaxDirectMemorySize</code></td>
<td>设置直接内存大小（影响 NIO）</td>
<td><code>-XX:MaxDirectMemorySize=1g</code></td>
</tr>
</tbody>
</table>
</div>
<p>在实际项目中，常见的 JVM 启动配置一般会包含以下几类参数组合：<br>| 类型             | 常用配置                                                     |<br>| ———————— | —————————————————————————————— |<br>| <strong>基础内存设置</strong> | <code>-Xms1g -Xmx2g -Xmn512m</code>                                     |<br>| <strong>垃圾回收设置</strong> | <code>-XX:+UseG1GC -XX:MaxGCPauseMillis=200</code>                      |<br>| <strong>性能优化</strong>     | <code>-XX:+UseCompressedOops -XX:+DoEscapeAnalysis -XX:+UseBiasedLocking</code> |<br>| <strong>监控调试</strong>     | <code>-XX:+PrintGCDetails -Xloggc:/logs/gc.log -XX:+HeapDumpOnOutOfMemoryError</code> |<br>| <strong>其他常用项</strong>   | <code>-Dfile.encoding=UTF-8 -XX:MaxDirectMemorySize=512m</code>         |</p>
<blockquote>
<p>JVM 参数主要分五大类：<br>内存分配、GC 策略、性能优化、监控调试、系统配置。</p>
</blockquote>
<h2 id="你常用哪些工具来分析-JVM-性能？"><a href="#你常用哪些工具来分析-JVM-性能？" class="headerlink" title="你常用哪些工具来分析 JVM 性能？"></a>你常用哪些工具来分析 JVM 性能？</h2><p>分析 JVM 性能常用的工具主要分为五类：<br><strong>基础信息工具、内存与 GC 工具、线程分析工具、可视化工具、第三方监控分析工具</strong>。</p>
<h3 id="基础信息工具"><a href="#基础信息工具" class="headerlink" title="基础信息工具"></a>基础信息工具</h3><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>jps</strong></td>
<td>查看当前用户的 Java 进程，快速定位进程 PID。</td>
</tr>
<tr>
<td><strong>jinfo</strong></td>
<td>查看或修改 JVM 参数配置，适合排查参数设置问题。</td>
</tr>
</tbody>
</table>
</div>
<p>“我一般先用 jps 查进程号，再用 jinfo 看看 JVM 参数，比如堆大小、GC 策略这些。”</p>
<h3 id="内存与-GC-分析工具"><a href="#内存与-GC-分析工具" class="headerlink" title="内存与 GC 分析工具"></a>内存与 GC 分析工具</h3><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>jmap</strong></td>
<td>导出堆快照 dump 文件，或直接查看堆内对象分布情况。</td>
</tr>
<tr>
<td><strong>jstat</strong></td>
<td>实时监控 GC、类加载、编译和内存使用等运行时指标。</td>
</tr>
</tbody>
</table>
</div>
<p>“我常用 jstat 监控 GC 频率，看是否有 Full GC 过多的问题；<br>如果怀疑内存泄漏，就用 jmap dump 出堆文件，再用 MAT 分析。”</p>
<h3 id="线程和锁分析工具"><a href="#线程和锁分析工具" class="headerlink" title="线程和锁分析工具"></a>线程和锁分析工具</h3><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>jstack</strong></td>
<td>抓取线程堆栈信息，用来分析死锁、线程阻塞、高 CPU 占用等问题。</td>
</tr>
</tbody>
</table>
</div>
<p>“应用 CPU 飙高或者响应慢时，我会先 jstack 看看是不是线程死锁或者有线程在 spin。”</p>
<h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>jhat</strong></td>
<td>简单的堆快照分析工具（功能较弱，推荐用 MAT 或 VisualVM）。</td>
</tr>
<tr>
<td><strong>jconsole</strong></td>
<td>JDK 自带图形化监控工具，可查看内存、GC、线程和 CPU。</td>
</tr>
<tr>
<td><strong>VisualVM</strong></td>
<td>功能强大的可视化工具，支持实时监控、GC 统计、CPU 采样、dump 文件分析等。</td>
</tr>
</tbody>
</table>
</div>
<p>“我平时调优时喜欢用 VisualVM，能直观看到堆和 GC 的变化，还能采样分析 CPU。”</p>
<h3 id="第三方高级工具"><a href="#第三方高级工具" class="headerlink" title="第三方高级工具"></a>第三方高级工具</h3><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Arthas</strong></td>
<td>阿里开源的 Java 诊断神器，支持在线排查、查看类加载、监控方法调用和内存实时情况。</td>
</tr>
<tr>
<td><strong>MAT（Memory Analyzer Tool）</strong></td>
<td>深度分析堆转储文件，定位内存泄漏和大对象引用链。</td>
</tr>
</tbody>
</table>
</div>
<p>“如果是线上问题，我一般直接上 Arthas，远程 attach 进程实时看。<br>如果是内存泄漏，就导出 dump 文件用 MAT 深挖引用链。”</p>
<h3 id="常见问题与工具选择建议"><a href="#常见问题与工具选择建议" class="headerlink" title="常见问题与工具选择建议"></a>常见问题与工具选择建议</h3><div class="table-container">
<table>
<thead>
<tr>
<th>问题类型</th>
<th>推荐工具</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内存溢出（OOM）</strong></td>
<td><code>jmap</code> + <code>MAT</code></td>
</tr>
<tr>
<td><strong>内存泄漏</strong></td>
<td><code>jstat</code> + <code>jmap</code> + <code>MAT</code></td>
</tr>
<tr>
<td><strong>GC 频繁</strong></td>
<td><code>GC 日志</code> + <code>jstat</code></td>
</tr>
<tr>
<td><strong>线程死锁</strong></td>
<td><code>jstack</code></td>
</tr>
<tr>
<td><strong>CPU 飙高</strong></td>
<td><code>top</code> / <code>ps</code> + <code>jstack</code></td>
</tr>
<tr>
<td><strong>长期监控</strong></td>
<td><code>Prometheus</code> + <code>Grafana</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="小结-16"><a href="#小结-16" class="headerlink" title="小结"></a>小结</h3><p>我平时分析 JVM 性能问题主要分几类工具：<br>jps、jinfo 这种看基础信息的；<br>jmap、jstat 看内存和 GC；<br>jstack 查线程死锁或 CPU 问题；<br>可视化我用 VisualVM 或 jconsole；<br>线上排查就用 Arthas，离线分析用 MAT。<br>一般套路是：先 jps 定进程，再 jstat 看 GC，再根据问题用 jstack 或 jmap 定位。</p>
<h2 id="如何在-Java-中进行内存泄漏分析？"><a href="#如何在-Java-中进行内存泄漏分析？" class="headerlink" title="如何在 Java 中进行内存泄漏分析？"></a>如何在 Java 中进行内存泄漏分析？</h2><p>面试官：“你知道如何解决内存泄漏问题吗？”</p>
<p>答：内存泄漏其实是指在 Java 中，有些对象在用完之后，虽然不再需要，但是它们还是被某些地方引用着，导致垃圾回收器无法回收这些对象，最终可能会导致内存溢出。</p>
<p>解决这个问题的步骤一般包括几个方面：</p>
<ol>
<li><p>发现问题：</p>
<ul>
<li>首先，你可以通过监控内存的使用情况来发现问题。正常情况下，内存会随着程序的运行起伏，<br>Minor GC 后内存会回落，但如果你看到内存持续增长，手动执行 FULL GC 后内存依然不下降，那就有可能是内存泄漏了。</li>
</ul>
</li>
<li><p>诊断问题：</p>
<ul>
<li>一旦怀疑是内存泄漏，你可以生成堆内存快照。这可以通过 JVM 参数来自动做，像是加上<br>-XX: +HeapDumpOnOutOfMemoryError，这样如果发生 OOM 错误时就会自动生成一个堆快照文件。或者你可以手动导出，比如用 jmap 或者 <strong>Arthas</strong> 来获取内存快照，这样就能看到哪些对象还没被回收。</li>
</ul>
</li>
<li><p>定位问题：</p>
<ul>
<li>接着，你可以使用 <strong>MAT（Memory Analyzer Tool）</strong> 来分析这些堆快照，看看是不是某些对象占用了大量的内存，导致其他对象无法被回收。</li>
</ul>
</li>
<li><p>修复问题：</p>
<ul>
<li>修复的时候，首先要看看问题是出在哪。比如代码中如果有不必要的引用，可以手动清理；如果是并发问题，可能是因为设置的堆内存太小或者设计不当，这时候可以通过调整内存参数或优化设计来解决。</li>
</ul>
</li>
<li><p>工具的使用：</p>
<ul>
<li>常用的工具有 JDK 自带的 jps （查看进程）和 jmap （生成内存快照），以及第三方工具像 <strong>VisualVM</strong> 和 <strong>Arthas</strong>，它们都能帮助我们监控和分析内存使用情况。</li>
</ul>
</li>
</ol>
<p>总的来说，内存泄漏是一个比较常见的问题，但只要我们通过监控、生成堆快照并分析，能够及时发现并修复它。</p>
<h2 id="Java-里的对象在虚拟机里面是怎么存储的？"><a href="#Java-里的对象在虚拟机里面是怎么存储的？" class="headerlink" title="Java 里的对象在虚拟机里面是怎么存储的？"></a>Java 里的对象在虚拟机里面是怎么存储的？</h2><p>在 Java 中，对象是存放在 <strong>堆内存</strong> 中的，而对象在堆中的布局主要由三部分组成：<br><strong>对象头（Header）+ 实例数据（Instance Data）+ 对齐填充（Padding）</strong>。</p>
<h3 id="对象的整体结构"><a href="#对象的整体结构" class="headerlink" title="对象的整体结构"></a>对象的整体结构</h3><p>对象在内存中的基本组成如下：<br>| 组成部分                      | 说明                           | 示例                               |<br>| ——————————————- | ——————————————— | ————————————————— |<br>| <strong>对象头（Object Header）</strong>   | 存放对象的元数据和运行时信息   | Mark Word、Klass Pointer、数组长度 |<br>| <strong>实例数据（Instance Data）</strong> | 存放对象的实际字段（成员变量） | 如 <code>int id</code>、<code>String name</code>         |<br>| <strong>对齐填充（Padding）</strong>       | 用于保证 8 字节对齐的内存要求  | 根据对象大小自动补齐               |</p>
<h3 id="对象头（Header）详解"><a href="#对象头（Header）详解" class="headerlink" title="对象头（Header）详解"></a>对象头（Header）详解</h3><p>对象头是 JVM 用来描述对象自身信息的区域，主要包含三部分内容：</p>
<ol>
<li>Mark Word（标记字段）</li>
</ol>
<ul>
<li>存储对象运行时数据，比如：hashCode、GC 分代年龄、锁状态标志（无锁、偏向锁、轻量级锁、重量级锁）等。</li>
<li>是一个会随着对象状态变化的多功能字段。</li>
</ul>
<ol>
<li>Klass Pointer（类型指针）</li>
</ol>
<ul>
<li>指向对象所属类的元数据，用于确定该对象的类型。</li>
</ul>
<ol>
<li>数组长度（仅数组对象有）<ul>
<li>如果是数组对象，这里会额外存储数组长度信息。</li>
</ul>
</li>
</ol>
<blockquote>
<p>简单理解：“对象头其实就是对象的身份证，里面记着它的 hashCode、锁状态、GC 信息，还有它是哪种类创建的。”</p>
</blockquote>
<h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><ul>
<li>存储对象的实际字段数据，比如成员变量。</li>
<li>JVM 会根据字段类型和继承层次进行内存重排，让对象结构更加紧凑。</li>
</ul>
<blockquote>
<p>简单理解：“这一块就是真正保存业务数据的地方，比如一个 User 对象，它的 id、name 都在这里。”</p>
</blockquote>
<h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><ul>
<li>JVM 为了提高内存访问效率，要求对象大小是 8 字节的倍数。</li>
<li>如果对象实际大小不足，JVM 会自动添加填充字节。</li>
</ul>
<blockquote>
<p>简单理解：“对齐填充就像打补丁，为了让对象大小对齐到 8 字节边界。”</p>
</blockquote>
<p>存储位置</p>
<ul>
<li>普通对象：一般分配在<strong>堆</strong>（Heap）中。</li>
<li>年轻代（Young Generation）：新对象分配在 <strong>Eden</strong> 区，经过多次 GC 后可能晋升到老年代。</li>
<li>老年代（Old Generation）：<strong>存放生命周期较长的对象</strong>，比如缓存对象或静态实例。</li>
</ul>
<h3 id="Mark-Word-示例（64-位）"><a href="#Mark-Word-示例（64-位）" class="headerlink" title="Mark Word 示例（64 位）"></a>Mark Word 示例（64 位）</h3><div class="table-container">
<table>
<thead>
<tr>
<th>位数</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>54bit</td>
<td>哈希码（hashCode）/ GC 年龄 / 锁信息</td>
<td>动态变化字段</td>
</tr>
<tr>
<td>2bit</td>
<td>锁状态标志</td>
<td>00 无锁 / 01 偏向锁 / 10 轻量级锁 / 11 重量级锁</td>
</tr>
<tr>
<td>其他</td>
<td>线程 ID、GC 标志等</td>
<td>取决于锁类型</td>
</tr>
</tbody>
</table>
</div>
<p>“Mark Word 就像对象的‘运行日志’，JVM 会不断更新这里的锁状态和 GC 信息。”</p>
<h3 id="小结-17"><a href="#小结-17" class="headerlink" title="小结"></a>小结</h3><p>在 JVM 里，对象是存放在堆中的，它的内存结构主要分三块：<br>第一是对象头，里面有 Mark Word（存 hashCode、锁信息、GC 年龄等）和类指针；<br>第二是实例数据，也就是对象真正的字段内容；<br>第三是对齐填充，用来保证 8 字节对齐。<br>数组对象会多一项数组长度字段。整体来看，对象头就像身份证，实例数据是内容，而填充只是凑整。</p>
<p><img src="https://pic.code-nav.cn/mianshiya/question_picture/1942188251568476161/1GHPIgAF_0_mianshiya.png" alt="0.png" width="100%" /></p>
<h2 id="说说-Java-的执行流程"><a href="#说说-Java-的执行流程" class="headerlink" title="说说 Java 的执行流程?"></a>说说 Java 的执行流程?</h2><p>Java的执行流程：</p>
<ol>
<li>源代码：编写.java文件</li>
<li>编译：使用javac编译器生成.class字节码文件。</li>
<li>类加载：JVM的类加载器加载.class文件到内存中。</li>
<li>解释执行：JVM将字节码转为机器码执行。</li>
<li>JIT编译：JVM根据需要将热点代码编译为机器码。</li>
<li>运行：执行main方法中的逻辑。</li>
<li>垃圾回收：JVM管理内存，并回收不再使用的对象。</li>
<li>程序结束：main方法结束，JVM清理资源，推出程序。</li>
</ol>
<h2 id="线上-CPU-飙高如何排查？"><a href="#线上-CPU-飙高如何排查？" class="headerlink" title="线上 CPU 飙高如何排查？"></a>线上 CPU 飙高如何排查？</h2><blockquote>
<p>线上 CPU 飙高其实是一个非常常见、但排查流程非常固定的问题。我一般会按照 <strong>“定位进程 → 定位线程 → 定位代码 → 修复问题”</strong> 这套方法走。</p>
</blockquote>
<h4 id="①-定位哪个进程占用-CPU"><a href="#①-定位哪个进程占用-CPU" class="headerlink" title="① 定位哪个进程占用 CPU"></a><strong>① 定位哪个进程占用 CPU</strong></h4><p>第一步用：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">top</span></span><br></pre></td></tr></table></figure>
<p>看到哪个进程 CPU 最高，比如 Java 进程占了 180%+，就说明是应用本身的问题。</p>
<h4 id="②-定位哪个线程占用-CPU"><a href="#②-定位哪个线程占用-CPU" class="headerlink" title="② 定位哪个线程占用 CPU"></a><strong>② 定位哪个线程占用 CPU</strong></h4><p>继续用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp <span class="tag">&lt;<span class="name">进程ID</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>找到 CPU 占用最高的线程，比如线程号 4519。</p>
<p>然后将线程号转成 16 进制：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">printf</span> <span class="string">&quot;<span class="variable">%x</span>\n&quot;</span> <span class="number">4519</span></span><br></pre></td></tr></table></figure>
<h4 id="③-打印线程栈，定位到底是哪段代码造成的"><a href="#③-打印线程栈，定位到底是哪段代码造成的" class="headerlink" title="③ 打印线程栈，定位到底是哪段代码造成的"></a><strong>③ 打印线程栈，定位到底是哪段代码造成的</strong></h4><p>用 jstack 或 Arthas：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">jstack</span> &lt;pid&gt; | grep -A <span class="number">200</span> &lt;<span class="number">16</span>进制线程号&gt;</span><br></pre></td></tr></table></figure>
<p>再查看堆栈最顶层，看代码卡在哪个方法。</p>
<h4 id="④-修复-CPU-热点代码"><a href="#④-修复-CPU-热点代码" class="headerlink" title="④ 修复 CPU 热点代码"></a><strong>④ 修复 CPU 热点代码</strong></h4><ul>
<li><strong>把高频创建的对象提前到应用启动时初始化一次</strong><br>（如：Sequence、Validator）</li>
<li>避免不必要的反射、正则、序列号获取</li>
<li>检查是否有死循环、大量 JSON 解析、大对象创建等</li>
</ul>
<h3 id="小结-18"><a href="#小结-18" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>CPU 飙高我一般按固定流程排查：先找进程、再找线程、最后定位到具体代码。</p>
</blockquote>
<ol>
<li><p><strong>定位高 CPU 进程</strong><br>用 <code>top</code> 看是哪个进程占满 CPU。</p>
</li>
<li><p><strong>定位高 CPU 线程</strong><br><code>top -Hp &lt;pid&gt;</code> 找出最耗 CPU 的线程号。</p>
</li>
<li><p><strong>定位具体代码</strong><br>把线程号转成 16 进制：<br><code>printf &quot;%x\n&quot; &lt;tid&gt;</code><br>再用：<br><code>jstack &lt;pid&gt; | grep -A 200 &lt;16进制tid&gt;</code><br>或 Arthas <code>thread -n 3</code>，直接找到热点方法。</p>
</li>
<li><p><strong>根据堆栈优化代码</strong><br>多数根因都是：频繁创建对象、正则/反射过多、DB/IO 阻塞、死循环等。</p>
</li>
</ol>
<p><strong>一句话总结：</strong></p>
<blockquote>
<p><strong>top 找进程 → top -Hp 找线程 → jstack/Arthas 找热点方法 → 优化代码</strong>，这是排查 CPU 飙高最标准、最高效的流程。</p>
</blockquote>
<h2 id="怎么分析-JVM-当前的内存占用情况？OOM-后怎么分析？"><a href="#怎么分析-JVM-当前的内存占用情况？OOM-后怎么分析？" class="headerlink" title="怎么分析 JVM 当前的内存占用情况？OOM 后怎么分析？"></a>怎么分析 JVM 当前的内存占用情况？OOM 后怎么分析？</h2><h2 id="怎么分析-JVM-当前的内存占用情况？OOM-之后怎么分析？"><a href="#怎么分析-JVM-当前的内存占用情况？OOM-之后怎么分析？" class="headerlink" title="怎么分析 JVM 当前的内存占用情况？OOM 之后怎么分析？"></a>怎么分析 JVM 当前的内存占用情况？OOM 之后怎么分析？</h2><blockquote>
<p>我一般会分两步：<strong>先看实时内存情况</strong>，再分析 <strong>OOM dump 文件</strong> 去定位根因。</p>
</blockquote>
<h3 id="一、如何分析-JVM-当前的内存占用情况？"><a href="#一、如何分析-JVM-当前的内存占用情况？" class="headerlink" title="一、如何分析 JVM 当前的内存占用情况？"></a>一、如何分析 JVM 当前的内存占用情况？</h3><p>主要用自带工具：</p>
<h4 id="1）jstat-——-看-JVM-内存实时情况"><a href="#1）jstat-——-看-JVM-内存实时情况" class="headerlink" title="1）jstat —— 看 JVM 内存实时情况"></a><strong>1）jstat —— 看 JVM 内存实时情况</strong></h4><p><code>jstat -gc &lt;pid&gt;</code><br>可以看到：</p>
<ul>
<li>Eden、Survivor、Old 区的使用情况</li>
<li>GC 次数和耗时<br>方便判断是不是某块内存持续上涨、GC 频繁等问题。</li>
</ul>
<h4 id="2）jmap-——-查看堆的详细结构"><a href="#2）jmap-——-查看堆的详细结构" class="headerlink" title="2）jmap —— 查看堆的详细结构"></a><strong>2）jmap —— 查看堆的详细结构</strong></h4><p><code>jmap -heap &lt;pid&gt;</code> 查看：</p>
<ul>
<li>堆大小配置</li>
<li>当前各区占用情况</li>
<li>GC 类别</li>
</ul>
<p><code>jmap -histo &lt;pid&gt;</code> 可以看到：</p>
<ul>
<li>哪些类实例最多、占用最大<br>用来判断是否有往堆里塞大量对象的风险。</li>
</ul>
<h3 id="二、OOM-后怎么分析？"><a href="#二、OOM-后怎么分析？" class="headerlink" title="二、OOM 后怎么分析？"></a>二、OOM 后怎么分析？</h3><p>OOM 时最关键的是 <strong>拿到 heap dump 文件</strong>。</p>
<h3 id="1）开启自动-dump"><a href="#1）开启自动-dump" class="headerlink" title="1）开启自动 dump"></a><strong>1）开启自动 dump</strong></h3><p>在启动参数加：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+HeapDumpOnOutOfMemoryError</span> </span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:HeapDumpPath=/tmp/heapdump</span>.hprof</span><br></pre></td></tr></table></figure>
<p>发生 OOM 时 JVM 会自动生成 <code>.hprof</code> 文件。</p>
<h3 id="2）用专业工具分析-dump"><a href="#2）用专业工具分析-dump" class="headerlink" title="2）用专业工具分析 dump"></a><strong>2）用专业工具分析 dump</strong></h3><p>常用工具：</p>
<ul>
<li><strong>MAT（Eclipse Memory Analyzer）</strong></li>
<li><strong>VisualVM</strong></li>
<li><strong>GCeasy</strong></li>
<li><strong>YourKit</strong></li>
</ul>
<p>这些工具可以告诉你：</p>
<ul>
<li>哪些对象占了最多内存</li>
<li>哪些对象存在强引用链无法被清理</li>
<li>是否存在缓存未清理、连接未关闭、集合无限膨胀等问题<br>最后定位到具体代码并修复。</li>
</ul>
<h3 id="小结-19"><a href="#小结-19" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>分析 JVM 内存我主要用两类工具：<strong>在线看实时内存</strong> + <strong>OOM 后看 dump 文件</strong>。</p>
</blockquote>
<p><strong>① 在线分析（实时内存占用）</strong></p>
<ul>
<li><code>jstat -gc &lt;pid&gt;</code> 看 Eden、Survivor、Old 区的使用情况和 GC 情况。</li>
<li><code>jmap -heap &lt;pid&gt;</code> 看堆大小、配置、当前占用情况。</li>
<li><code>jmap -histo &lt;pid&gt;</code> 找占内存最多的类。</li>
</ul>
<p><strong>② OOM 之后怎么分析</strong></p>
<ul>
<li>启动参数加上：<br><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heap.hprof</code><br>OOM 时自动生成 dump。</li>
<li>用 <strong>MAT / VisualVM / GCeasy</strong> 打开 dump，找占用最大的对象、引用链，定位内存泄漏或对象膨胀的代码。</li>
</ul>
<p><strong>一句话总结：</strong></p>
<blockquote>
<p>在线靠 jstat/jmap 看趋势，OOM 靠 dump 文件找大对象和引用链，这两步就能定位大部分 JVM 内存问题。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>JVM面试题</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://itgeqian.github.io/posts/71.html">https://itgeqian.github.io/posts/71.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>geqian's Blog🍭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-10-07</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-10-20</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>JVM</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1PAY.jpg" target="_blank"><img class="post-qr-code-img" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1PAY.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E6%94%AF%E4%BB%98%E5%AE%9DPAY.jpg" target="_blank"><img class="post-qr-code-img" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/%E6%94%AF%E4%BB%98%E5%AE%9DPAY.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/78.html"><img class="prev-cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ElasticSearch相关面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/73.html"><img class="next-cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis相关面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/26.html" title="JVM面试篇"><img class="cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-07-30</div><div class="title">JVM面试篇</div></div></a></div><div><a href="/posts/25.html" title="JVM原理篇"><img class="cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-07-30</div><div class="title">JVM原理篇</div></div></a></div><div><a href="/posts/8.html" title="JVM基础篇"><img class="cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-06-18</div><div class="title">JVM基础篇</div></div></a></div><div><a href="/posts/23.html" title="JVM实战篇"><img class="cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-07-25</div><div class="title">JVM实战篇</div></div></a></div><div><a href="/posts/24.html" title="JVM高级篇"><img class="cover" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-07-28</div><div class="title">JVM高级篇</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GQ-JVM"><span class="toc-text">GQ JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">Java 中有哪些垃圾回收算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%EF%BC%88Mark-Sweep%EF%BC%89%EF%BC%9A"><span class="toc-text">1. 标记 - 清除（Mark-Sweep）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%EF%BC%88Copying%EF%BC%89%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-text">2. 复制（Copying）算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%88Mark-Compact%EF%BC%89%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-text">3. 标记 - 整理（Mark-Compact）算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88Generational-GC%EF%BC%89%EF%BC%9A"><span class="toc-text">4. 分代垃圾回收（Generational GC）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E7%9A%84-TLAB%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JVM 的 TLAB（Thread-Local Allocation Buffer）是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 是如何实现跨平台的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%9F"><span class="toc-text">JVM 由哪些部分组成？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E4%B8%8E%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FJVM-%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">编译执行与解释执行的区别是什么？JVM 使用哪种方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">JVM 的方式：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84%EF%BC%9F"><span class="toc-text">JVM 的内存区域是如何划分的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E7%AE%80%E8%A6%81%E5%9B%9E%E7%AD%94"><span class="toc-text">面试简要回答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E6%96%B9%E6%B3%95%E5%8C%BA%E6%98%AF%E5%90%A6%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">JVM 方法区是否会出现内存溢出?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-text">运行时数据区的哪些区域会出现内存溢出？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9A"><span class="toc-text">堆内存溢出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9A"><span class="toc-text">栈内存溢出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9A"><span class="toc-text">方法区内存溢出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9A"><span class="toc-text">直接内存溢出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E6%97%B6%E7%AE%80%E7%AD%94%EF%BC%9A"><span class="toc-text">面试时简答：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E6%9C%89%E9%82%A3%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%BC%9A%E4%BA%A7%E7%94%9F-OOM%EF%BC%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%89%EF%BC%9F"><span class="toc-text">JVM 有那几种情况会产生 OOM（内存溢出）？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中堆和栈的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%EF%BC%89%EF%BC%9F"><span class="toc-text">什么是 Java 中的直接内存（堆外内存）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-text">什么是 Java 中的常量池？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">常量池的作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-text">对比和优化：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3-Java-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%90%97%EF%BC%9F"><span class="toc-text">你了解 Java 的类加载器吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">什么是类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-1-9-%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">JDK 1.9 的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">类加载器之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84-JIT%EF%BC%88Just-In-Time%EF%BC%89"><span class="toc-text">什么是 Java 中的 JIT（Just-In-Time）?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90"><span class="toc-text">举个栗子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JIT 编译优化做了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E8%AF%86%E5%88%AB%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">热点代码识别方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT-%E7%BC%96%E8%AF%91%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">JIT 编译器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">JIT可能带来的问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JIT-%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AD%98%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">JIT 编译后的代码存在哪？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-AOT%EF%BC%88Ahead-Of-Time%EF%BC%89%EF%BC%9F"><span class="toc-text">什么是 Java 的 AOT（Ahead-Of-Time）？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOT"><span class="toc-text">什么是AOT?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">工作原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOT-%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-text">AOT 的优势：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOT-%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">AOT 的缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-AOT-%E5%B7%A5%E5%85%B7%EF%BC%9A"><span class="toc-text">常见 AOT 工具：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3-Java-%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%90%97%EF%BC%9F"><span class="toc-text">你了解 Java 的逃逸分析吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">什么是逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">核心原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E9%80%83%E9%80%B8%E8%8C%83%E5%9B%B4%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">根据逃逸范围分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E6%A0%B9%E6%8D%AE%E9%80%83%E9%80%B8%E6%83%85%E5%86%B5%E4%BC%9A%E5%81%9A%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-text">JVM 根据逃逸情况会做的三种优化：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E8%99%BD%E7%84%B6%E5%BE%88%E5%BC%BA%EF%BC%8C%E4%BD%86%E4%B9%9F%E6%9C%89%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">逃逸分析虽然很强，但也有一些问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-JVM-%E5%8F%82%E6%95%B0%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-text">常见 JVM 参数（了解即可）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的强引用、软引用、弱引用和虚引用分别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="toc-text">强引用（Strong Reference）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">举例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="toc-text">软引用（Soft Reference）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A-1"><span class="toc-text">举例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="toc-text">弱引用（Weak Reference）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A-2"><span class="toc-text">举例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89"><span class="toc-text">虚引用（Phantom Reference）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A-3"><span class="toc-text">举例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E8%A1%A8%E6%A0%BC"><span class="toc-text">对比表格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Java 中常见的垃圾收集器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%98%AF%E5%9E%83%E5%9C%BE%EF%BC%9F%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Java 中如何判断对象是否是垃圾？不同实现方式有何区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%B0%86%E5%A0%86%E5%88%86%E4%B8%BA%E8%80%81%E5%B9%B4%E4%BB%A3%E5%92%8C%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%9F"><span class="toc-text">为什么 Java 的垃圾收集器将堆分为老年代和新生代？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%BB%A3%EF%BC%9F"><span class="toc-text">为什么要分代？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%88%86%E4%BB%A3%E7%BB%93%E6%9E%84"><span class="toc-text">堆的分代结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%BB%93%E6%9E%84"><span class="toc-text">新生代结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">老年代的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-8-%E7%A7%BB%E9%99%A4%E4%BA%86%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88PermGen%EF%BC%89%E5%B9%B6%E5%BC%95%E5%85%A5%E4%BA%86%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89%EF%BC%9F"><span class="toc-text">为什么 Java 8 移除了永久代（PermGen）并引入了元空间（Metaspace）？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PermGen-%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E5%B1%80%E9%99%90"><span class="toc-text">PermGen 的问题与局限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metaspace-%E7%9A%84%E6%94%B9%E8%BF%9B%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="toc-text">Metaspace 的改进与优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%85%83%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-text">如何调整元空间大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E5%AF%B9%E6%AF%94"><span class="toc-text">表格对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E6%96%B0%E7%94%9F%E4%BB%A3%E8%A2%AB%E5%88%92%E5%88%86%E4%B8%BA-S0%E3%80%81S1-%E5%92%8C-Eden-%E5%8C%BA%EF%BC%9F"><span class="toc-text">为什么 Java 新生代被划分为 S0、S1 和 Eden 区？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="toc-text">为什么要分区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%AF%94%E4%BE%8B"><span class="toc-text">分区结构与比例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%97%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">GC时的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C-Survivor-%E6%94%BE%E4%B8%8D%E4%B8%8B%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">如果 Survivor 放不下怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是三色标记算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E6%BC%8F%E6%A0%87%E9%97%AE%E9%A2%98%E5%92%8C%E5%A4%9A%E6%A0%87%E9%97%AE%E9%A2%98"><span class="toc-text">三色标记中可能出现漏标问题和多标问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-young-GC%E3%80%81old-GC%E3%80%81full-GC-%E5%92%8C-mixed-GC-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Java 中的 young GC、old GC、full GC 和 mixed GC 的区别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Young-GC%EF%BC%88%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E5%8F%88%E7%A7%B0Minor-GC-%E6%88%96-YGC"><span class="toc-text">Young GC（年轻代垃圾回收）又称Minor GC 或 YGC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Old-GC%EF%BC%88%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E5%8F%88%E7%A7%B0Major-GC-%E6%88%96-OGC"><span class="toc-text">Old GC（老年代垃圾回收）又称Major GC 或 OGC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixed-GC%EF%BC%88%E6%B7%B7%E5%90%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-text">Mixed GC（混合垃圾回收）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E8%A1%A8%E6%A0%BC"><span class="toc-text">总结表格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%9D%A1%E4%BB%B6%E4%BC%9A%E8%A7%A6%E5%8F%91-Java-%E7%9A%84-young-GC%EF%BC%9F"><span class="toc-text">什么条件会触发 Java 的 young GC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91-Java-%E7%9A%84-Full-GC%EF%BC%9F"><span class="toc-text">什么情况下会触发 Java 的 Full GC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84-PLAB%EF%BC%9F"><span class="toc-text">什么是 Java 的 PLAB？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLAB-vs-PLAB"><span class="toc-text">TLAB vs PLAB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%97%B6%E4%BA%A7%E7%94%9F%E7%9A%84-concurrent-mode-failure-%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-text">CMS 的工作原理简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD"><span class="toc-text">常见的优化措施</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A-1"><span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD-CMS-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%9C%A8%E5%8F%91%E7%94%9F-Concurrent-Mode-Failure-%E6%97%B6%E7%9A%84-Full-GC-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-text">为什么 Java 中 CMS 垃圾收集器在发生 Concurrent Mode Failure 时的 Full GC 是单线程的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD%E6%9F%90%E4%BA%9B%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8D%E8%83%BD%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E6%AF%94%E5%A6%82-ParNew-%E5%92%8C-Parallel-Old"><span class="toc-text">为什么 Java 中某些新生代和老年代的垃圾收集器不能组合使用？比如 ParNew 和 Parallel Old</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%85%A8%E5%A0%86%E6%89%AB%E6%8F%8F%EF%BC%9F"><span class="toc-text">JVM 新生代垃圾回收如何避免全堆扫描？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E2%80%9C%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E2%80%9D%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">为什么会有“跨代引用”问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%8D%A1%E8%A1%A8%EF%BC%88Card-Table%EF%BC%89-%E5%86%99%E5%B1%8F%E9%9A%9C%EF%BC%88Write-Barrier%EF%BC%89"><span class="toc-text">解决方案：卡表（Card Table）+ 写屏障（Write Barrier）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC-%E6%97%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">Minor GC 时的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-9"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%9A%84-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9C%A8%E8%AE%B0%E5%BF%86%E9%9B%86%E7%9A%84%E7%BB%B4%E6%8A%A4%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">Java 的 CMS 垃圾回收器和 G1 垃圾回收器在记忆集的维护上有什么不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-%E7%9A%84%E8%AE%B0%E5%BF%86%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-text">G1 的记忆集机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">对比总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-10"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-G1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8D%E7%BB%B4%E6%8A%A4%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%88%B0%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E8%AE%B0%E5%BF%86%E9%9B%86%EF%BC%9F"><span class="toc-text">为什么 G1 垃圾收集器不维护年轻代到老年代的记忆集？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-CMS-%E5%92%8C-G1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8C%81%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%EF%BC%9F"><span class="toc-text">Java 中的 CMS 和 G1 垃圾收集器如何维持并发的正确性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B9%B6%E5%8F%91%E6%AD%A3%E7%A1%AE%E6%80%A7%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">为什么需要并发正确性机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%EF%BC%9A%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%EF%BC%88Incremental-Update%EF%BC%89"><span class="toc-text">CMS：增量更新（Incremental Update）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">机制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E8%A1%A5%E5%85%85%E6%96%B0%E5%A2%9E%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%9C%89%E6%96%B0%E7%9A%84%E5%BC%95%E7%94%A8%E4%BA%A7%E7%94%9F%EF%BC%8CCMS-%E4%BC%9A%E9%80%9A%E8%BF%87%E5%86%99%E5%B1%8F%E9%9A%9C%E7%AB%8B%E5%8D%B3%E6%9B%B4%E6%96%B0%E6%A0%87%E8%AE%B0%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-text">核心思想：补充新增的引用关系。也就是说，只要有新的引用产生，CMS 会通过写屏障立即更新标记状态。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%EF%BC%9ASATB%EF%BC%88Snapshot-At-The-Beginning%EF%BC%89"><span class="toc-text">G1：SATB（Snapshot At The Beginning）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86-1"><span class="toc-text">机制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E4%BF%9D%E7%95%99%E6%97%A7%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%EF%BC%8C%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A0%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-text">核心思想：保留旧的引用关系，防止误删对象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">G1 的实现细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-11"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-G1-%E7%9B%B8%E5%AF%B9%E4%BA%8E-CMS-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9B%E6%AD%A5%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-text">Java G1 相对于 CMS 有哪些进步的地方?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E6%9D%A5%E7%9C%8B"><span class="toc-text">从内存管理机制来看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9D%A5%E7%9C%8B"><span class="toc-text">从回收算法来看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E6%9D%A5%E7%9C%8B"><span class="toc-text">从停顿时间来看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%9D%A5%E7%9C%8B"><span class="toc-text">从大对象与跨代引用优化来看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85"><span class="toc-text">额外补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-12"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E4%B8%AD%E7%9A%84-logging-write-barrier%EF%BC%9F"><span class="toc-text">什么是 Java 中的 logging write barrier？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E7%90%86%E8%A7%A3%E5%86%99%E5%B1%8F%E9%9A%9C%EF%BC%88Write-Barrier%EF%BC%89"><span class="toc-text">先理解写屏障（Write Barrier）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logging-Write-Barrier-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Logging Write Barrier 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logging-Write-Barrier-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">Logging Write Barrier 的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8D%E5%90%8C-GC-%E4%B8%AD%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-text">在不同 GC 中的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logging-Write-Barrier-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">Logging Write Barrier 的意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%9A%84-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 的 G1 垃圾回收流程是怎样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%EF%BC%88Initial-Mark%EF%BC%8CSTW%EF%BC%89"><span class="toc-text">一、初始标记（Initial Mark，STW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%88Concurrent-Mark%EF%BC%89"><span class="toc-text">二、并发标记（Concurrent Mark）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9C%80%E7%BB%88%E6%A0%87%E8%AE%B0%EF%BC%88Final-Remark%EF%BC%8CSTW%EF%BC%89"><span class="toc-text">三、最终标记（Final Remark，STW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B8%85%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%88Cleanup%EF%BC%8CSTW%EF%BC%89"><span class="toc-text">四、清理阶段（Cleanup，STW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E8%BD%AC%E7%A7%BB%EF%BC%88Evacuation%EF%BC%8CSTW%EF%BC%89"><span class="toc-text">五、对象拷贝 &#x2F; 转移（Evacuation，STW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-%E7%9A%84%E5%B9%B6%E5%8F%91%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="toc-text">G1 的并发调优参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%9A%84-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 的 CMS 垃圾回收流程是怎样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%EF%BC%88Initial-Mark%EF%BC%8CSTW%EF%BC%89-1"><span class="toc-text">一、初始标记（Initial Mark，STW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%88Concurrent-Marking%EF%BC%89"><span class="toc-text">二、并发标记（Concurrent Marking）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%A2%84%E6%B8%85%E7%90%86%EF%BC%88Concurrent-Preclean%EF%BC%89"><span class="toc-text">三、预清理（Concurrent Preclean）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%EF%BC%88Remark%EF%BC%8CSTW%EF%BC%89"><span class="toc-text">四、重新标记（Remark，STW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B9%B6%E5%8F%91%E6%B8%85%E7%90%86%EF%BC%88Concurrent-Sweep%EF%BC%89"><span class="toc-text">五、并发清理（Concurrent Sweep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B9%B6%E5%8F%91%E9%87%8D%E7%BD%AE%EF%BC%88Concurrent-Reset%EF%BC%89"><span class="toc-text">六、并发重置（Concurrent Reset）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="toc-text">CMS 的两个典型问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A-2"><span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3-Java-%E7%9A%84-ZGC%EF%BC%88Z-Garbage-Collector%EF%BC%89%E5%90%97%EF%BC%9F"><span class="toc-text">你了解 Java 的 ZGC（Z Garbage Collector）吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">ZGC 的核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">ZGC 的核心原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC%E6%B5%81%E7%A8%8B"><span class="toc-text">ZGC流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC%E4%B8%8E-G1-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">ZGC与 G1 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-13"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JVM 垃圾回收调优的主要目标是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-text">两者的权衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-14"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9-Java-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E4%BC%98%EF%BC%9F"><span class="toc-text">如何对 Java 的垃圾回收进行调优？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95"><span class="toc-text">常见调优方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-15"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-JVM-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">常用的 JVM 配置参数有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%B8%B8%E7%94%A8%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7%E6%9D%A5%E5%88%86%E6%9E%90-JVM-%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-text">你常用哪些工具来分析 JVM 性能？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF%E5%B7%A5%E5%85%B7"><span class="toc-text">基础信息工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E-GC-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">内存与 GC 分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">线程和锁分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-text">可视化工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E9%AB%98%E7%BA%A7%E5%B7%A5%E5%85%B7"><span class="toc-text">第三方高级工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-text">常见问题与工具选择建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-16"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-Java-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-text">如何在 Java 中进行内存泄漏分析？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E9%87%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8C%E9%9D%A2%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">Java 里的对象在虚拟机里面是怎么存储的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">对象的整体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88Header%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-text">对象头（Header）详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%88Instance-Data%EF%BC%89"><span class="toc-text">实例数据（Instance Data）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%EF%BC%88Padding%EF%BC%89"><span class="toc-text">对齐填充（Padding）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mark-Word-%E7%A4%BA%E4%BE%8B%EF%BC%8864-%E4%BD%8D%EF%BC%89"><span class="toc-text">Mark Word 示例（64 位）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-17"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Java-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">说说 Java 的执行流程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E4%B8%8A-CPU-%E9%A3%99%E9%AB%98%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-text">线上 CPU 飙高如何排查？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%AE%9A%E4%BD%8D%E5%93%AA%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8-CPU"><span class="toc-text">① 定位哪个进程占用 CPU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%AE%9A%E4%BD%8D%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8D%A0%E7%94%A8-CPU"><span class="toc-text">② 定位哪个线程占用 CPU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E6%89%93%E5%8D%B0%E7%BA%BF%E7%A8%8B%E6%A0%88%EF%BC%8C%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%BA%95%E6%98%AF%E5%93%AA%E6%AE%B5%E4%BB%A3%E7%A0%81%E9%80%A0%E6%88%90%E7%9A%84"><span class="toc-text">③ 打印线程栈，定位到底是哪段代码造成的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-%E4%BF%AE%E5%A4%8D-CPU-%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="toc-text">④ 修复 CPU 热点代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-18"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90-JVM-%E5%BD%93%E5%89%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%9FOOM-%E5%90%8E%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-text">怎么分析 JVM 当前的内存占用情况？OOM 后怎么分析？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90-JVM-%E5%BD%93%E5%89%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%9FOOM-%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-text">怎么分析 JVM 当前的内存占用情况？OOM 之后怎么分析？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-JVM-%E5%BD%93%E5%89%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">一、如何分析 JVM 当前的内存占用情况？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89jstat-%E2%80%94%E2%80%94-%E7%9C%8B-JVM-%E5%86%85%E5%AD%98%E5%AE%9E%E6%97%B6%E6%83%85%E5%86%B5"><span class="toc-text">1）jstat —— 看 JVM 内存实时情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89jmap-%E2%80%94%E2%80%94-%E6%9F%A5%E7%9C%8B%E5%A0%86%E7%9A%84%E8%AF%A6%E7%BB%86%E7%BB%93%E6%9E%84"><span class="toc-text">2）jmap —— 查看堆的详细结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81OOM-%E5%90%8E%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-text">二、OOM 后怎么分析？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8-dump"><span class="toc-text">1）开启自动 dump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%94%A8%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90-dump"><span class="toc-text">2）用专业工具分析 dump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-19"><span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/comments/">留点什么</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By geqian's Blog🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20230913" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20230913号"><img src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/20230913.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 geqianの学习笔记 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/杂项/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 geqianの杂项 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 geqianの项目笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/AI/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 geqianのAI大模型 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 geqianの算法学习笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 geqianの面试 (18)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/JUC/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🌏 geqianのJUC (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/JVM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍜 geqianのJVM (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/云原生/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🔐 geqianの云原生相关 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/MQ/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📱 geqianの消息队列 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🏛️ geqianの前端工程 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/mybatis-mybatis-plus/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎨 geqianのmybatis系列 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/微服务/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🗺️ geqianのSpringCloud系列 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/SSM/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📖 geqianのSSM+SpringBoot系列 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/ruoyi/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📞 geqianの若依框架 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/mysql/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">❓ geqianのmysql (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://itgeqian.github.io/categories/Redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💖 geqianのRedis (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://itgeqian.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/%E5%8F%A4%E9%A3%8E.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt="">速通Spring AI Alibaba </a><div class="blog-slider__text">速通Spring AI Alibaba 完结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/60.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt="">GQ Video单服务版本记录</a><div class="blog-slider__text">GQ Video单服务版本记录（完整记录GQ Video从0到1的全记录）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://java-geqian.oss-cn-beijing.aliyuncs.com/geqian-Blos/%E9%BB%91%E9%A9%AC%E5%96%BD2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1.html&quot;);" href="javascript:void(0);" alt="">实验三 汽车租赁系统的UML设计建模 （完结）</a><div class="blog-slider__text">关于汽车租赁系统的UML设计建模</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt="">Mysql相关面试题</a><div class="blog-slider__text">我对mysql的相关理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt="">javase+集合相关面试题</a><div class="blog-slider__text">我对java基础和集合类的相关理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/77.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://u7imgblog.oss-cn-hangzhou.aliyuncs.com/blogbackground/wallhaven-o59q2m.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt="">JUC面试题</a><div class="blog-slider__text">我对JUC的理解</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/68.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper@1.0.12/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>