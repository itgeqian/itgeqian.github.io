<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GQ Video项目部署</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>服务名称</th><th>英文名</th><th>端口号</th><th>版本号</th><th>服务类别</th></tr></thead><tbody><tr><td>数据库</td><td>mysql</td><td>3306</td><td>v8.26</td><td>环境依赖</td></tr><tr><td>搜索引擎</td><td>es</td><td>9201</td><td>3.1.9</td><td>环境依赖</td></tr><tr><td>缓存</td><td>Redis</td><td>6379</td><td>v8</td><td>环境依赖</td></tr><tr><td>消息队列</td><td>RocketMQ</td><td></td><td>2.3.0</td><td>环境依赖</td></tr><tr><td>注册中心</td><td>nacos</td><td>8848</td><td>v2.2.0</td><td>环境依赖</td></tr><tr><td>网关服务</td><td>easylive-cloud-gateway</td><td>7071</td><td>java8</td><td>项目</td></tr><tr><td>分布式事务</td><td>Seata</td><td>7091</td><td>2021.0.5.0</td><td>环境依赖</td></tr><tr><td>对象存储</td><td>Minio</td><td>9000</td><td>2024-09-13T20-26-02Z</td><td>环境依赖</td></tr><tr><td>管理端服务</td><td>easylive-cloud-admin</td><td>7070</td><td>java8</td><td>项目</td></tr><tr><td>用户端服务</td><td>easylive-cloud-web</td><td>7072</td><td>java8</td><td>项目</td></tr><tr><td>交互服务</td><td>easylive-cloud-interact</td><td>7073</td><td>java8</td><td>项目</td></tr><tr><td>资源服务</td><td>easylive-cloud-resource</td><td>7074</td><td>java8</td><td>项目</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h1 id="微服务项目部署指导"><a href="#微服务项目部署指导" class="headerlink" title="微服务项目部署指导"></a>微服务项目部署指导</h1><p><em>Exported on 2025/10/6 at GMT+8 0:12:27 from Cursor (1.4.2)</em></p><hr><p><strong>User</strong></p><p>整个项目已经完结，请你仔细查看一下项目的结构，我现在想要把这个微服务项目部署到一个我已经准备好的4核4g的服务器上该如何部署，是选择用宝塔面板还是用docker compose部署呢，请你指引着我一步步完成部署@c:\Users\wanglei\Desktop\项目部署.md </p><hr><p><strong>Cursor</strong></p><p>我先快速查看各微服务的配置文件端口与外部依赖（Nacos、Redis、RocketMQ、Minio 等）的指向，确保 docker-compose 方案能一次性把依赖与服务都编排好。随后我会给出一步步部署清单与可直接使用的 compose 文件与构建命令。</p><p>我将先创建一个部署任务清单，随后直接给出推荐方案（Docker Compose）与可运行的命令、配置与文件模板。接下来我会把全部步骤一次性写全，便于你按部就班执行。</p><p>我先并行打开各微服务的配置文件，确认注册中心、配置名与端口设置，以便给出可直接可用的 docker-compose 参数和环境变量。接着我会确定采用 Docker Compose 的总体策略并开始给出脚本。</p><p>我已确认各服务的 <code>bootstrap.yml</code> 通过 Nacos 加载共享配置且默认指向 127.0.0.1:8848，容器化时需用环境变量覆盖为 nacos:8848。现在我先确定采用 Docker Compose 方案，并开始给出安装与编排文件。接下来把“安装 Docker/Compose”设为进行中。</p><p>我将并行打开各服务的 dev 配置文件，确认数据库、存储和消息队列的连接信息，以便在 docker-compose 中正确注入环境变量。</p><p>我将把“安装 Docker/Compose”完成并开始“创建目录结构与 .env 机密变量”，随后给出<code>.env</code>和<code>docker-compose.yml</code>模板与执行命令。接着我会继续推进依赖与应用编排等步骤，并同步勾选对应待办。</p><p>我已经确定采用 Docker Compose 部署，并开始输出目录结构、<code>.env</code> 与依赖编排模板，随后给出后端镜像构建与应用编排、前端与 Nginx 配置。接着我会把“创建目录结构与 .env”标记完成，并开启“依赖服务编排”和“应用编排”。</p><p>我已确认采用 Docker Compose 并核对了各微服务的 Nacos 配置与端口。现在我会直接给出一步步部署清单、必要命令与可用模板（.env、docker-compose、Dockerfile、Nginx），你可以按顺序执行。随后我会把清单项勾选完成。### 结论与建议</p><ul><li>建议使用 Docker Compose 部署。原因：<ul><li>多个基础依赖（MySQL/Redis/Nacos/RocketMQ/Minio/ES/Seata）与 5 个 SpringBoot 微服务需要统一编排、网络与持久化，更易复现与维护。</li><li>日志、重启策略、资源限制、备份与迁移都更容易标准化。</li></ul></li><li>4 核 4G 机器资源偏紧。建议先上线核心链路（MySQL、Redis、Nacos、Minio、网关与核心三服务），RocketMQ/ES/Seata如非强依赖可延后启用，或按需独立机器。</li></ul><h3 id="端口规划（来自你的部署文档）"><a href="#端口规划（来自你的部署文档）" class="headerlink" title="端口规划（来自你的部署文档）"></a>端口规划（来自你的部署文档）</h3><ul><li>数据库 MySQL: 3306</li><li>Nacos: 8848</li><li>网关 <code>easylive-cloud-gateway</code>: 7071</li><li>管理端 <code>easylive-cloud-admin</code>: 7070</li><li>用户端 <code>easylive-cloud-web</code>: 7072</li><li>交互 <code>easylive-cloud-interact</code>: 7073</li><li>资源 <code>easylive-cloud-resource</code>: 7074</li><li>Redis: 6379</li><li>Minio: 9000(服务) + 9001(控制台)</li><li>RocketMQ/ES/Seata：按需启用（建议后置）</li></ul><p>下面步骤直接可执行，按顺序来。</p><h3 id="1-安装-Docker-amp-Compose（以-Ubuntu-20-04-22-04-为例）"><a href="#1-安装-Docker-amp-Compose（以-Ubuntu-20-04-22-04-为例）" class="headerlink" title="1) 安装 Docker &amp; Compose（以 Ubuntu 20.04/22.04 为例）"></a>1) 安装 Docker &amp; Compose（以 Ubuntu 20.04/22.04 为例）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 基础依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update -y</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y ca-certificates curl gnupg lsb-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) Docker 仓库</span></span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg \</span><br><span class="line"> | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] \</span></span><br><span class="line"><span class="string">  https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> \</span><br><span class="line"> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"><span class="built_in">sudo</span> apt-get update -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 安装</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4) 免 sudo（重新登录生效）</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h3 id="2-目录结构与时区"><a href="#2-目录结构与时区" class="headerlink" title="2) 目录结构与时区"></a>2) 目录结构与时区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/easylive/&#123;mysql/data,mysql/init,redis,data,nacos,data,minio/data,nginx/conf.d,frontend/&#123;web,admin&#125;,logs&#125;</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/easylive/&#123;gateway,admin,web,interact,resource&#125;/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/easylive/&#123;rocketmq/&#123;namesrv,broker&#125;,es/data,seata&#125;</span><br><span class="line"><span class="built_in">sudo</span> timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure><h3 id="3-env（放到-opt-easylive-env）"><a href="#3-env（放到-opt-easylive-env）" class="headerlink" title="3) .env（放到 /opt/easylive/.env）"></a>3) .env（放到 /opt/easylive/.env）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL</span></span><br><span class="line">MYSQL_ROOT_PASSWORD=YourStrongRootPass!</span><br><span class="line">MYSQL_DATABASE=easylive</span><br><span class="line"></span><br><span class="line"><span class="comment"># Nacos</span></span><br><span class="line">NACOS_VERSION=v2.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Minio</span></span><br><span class="line">MINIO_ROOT_USER=admin</span><br><span class="line">MINIO_ROOT_PASSWORD=YourStrongMinioPass!</span><br><span class="line"></span><br><span class="line"><span class="comment"># Java 内存建议（4G 机器尽量克制）</span></span><br><span class="line">JAVA_XMS=256m</span><br><span class="line">JAVA_XMX=512m</span><br></pre></td></tr></table></figure><h3 id="4-docker-compose-yml（放到-opt-easylive-docker-compose-yml）"><a href="#4-docker-compose-yml（放到-opt-easylive-docker-compose-yml）" class="headerlink" title="4) docker-compose.yml（放到 /opt/easylive/docker-compose.yml）"></a>4) docker-compose.yml（放到 /opt/easylive/docker-compose.yml）</h3><p>为节省内存，RocketMQ/ES/Seata 先注释，核心链路先跑通。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">easylive</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">easylive-net:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql-data:</span></span><br><span class="line">  <span class="attr">redis-data:</span></span><br><span class="line">  <span class="attr">nacos-data:</span></span><br><span class="line">  <span class="attr">minio-data:</span></span><br><span class="line">  <span class="attr">es-data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=$&#123;MYSQL_DATABASE&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD-SHELL&quot;</span>,<span class="string">&quot;mysqladmin ping -uroot -p$&#123;MYSQL_ROOT_PASSWORD&#125; | grep &#x27;mysqld is alive&#x27;&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--appendonly&quot;</span>, <span class="string">&quot;yes&quot;</span> ]</span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-data:/data</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:$&#123;NACOS_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">      <span class="comment"># 使用 MySQL 做持久化（推荐）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PLATFORM=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_NAME=nacos_config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PORT=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_USER=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="comment"># JVM 缩小</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMS=256m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMX=512m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMN=256m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:RELEASE.2024-09-13T20-26-02Z</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">minio</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MINIO_ROOT_USER=$&#123;MINIO_ROOT_USER&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MINIO_ROOT_PASSWORD=$&#123;MINIO_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">/data</span> <span class="string">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio-data:/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如无强依赖，先不启动下列服务，稳定后再启用</span></span><br><span class="line">  <span class="comment"># rocketmq-namesrv:</span></span><br><span class="line">  <span class="comment">#   image: apache/rocketmq:5.2.0</span></span><br><span class="line">  <span class="comment">#   container_name: rmq-namesrv</span></span><br><span class="line">  <span class="comment">#   ports: [&quot;9876:9876&quot;]</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - TZ=$&#123;TZ&#125;</span></span><br><span class="line">  <span class="comment">#     - JAVA_OPT_EXT=-Xms256m -Xmx512m</span></span><br><span class="line">  <span class="comment">#   networks: [easylive-net]</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># rocketmq-broker:</span></span><br><span class="line">  <span class="comment">#   image: apache/rocketmq:5.2.0</span></span><br><span class="line">  <span class="comment">#   container_name: rmq-broker</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - NAMESRV_ADDR=rmq-namesrv:9876</span></span><br><span class="line">  <span class="comment">#     - TZ=$&#123;TZ&#125;</span></span><br><span class="line">  <span class="comment">#     - JAVA_OPT_EXT=-Xms256m -Xmx512m</span></span><br><span class="line">  <span class="comment">#   depends_on: [rocketmq-namesrv]</span></span><br><span class="line">  <span class="comment">#   ports: [&quot;10911:10911&quot;,&quot;10909:10909&quot;,&quot;10912:10912&quot;]</span></span><br><span class="line">  <span class="comment">#   networks: [easylive-net]</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># es:</span></span><br><span class="line">  <span class="comment">#   image: docker.elastic.co/elasticsearch/elasticsearch:7.17.22</span></span><br><span class="line">  <span class="comment">#   container_name: es</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - discovery.type=single-node</span></span><br><span class="line">  <span class="comment">#     - xpack.security.enabled=false</span></span><br><span class="line">  <span class="comment">#     - ES_JAVA_OPTS=-Xms512m -Xmx512m</span></span><br><span class="line">  <span class="comment">#     - TZ=$&#123;TZ&#125;</span></span><br><span class="line">  <span class="comment">#   ulimits:</span></span><br><span class="line">  <span class="comment">#     memlock:</span></span><br><span class="line">  <span class="comment">#       soft: -1</span></span><br><span class="line">  <span class="comment">#       hard: -1</span></span><br><span class="line">  <span class="comment">#   ports:</span></span><br><span class="line">  <span class="comment">#     - &quot;9201:9200&quot;</span></span><br><span class="line">  <span class="comment">#   volumes:</span></span><br><span class="line">  <span class="comment">#     - es-data:/usr/share/elasticsearch/data</span></span><br><span class="line">  <span class="comment">#   networks: [easylive-net]</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># seata:</span></span><br><span class="line">  <span class="comment">#   image: seataio/seata-server:1.6.1</span></span><br><span class="line">  <span class="comment">#   container_name: seata</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - SEATA_PORT=7091</span></span><br><span class="line">  <span class="comment">#     - TZ=$&#123;TZ&#125;</span></span><br><span class="line">  <span class="comment">#   ports: [&quot;7091:7091&quot;]</span></span><br><span class="line">  <span class="comment">#   networks: [easylive-net]</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ------------------ 应用服务 ------------------</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-gateway:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gateway</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7071</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">nacos</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7071:7071&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-admin:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7070</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="comment"># 覆盖数据库与 Redis（如 Nacos 未配置完整）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_PORT=6379</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">mysql</span>, <span class="string">redis</span>, <span class="string">nacos</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7070:7070&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-web:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7072</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_PORT=6379</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">mysql</span>, <span class="string">redis</span>, <span class="string">nacos</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7072:7072&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">interact:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-interact:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">interact</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7073</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_PORT=6379</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">mysql</span>, <span class="string">redis</span>, <span class="string">nacos</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7073:7073&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resource:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-resource:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">resource</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7074</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_PORT=6379</span></span><br><span class="line">      <span class="comment"># 如资源服务用到 Minio，请在 Nacos 配置或此处补充访问参数</span></span><br><span class="line">      <span class="comment"># - MINIO_ENDPOINT=http://minio:9000</span></span><br><span class="line">      <span class="comment"># - MINIO_ACCESS_KEY=$&#123;MINIO_ROOT_USER&#125;</span></span><br><span class="line">      <span class="comment"># - MINIO_SECRET_KEY=$&#123;MINIO_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="comment"># - MINIO_BUCKET=your-bucket</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">mysql</span>, <span class="string">redis</span>, <span class="string">nacos</span>, <span class="string">minio</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7074:7074&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.25</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">gateway</span>]</span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./frontend/web:/usr/share/nginx/html</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./frontend/admin:/usr/share/nginx/html/admin</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><h3 id="5-后端服务镜像构建"><a href="#5-后端服务镜像构建" class="headerlink" title="5) 后端服务镜像构建"></a>5) 后端服务镜像构建</h3><p>建议每个服务放一个最简 Dockerfile（以 <code>easylive-cloud-gateway</code> 为例）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 放在 easylive-server/easylive-cloud/easylive-cloud-gateway/Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> eclipse-temurin:<span class="number">8</span>-jre</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/*.jar app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7071</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Xms<span class="variable">$&#123;JAVA_XMS:-256m&#125;</span>&quot;</span>,<span class="string">&quot;-Xmx<span class="variable">$&#123;JAVA_XMX:-512m&#125;</span>&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建步骤（在你的仓库根目录执行；其他四个服务同理更换路径与镜像名/端口）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包全部（跳过测试）</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/easylive-springcloud/easylive-server</span><br><span class="line">./mvnw -v || mvn -v</span><br><span class="line">mvn -DskipTests clean package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像（五个服务）</span></span><br><span class="line">docker build -t easylive-cloud-gateway:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-gateway</span><br><span class="line"></span><br><span class="line">docker build -t easylive-cloud-admin:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-admin</span><br><span class="line"></span><br><span class="line">docker build -t easylive-cloud-web:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-web</span><br><span class="line"></span><br><span class="line">docker build -t easylive-cloud-interact:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-interact</span><br><span class="line"></span><br><span class="line">docker build -t easylive-cloud-resource:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-resource</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>端口通过 <code>SERVER_PORT</code> 覆盖为 7071/7070/7072/7073/7074，跟你的表一致。</li><li>Nacos 地址在容器间为 <code>nacos:8848</code>（已在 compose 中用环境变量覆盖）。</li><li>数据库/Redis 在容器间为 <code>mysql:3306</code>、<code>redis:6379</code>。</li></ul><h3 id="6-Nginx-反代与前端"><a href="#6-Nginx-反代与前端" class="headerlink" title="6) Nginx 反代与前端"></a>6) Nginx 反代与前端</h3><p><code>/opt/easylive/nginx/conf.d/easylive.conf</code>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用户端 Web 静态</span></span><br><span class="line">  <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">  <span class="attribute">index</span> index.html;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 管理端静态（访问 /admin/）</span></span><br><span class="line">  <span class="section">location</span> /admin/ &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/share/nginx/html/admin/;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /admin/index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 反向代理到网关（和 gateway 的路由保持一致）</span></span><br><span class="line">  <span class="section">location</span> /web/       &#123; <span class="attribute">proxy_pass</span> http://gateway:7071/web/; &#125;</span><br><span class="line">  <span class="section">location</span> /interact/  &#123; <span class="attribute">proxy_pass</span> http://gateway:7071/interact/; &#125;</span><br><span class="line">  <span class="section">location</span> /user/      &#123; <span class="attribute">proxy_pass</span> http://gateway:7071/user/; &#125;</span><br><span class="line">  <span class="section">location</span> /file/      &#123; <span class="attribute">proxy_pass</span> http://gateway:7071/file/; &#125;</span><br><span class="line">  <span class="section">location</span> /adminapi/  &#123; <span class="attribute">proxy_pass</span> http://gateway:7071/admin/; &#125; <span class="comment"># 避免静态路径冲突，给管理端 API 换前缀</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host              <span class="variable">$host</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP         <span class="variable">$remote_addr</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Forwarded-For   <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建前端并拷贝静态资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户端</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/easylive-springcloud/easylive-front/easylive-front-web</span><br><span class="line">npm ci || npm install</span><br><span class="line">npm run build</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -r dist/* /opt/easylive/frontend/web/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理端</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/easylive-springcloud/easylive-front/easylive-front-admin</span><br><span class="line">npm ci || npm install</span><br><span class="line">npm run build</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/easylive/frontend/admin</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -r dist/* /opt/easylive/frontend/admin/</span><br></pre></td></tr></table></figure><p>如前端请求网关的基地址可配置，建议改为相对路径并按上面 Nginx 反代规则访问。</p><h3 id="7-Minio-初始化（可选）"><a href="#7-Minio-初始化（可选）" class="headerlink" title="7) Minio 初始化（可选）"></a>7) Minio 初始化（可选）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --network easylive_easylive-net -it \</span><br><span class="line">  minio/mc sh -c <span class="string">&quot;</span></span><br><span class="line"><span class="string">mc alias set minio http://minio:9000 <span class="variable">$&#123;MINIO_ROOT_USER&#125;</span> <span class="variable">$&#123;MINIO_ROOT_PASSWORD&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="string">mc mb -p minio/easylive &amp;&amp; \</span></span><br><span class="line"><span class="string">mc anonymous set download minio/easylive&quot;</span></span><br></pre></td></tr></table></figure><h3 id="8-Nacos-配置"><a href="#8-Nacos-配置" class="headerlink" title="8) Nacos 配置"></a>8) Nacos 配置</h3><ul><li>访问 <code>http://服务器IP:8848/nacos</code>，默认无鉴权或按镜像默认设置。</li><li>为每个服务新增配置：<ul><li><code>easylive-cloud-admin-dev.yml</code></li><li><code>easylive-cloud-web-dev.yml</code></li><li><code>easylive-cloud-interact-dev.yml</code></li><li><code>easylive-cloud-resource-dev.yml</code></li><li>内容至少包含数据库与 Redis 连接（参考你仓库中 dev yml，将 host 从 127.0.0.1 改为 <code>mysql</code>、<code>redis</code>）：</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><ul><li>资源服务若使用 Minio，请在对应 yml 增加 Minio 配置项（按你项目属性命名），指向 <code>http://minio:9000</code>。</li></ul><h3 id="9-启动与验证"><a href="#9-启动与验证" class="headerlink" title="9) 启动与验证"></a>9) 启动与验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/easylive</span><br><span class="line">docker compose pull   <span class="comment"># 第一次可忽略</span></span><br><span class="line">docker compose up -d  <span class="comment"># 启动</span></span><br><span class="line">docker compose ps     <span class="comment"># 查看状态</span></span><br><span class="line">docker logs -f gateway</span><br><span class="line">docker logs -f admin</span><br><span class="line">docker logs -f web</span><br><span class="line">docker logs -f interact</span><br><span class="line">docker logs -f resource</span><br></pre></td></tr></table></figure><ul><li>浏览器访问：<ul><li>Nacos: <code>http://服务器IP:8848/nacos</code></li><li>Minio: <code>http://服务器IP:9001</code></li><li>前端: <code>http://服务器IP/</code>（用户端）与 <code>http://服务器IP/admin/</code>（管理端）</li></ul></li><li>后端连通性：网关 <code>http://服务器IP:7071</code> 下的 <code>/web/**</code>、<code>/interact/**</code>、<code>/user/**</code>、<code>/file/**</code>、<code>/admin/**</code>。</li></ul><h3 id="10-域名与-HTTPS（可选快速）"><a href="#10-域名与-HTTPS（可选快速）" class="headerlink" title="10) 域名与 HTTPS（可选快速）"></a>10) 域名与 HTTPS（可选快速）</h3><ul><li>用 Nginx + Certbot：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -y certbot python3-certbot-nginx</span><br><span class="line"><span class="built_in">sudo</span> certbot --nginx -d your.domain.com -m your@email \</span><br><span class="line">  --agree-tos --no-eff-email --redirect</span><br></pre></td></tr></table></figure><ul><li>或用 Caddy（更简单，自动签发）：将 Nginx 换成 <code>caddy:2</code>，用 Caddyfile 一行反代网关和静态。</li></ul><h3 id="11-常见资源与优化建议"><a href="#11-常见资源与优化建议" class="headerlink" title="11) 常见资源与优化建议"></a>11) 常见资源与优化建议</h3><ul><li>4G 机器内存紧张：先不上 RocketMQ/ES/Seata，JVM 堆保持 <code>-Xms256m -Xmx512m</code>；Nacos JVM 也已收敛。</li><li>MySQL/ES/Minio 数据请使用卷持久化（compose 已配置）。</li><li>日志落盘到容器 stdout，建议再配 ELK/Vector 后续接入。</li></ul><p>你现在可以按以上顺序执行；如果遇到端口/内存/配置问题，发我报错我继续帮你排查。</p><ul><li>我已经完成部署方案选择与全部步骤指引，包含 <code>.env</code>、<code>docker-compose.yml</code>、后端 Dockerfile、Nginx 反代与初始化要点。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1) 基础依赖</span><br><span class="line">sudo apt-get update -y</span><br><span class="line">sudo apt-get install -y ca-certificates curl gnupg lsb-release</span><br><span class="line"></span><br><span class="line"># 2) Docker 仓库</span><br><span class="line">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg \</span><br><span class="line"> | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line">echo \</span><br><span class="line">  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \</span><br><span class="line">  https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; \</span><br><span class="line"> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">sudo apt-get update -y</span><br><span class="line"></span><br><span class="line"># 3) 安装</span><br><span class="line">sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"></span><br><span class="line"># 4) 免 sudo（重新登录生效）</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /opt/easylive/&#123;mysql/data,mysql/init,redis,data,nacos,data,minio/data,nginx/conf.d,frontend/&#123;web,admin&#125;,logs&#125;</span><br><span class="line">sudo mkdir -p /opt/easylive/&#123;gateway,admin,web,interact,resource&#125;/config</span><br><span class="line">sudo mkdir -p /opt/easylive/&#123;rocketmq/&#123;namesrv,broker&#125;,es/data,seata&#125;</span><br><span class="line">sudo timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># MySQL</span><br><span class="line">MYSQL_ROOT_PASSWORD=YourStrongRootPass!</span><br><span class="line">MYSQL_DATABASE=easylive</span><br><span class="line"></span><br><span class="line"># Nacos</span><br><span class="line">NACOS_VERSION=v2.2.0</span><br><span class="line"></span><br><span class="line"># Minio</span><br><span class="line">MINIO_ROOT_USER=admin</span><br><span class="line">MINIO_ROOT_PASSWORD=YourStrongMinioPass!</span><br><span class="line"></span><br><span class="line"># Java 内存建议（4G 机器尽量克制）</span><br><span class="line">JAVA_XMS=256m</span><br><span class="line">JAVA_XMX=512m</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">easylive</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">easylive-net:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql-data:</span></span><br><span class="line">  <span class="attr">redis-data:</span></span><br><span class="line">  <span class="attr">nacos-data:</span></span><br><span class="line">  <span class="attr">minio-data:</span></span><br><span class="line">  <span class="attr">es-data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=$&#123;MYSQL_DATABASE&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD-SHELL&quot;</span>,<span class="string">&quot;mysqladmin ping -uroot -p$&#123;MYSQL_ROOT_PASSWORD&#125; | grep &#x27;mysqld is alive&#x27;&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--appendonly&quot;</span>, <span class="string">&quot;yes&quot;</span> ]</span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-data:/data</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:$&#123;NACOS_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">      <span class="comment"># 使用 MySQL 做持久化（推荐）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PLATFORM=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_NAME=nacos_config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PORT=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_USER=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="comment"># JVM 缩小</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMS=256m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMX=512m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMN=256m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:RELEASE.2024-09-13T20-26-02Z</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">minio</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MINIO_ROOT_USER=$&#123;MINIO_ROOT_USER&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MINIO_ROOT_PASSWORD=$&#123;MINIO_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">/data</span> <span class="string">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio-data:/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如无强依赖，先不启动下列服务，稳定后再启用</span></span><br><span class="line">  <span class="comment"># rocketmq-namesrv:</span></span><br><span class="line">  <span class="comment">#   image: apache/rocketmq:5.2.0</span></span><br><span class="line">  <span class="comment">#   container_name: rmq-namesrv</span></span><br><span class="line">  <span class="comment">#   ports: [&quot;9876:9876&quot;]</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - TZ=$&#123;TZ&#125;</span></span><br><span class="line">  <span class="comment">#     - JAVA_OPT_EXT=-Xms256m -Xmx512m</span></span><br><span class="line">  <span class="comment">#   networks: [easylive-net]</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># rocketmq-broker:</span></span><br><span class="line">  <span class="comment">#   image: apache/rocketmq:5.2.0</span></span><br><span class="line">  <span class="comment">#   container_name: rmq-broker</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - NAMESRV_ADDR=rmq-namesrv:9876</span></span><br><span class="line">  <span class="comment">#     - TZ=$&#123;TZ&#125;</span></span><br><span class="line">  <span class="comment">#     - JAVA_OPT_EXT=-Xms256m -Xmx512m</span></span><br><span class="line">  <span class="comment">#   depends_on: [rocketmq-namesrv]</span></span><br><span class="line">  <span class="comment">#   ports: [&quot;10911:10911&quot;,&quot;10909:10909&quot;,&quot;10912:10912&quot;]</span></span><br><span class="line">  <span class="comment">#   networks: [easylive-net]</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># es:</span></span><br><span class="line">  <span class="comment">#   image: docker.elastic.co/elasticsearch/elasticsearch:7.17.22</span></span><br><span class="line">  <span class="comment">#   container_name: es</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - discovery.type=single-node</span></span><br><span class="line">  <span class="comment">#     - xpack.security.enabled=false</span></span><br><span class="line">  <span class="comment">#     - ES_JAVA_OPTS=-Xms512m -Xmx512m</span></span><br><span class="line">  <span class="comment">#     - TZ=$&#123;TZ&#125;</span></span><br><span class="line">  <span class="comment">#   ulimits:</span></span><br><span class="line">  <span class="comment">#     memlock:</span></span><br><span class="line">  <span class="comment">#       soft: -1</span></span><br><span class="line">  <span class="comment">#       hard: -1</span></span><br><span class="line">  <span class="comment">#   ports:</span></span><br><span class="line">  <span class="comment">#     - &quot;9201:9200&quot;</span></span><br><span class="line">  <span class="comment">#   volumes:</span></span><br><span class="line">  <span class="comment">#     - es-data:/usr/share/elasticsearch/data</span></span><br><span class="line">  <span class="comment">#   networks: [easylive-net]</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># seata:</span></span><br><span class="line">  <span class="comment">#   image: seataio/seata-server:1.6.1</span></span><br><span class="line">  <span class="comment">#   container_name: seata</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - SEATA_PORT=7091</span></span><br><span class="line">  <span class="comment">#     - TZ=$&#123;TZ&#125;</span></span><br><span class="line">  <span class="comment">#   ports: [&quot;7091:7091&quot;]</span></span><br><span class="line">  <span class="comment">#   networks: [easylive-net]</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ------------------ 应用服务 ------------------</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-gateway:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gateway</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7071</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">nacos</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7071:7071&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-admin:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7070</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="comment"># 覆盖数据库与 Redis（如 Nacos 未配置完整）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_PORT=6379</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">mysql</span>, <span class="string">redis</span>, <span class="string">nacos</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7070:7070&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-web:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7072</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_PORT=6379</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">mysql</span>, <span class="string">redis</span>, <span class="string">nacos</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7072:7072&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">interact:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-interact:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">interact</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7073</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_PORT=6379</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">mysql</span>, <span class="string">redis</span>, <span class="string">nacos</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7073:7073&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resource:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">easylive-cloud-resource:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">resource</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$&#123;TZ&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_PORT=7074</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_CLOUD_NACOS_CONFIG_SERVER_ADDR=nacos:8848</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_REDIS_PORT=6379</span></span><br><span class="line">      <span class="comment"># 如资源服务用到 Minio，请在 Nacos 配置或此处补充访问参数</span></span><br><span class="line">      <span class="comment"># - MINIO_ENDPOINT=http://minio:9000</span></span><br><span class="line">      <span class="comment"># - MINIO_ACCESS_KEY=$&#123;MINIO_ROOT_USER&#125;</span></span><br><span class="line">      <span class="comment"># - MINIO_SECRET_KEY=$&#123;MINIO_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="comment"># - MINIO_BUCKET=your-bucket</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">mysql</span>, <span class="string">redis</span>, <span class="string">nacos</span>, <span class="string">minio</span>]</span><br><span class="line">    <span class="attr">ports:</span> [<span class="string">&quot;7074:7074&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.25</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">depends_on:</span> [<span class="string">gateway</span>]</span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./frontend/web:/usr/share/nginx/html</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./frontend/admin:/usr/share/nginx/html/admin</span></span><br><span class="line">    <span class="attr">networks:</span> [<span class="string">easylive-net</span>]</span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 放在 easylive-server/easylive-cloud/easylive-cloud-gateway/Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> eclipse-temurin:<span class="number">8</span>-jre</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/*.jar app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7071</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Xms<span class="variable">$&#123;JAVA_XMS:-256m&#125;</span>&quot;</span>,<span class="string">&quot;-Xmx<span class="variable">$&#123;JAVA_XMX:-512m&#125;</span>&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 打包全部（跳过测试）</span><br><span class="line">cd /path/to/easylive-springcloud/easylive-server</span><br><span class="line">./mvnw -v || mvn -v</span><br><span class="line">mvn -DskipTests clean package</span><br><span class="line"></span><br><span class="line"># 构建镜像（五个服务）</span><br><span class="line">docker build -t easylive-cloud-gateway:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-gateway</span><br><span class="line"></span><br><span class="line">docker build -t easylive-cloud-admin:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-admin</span><br><span class="line"></span><br><span class="line">docker build -t easylive-cloud-web:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-web</span><br><span class="line"></span><br><span class="line">docker build -t easylive-cloud-interact:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-interact</span><br><span class="line"></span><br><span class="line">docker build -t easylive-cloud-resource:latest \</span><br><span class="line">  easylive-cloud/easylive-cloud-resource</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name _;</span><br><span class="line"></span><br><span class="line">  # 用户端 Web 静态</span><br><span class="line">  root /usr/share/nginx/html;</span><br><span class="line">  index index.html;</span><br><span class="line"></span><br><span class="line">  # 管理端静态（访问 /admin/）</span><br><span class="line">  location /admin/ &#123;</span><br><span class="line">    alias /usr/share/nginx/html/admin/;</span><br><span class="line">    try_files $uri $uri/ /admin/index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 反向代理到网关（和 gateway 的路由保持一致）</span><br><span class="line">  location /web/       &#123; proxy_pass http://gateway:7071/web/; &#125;</span><br><span class="line">  location /interact/  &#123; proxy_pass http://gateway:7071/interact/; &#125;</span><br><span class="line">  location /user/      &#123; proxy_pass http://gateway:7071/user/; &#125;</span><br><span class="line">  location /file/      &#123; proxy_pass http://gateway:7071/file/; &#125;</span><br><span class="line">  location /adminapi/  &#123; proxy_pass http://gateway:7071/admin/; &#125; # 避免静态路径冲突，给管理端 API 换前缀</span><br><span class="line"></span><br><span class="line">  proxy_set_header Host              $host;</span><br><span class="line">  proxy_set_header X-Real-IP         $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">  proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 用户端</span><br><span class="line">cd /path/to/easylive-springcloud/easylive-front/easylive-front-web</span><br><span class="line">npm ci || npm install</span><br><span class="line">npm run build</span><br><span class="line">sudo cp -r dist/* /opt/easylive/frontend/web/</span><br><span class="line"></span><br><span class="line"># 管理端</span><br><span class="line">cd /path/to/easylive-springcloud/easylive-front/easylive-front-admin</span><br><span class="line">npm ci || npm install</span><br><span class="line">npm run build</span><br><span class="line">sudo mkdir -p /opt/easylive/frontend/admin</span><br><span class="line">sudo cp -r dist/* /opt/easylive/frontend/admin/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --network easylive_easylive-net -it \</span><br><span class="line">  minio/mc sh -c &quot;</span><br><span class="line">mc alias set minio http://minio:9000 $&#123;MINIO_ROOT_USER&#125; $&#123;MINIO_ROOT_PASSWORD&#125; &amp;&amp; \</span><br><span class="line">mc mb -p minio/easylive &amp;&amp; \</span><br><span class="line">mc anonymous set download minio/easylive&quot;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/easylive?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/easylive</span><br><span class="line">docker compose pull   # 第一次可忽略</span><br><span class="line">docker compose up -d  # 启动</span><br><span class="line">docker compose ps     # 查看状态</span><br><span class="line">docker logs -f gateway</span><br><span class="line">docker logs -f admin</span><br><span class="line">docker logs -f web</span><br><span class="line">docker logs -f interact</span><br><span class="line">docker logs -f resource</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y certbot python3-certbot-nginx</span><br><span class="line">sudo certbot --nginx -d your.domain.com -m your@email \</span><br><span class="line">  --agree-tos --no-eff-email --redirect</span><br></pre></td></tr></table></figure><hr><p><strong>User</strong></p><p>4核8g的服务器是否够用能把所有的环境都配上呢，保险起见我是不是应该换个4核8g的服务器</p><hr><p><strong>Cursor</strong></p><p>结论先说：</p><ul><li>4核8G基本能把全套（MySQL/Redis/Nacos/Minio/ES/RocketMQ/Seata + 5个Java服务 + 网关）跑起来，但比较“紧”，需要严格限内存与低负载场景，属于可用但不太宽裕。</li><li>若计划“全部组件长期开启 + 有一定并发”，建议至少换到4核8G；若要更稳，优先把 ES 或 RocketMQ 单独拆机，或直接上更高规格（如8核16G）。</li></ul><p>快速内存预算（保守建议，单位≈GiB）：</p><ul><li>Nacos: 0.5</li><li>MySQL: 0.5–1.0（取决于 innodb_buffer_pool_size）</li><li>Redis: 0.1–0.3</li><li>Minio: 0.3–0.5</li><li>RocketMQ: 0.8–1.2（namesrv 0.3–0.5，broker 0.5–0.7）</li><li>Elasticsearch: 1.0–2.0（堆1–2G，且需 vm.max_map_count）</li><li>Seata: 0.3–0.5</li><li>5个SpringBoot服务: 1.3–2.5（每个 256–512M）</li><li>合计：约 5.3–8.5G（随设置和负载浮动）<br>=&gt; 4核8G在“全部开启”时边缘可用，需非常克制的JVM与DB配置。</li></ul><p>给你两种选择：</p><ul><li>想省事稳一点：换成4核8G（或更高），然后严格控内存即可全开；更理想是把 ES 或 RocketMQ 独立出去。</li><li>先不换服务器：保留4核4G/8G，只启核心链路（MySQL/Redis/Nacos/Minio/网关+业务服务），把 ES/RocketMQ/Seata 暂时关闭或托管到云上，等业务量起来再扩。</li></ul><p>若坚持在4核8G全开运行，务必：</p><ul><li>JVM：所有Java进程统一 -Xms256m -Xmx512m（Nacos、各微服务、Seata、RocketMQ），ES 堆设 1G 起步。</li><li>MySQL：innodb_buffer_pool_size 512M 起；慢慢再调大。</li><li>开启2–4G swap 兜底（仅兜底，不可依赖）。</li><li>用 docker-compose 限制每个容器内存并监控 docker stats。</li><li>优先上线无强依赖的路径；ES/RocketMQ 负载上来后优先拆分或升配。</li></ul><p>简短建议：</p><ul><li>如果你希望“一台机全家桶 + 可留有余量”，我建议换到4核8G（更稳）或把 ES/RocketMQ 外置/托管。</li><li>如果是演示/低QPS场景，4核8G可行；4核4G就建议按我给的最小化编排先跑核心链路。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目部署 </tag>
            
            <tag> GQ Video </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端web复习</title>
      <link href="/posts/4.html"/>
      <url>/posts/4.html</url>
      
        <content type="html"><![CDATA[<p>备考蓝桥杯时写的复习文档（目前有html+css+JavaScript+Ajax）<br>共263页</p><p><a href="https://www.legendkiller.xyz/wp-content/uploads/2025/05/web复习.pdf">https://www.legendkiller.xyz/wp-content/uploads/2025/05/web复习.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验三 汽车租赁系统的UML设计建模 （完结）</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<p>一、实验目的及要求<br>对汽车租赁系统进行分析，利用 UML 工具进行建模。<br>二、实验环境<br>微型计算机、Rational Rose<br>三、实验内容</p><ol><li>对汽车租赁系统进行需求分析，并确定其基本模块，如基本数据维护模块、基本业务<br>模块、数据库模块、信息查询模块。</li><li>确定系统中的类，并生成类图和各个类之间的关系。</li><li>确定 UML 模型框架，并作出以下各图：<br>（1）系统的用例图<br>（2）系统的时序图<br>（3）系统的协作图<br>（4）系统的活动图<br>四、实验步骤<br>1．分析系统，写出系统的功能需求分析描述。<br>（1）基本数据维护模块应包括：<br>添加车辆信息；修改车辆信息；添加员工信息；修改员工信息等。<br>（2）基本业务模块应包括：<br>用户填写预定申请；工作人员处理预定请求；技术人员填写服务纪录；工作人员处理还<br>车请求；<br>（3）数据库模块应包括：<br>客户信息管理；车辆信息管理；租赁信息管理；员工信息管理；<br>（4）信息查询模块应包括：<br>查询客户信息；查询员工信息；查询车辆信息；查询客户租车记录等；</li><li>建立 UML 模型<br>包括用例图、类图、时序图、活动图、协作图、状态图的构建。</li></ol><h2 id="具体分析："><a href="#具体分析：" class="headerlink" title="具体分析："></a><strong>具体分析：</strong></h2><h2 id="1-需求分析部分："><a href="#1-需求分析部分：" class="headerlink" title="1.需求分析部分："></a>1.需求分析部分：</h2><h3 id="1-系统的功能需求分析"><a href="#1-系统的功能需求分析" class="headerlink" title="1.系统的功能需求分析"></a><strong>1.系统的功能需求分析</strong></h3><p>（1）基本数据维护模块应包括：</p><p>添加车辆信息；修改车辆信息；添加员工信息；修改员工信息等。</p><p>（2）基本业务模块应包括：用户填写预定申请；工作人员处理预定请求；技术人员填写服务纪录；工作人员处理还车请求；<br>（3）数据库模块应包括：客户信息管理；车辆信息管理；租赁信息管理；员工信息管理；</p><p>（4）信息查询模块应包括：查询客户信息；查询员工信息；查询车辆信息；查询客户租车记录等；</p><h3 id="2-基本数据维护模块"><a href="#2-基本数据维护模块" class="headerlink" title="2.基本数据维护模块"></a><strong>2</strong>.基本数据维护模块</h3><p>基本数据维护模块是汽车租赁系统中的基础功能模块，主要用于管理与系统运行相关的基础数据，包括车辆信息与员工信息的添加、修改等操作。该模块的良好设计有助于保持数据一致性和系统稳定性，为后续业务操作提供数据支持。</p><p>（1）添加汽车信息：汽车租聘处的车辆信息全部保存在数据库中，确保后续租赁、维护、查询等操作能准确定位目标车辆。<br>应包括以下字段：</p><ul><li>车辆编号（唯一标识）</li><li>品牌型号（如：丰田凯美瑞）</li><li>车牌号码</li><li>颜色</li><li>类型（轿车/越野车/商务车等）</li><li>日租金</li><li>当前状态（空闲/租赁中/维护中） </li></ul><p>功能需求：</p><ul><li>信息提交后，应自动存入车辆信息表中。 </li><li>系统管理员登录后可通过图形界面填写车辆信息。</li><li>系统应对车辆编号、车牌号进行唯一性校验。</li></ul><p>（2）修改车辆信息：由于车辆信息可能发生变更（如状态变更、日租金调整等），系统应支持对已有车辆信息的修改。</p><p>功能需求：</p><ul><li>系统提供按车牌号或车辆编号的查询功能。</li><li>支持对车辆状态、日租金等字段的修改。</li></ul><p>（3）添加员工信息：为支持系统操作、客户服务等功能，所有员工的信息需录入系统。</p><p>应包括以下字段：</p><ul><li>员工编号（唯一标识）</li><li>姓名</li><li>岗位（如：管理员、技术人员、客服人员）</li><li>联系电话</li><li>入职日期</li></ul><p>功能需求：</p><ul><li>信息验证后保存至员工信息表中。</li><li>由管理员添加员工信息。</li><li>员工编号自动生成或手动录入，确保唯一性。</li></ul><p>（4）修改员工信息 </p><p>为应对员工岗位调整、联系方式变更等情况，系统应支持员工信息的维护与更新。</p><p>功能需求：</p><ul><li>修改记录应自动存档以备追踪。</li><li>支持通过员工编号查询目标员工。</li><li>可修改姓名、联系方式、岗位等内容。</li></ul><h3 id="3-基本业务模块"><a href="#3-基本业务模块" class="headerlink" title="3.基本业务模块"></a><strong>3.基本业务模块</strong></h3><p>基本业务模块是汽车租赁系统中最核心的功能板块，涉及用户与系统之间的交互行为，覆盖租赁全过程的操作，包括预定、车辆服务、还车等环节。</p><p>（1）用户填写预定申请：</p><p>用户在系统中发起租车请求，填写所需租赁的车辆类型、起止时间等信息，系统将记录并等待工作人员处理。</p><blockquote><p><strong>功能需求：</strong></p><ul><li>预定信息可由用户随时查看和取消（在审核前）。</li><li>用户登录后可进入“车辆预定”界面；</li><li>填写预定表单内容：租车人信息、租赁时间段、所需车型、用途说明等；</li><li>系统自动检索对应时间段内可租车辆；</li><li>提交成功后，系统自动生成预定记录，状态为“待处理”；       </li></ul></blockquote><p>（2）工作人员处理预定请求：</p><p>工作人员负责审核用户预定请求，确认车辆状态，并将状态变更为“已预定”或“拒绝”。</p><p><strong>功能需求：</strong></p><ul><li>审核通过的预定会锁定对应车辆的时间段状态。</li><li>工作人员登录后可查看所有“待处理”的预定申请；</li><li>支持按日期、用户、车辆类型等条件筛选；</li><li>可进行“通过”或“拒绝”操作，并添加处理备注；</li><li>处理完成后，系统将通知用户审核结果；</li></ul><p>（3）技术人员填写服务记录：</p><p>技术人员在车辆使用前/后进行检查，填写车辆维护与检测记录，保障车辆安全与状态信息准确。</p><p><strong>功能需求：</strong></p><ul><li>登录系统后，可查询并选择需要维护记录的车辆；</li><li>填写内容包括：检查日期、检查人、车辆状况、建议维修、是否可租等；</li><li>提交后，系统更新车辆状态（可租/需维护）；</li><li>服务记录保存至车辆服务历史中。</li></ul><p>（4）工作人员处理还车请求：</p><p>租赁期结束，用户归还车辆，工作人员需核对车辆状况，并更新车辆使用信息及租赁记录。（根据租赁时间和车辆使用状态收取租赁费，如果车辆有损坏收取一定的罚金）</p><p><strong>功能需求：</strong></p><ul><li>归还信息同步到租赁历史记录中。</li><li>系统提供“还车处理”界面；</li><li>工作人员输入车辆编号或租赁单号查询；</li><li>核对车辆归还时间、油量、车况、违章等情况；</li><li>计算最终租赁费用（按日租金×天数+其他费用）；</li><li>如若车辆无误系统自动将租赁记录归档，车辆状态更新为“空闲”；</li><li>如若车辆有损坏，收取一定的罚金，将车辆送往维修厂，车辆状态更新为“维护中”</li></ul><h3 id="4-数据库模块"><a href="#4-数据库模块" class="headerlink" title="4.数据库模块"></a><strong>4.数据库模块</strong></h3><p>数据库模块是整个汽车租赁系统的数据核心，负责系统中各类信息的存储、管理和调用。通过科学的数据结构设计与数据表管理，确保系统高效、稳定、安全运行，为业务模块提供支撑。</p><h4 id="（1）客户信息管理："><a href="#（1）客户信息管理：" class="headerlink" title="（1）客户信息管理："></a>（1）客户信息管理：</h4><p>用于存储和管理客户的基本资料，是租赁流程中用户识别与信用追踪的重要依据。</p><p><strong>主要字段包括：</strong></p><ul><li>客户编号（唯一标识）</li><li>姓名</li><li>性别</li><li>身份证号/驾照号</li><li>联系方式</li><li>注册日期</li><li>租赁历史记录</li><li>备注（如违章记录、黑名单等）</li></ul><p><strong>功能需求：</strong></p><ul><li>支持添加、查询、修改客户信息；</li><li>客户信息在注册或首次租赁时录入；</li><li>系统可根据客户编号或证件号进行唯一性校验；</li><li>敏感信息应加密存储，保障数据安全。</li></ul><h4 id="（2）车辆信息管理："><a href="#（2）车辆信息管理：" class="headerlink" title="（2）车辆信息管理："></a>（2）车辆信息管理：</h4><p>用于维护系统中所有车辆的详细资料，是支撑预定、还车、查询、服务等模块的关键数据来源。</p><p><strong>主要字段包括：</strong></p><ul><li>车辆编号</li><li>品牌型号</li><li>车牌号码</li><li>类型</li><li>当前状态（空闲/租赁中/维护中）</li><li>日租金</li></ul><p><strong>功能需求：</strong></p><ul><li>所有车辆在录入系统时自动生成记录；</li><li>状态字段根据业务流程动态更新；</li><li>支持按车型、状态、编号等条件查询；</li><li>可对车辆信息进行更新（如租金调整、状态更改）。</li></ul><h4 id="（3）租赁信息管理："><a href="#（3）租赁信息管理：" class="headerlink" title="（3）租赁信息管理："></a>（3）租赁信息管理：</h4><p>用于记录每一次租赁交易的完整数据，包括客户、车辆、时间段、费用等，是统计、报表、追责等功能的依据。</p><p><strong>主要字段包括：</strong></p><ul><li>租赁编号（唯一标识）</li><li>客户编号</li><li>车辆编号</li><li>起租时间</li><li>归还时间</li><li>实际归还时间</li><li>总费用</li><li>租赁状态（已完成/未还车/逾期等）</li><li>违章或损坏记录（如有）</li></ul><p><strong>功能需求：</strong></p><ul><li>每次成功预定后生成租赁记录；</li><li>记录车辆的实际归还情况与费用；</li><li>可按客户、车辆、时间段等查询历史租赁记录；</li><li>重要字段不允许擅自修改，保障数据一致性。</li></ul><h4 id="（4）员工信息管理："><a href="#（4）员工信息管理：" class="headerlink" title="（4）员工信息管理："></a>（4）员工信息管理：</h4><p>用于维护系统中所有工作人员的数据，分为不同岗位权限，为后台管理操作和分工协作提供依据。</p><p><strong>主要字段包括：</strong></p><ul><li>员工编号</li><li>姓名</li><li>联系电话</li><li>岗位（管理员/客服/技术人员等）</li><li>登录账号</li><li>密码（加密存储）</li><li>入职时间</li></ul><p><strong>功能需求：</strong></p><ul><li>管理员具备添加、修改员工信息权限；</li><li>系统登录需根据员工账号进行权限验证；</li><li>支持岗位权限管理，不同岗位访问系统不同模块；</li><li>可按员工编号、姓名等条件检索。</li></ul><h3 id="5-信息查询模块"><a href="#5-信息查询模块" class="headerlink" title="5.信息查询模块"></a><strong>5.信息查询模块</strong></h3><p>信息查询模块为用户与工作人员提供高效、便捷的数据检索服务，支持对客户、员工、车辆及租赁记录等信息的多维度查询，确保系统数据的可访问性和透明度。本模块是系统操作过程中的重要辅助功能。</p><h4 id="（1）查询客户信息："><a href="#（1）查询客户信息：" class="headerlink" title="（1）查询客户信息："></a>（1）查询客户信息：</h4><p>工作人员或管理员可根据客户信息进行快速定位与核查。</p><p><strong>功能需求：</strong></p><ul><li>支持按客户编号、姓名、身份证号/驾照号等条件模糊或精确查询；</li><li>展示客户基本信息、联系方式、注册时间、累计租赁次数等；</li><li>可查看该客户所有历史租赁记录；</li><li>提供黑名单或违章记录的标注提示。</li></ul><h4 id="（2）查询员工信息："><a href="#（2）查询员工信息：" class="headerlink" title="（2）查询员工信息："></a>（2）查询员工信息：</h4><p>管理员用于管理员工的身份、岗位、权限等信息。</p><p><strong>功能需求：</strong></p><ul><li>可根据员工编号、姓名、岗位进行查询；</li><li>展示员工基本资料、联系方式、所属岗位及入职日期；</li><li>提供岗位权限信息，判断员工是否具备某项操作权限；</li><li>可导出员工信息表作为管理资料。</li></ul><h4 id="（3）查询车辆信息："><a href="#（3）查询车辆信息：" class="headerlink" title="（3）查询车辆信息："></a>（3）查询车辆信息：</h4><p>便于用户选择合适车辆及工作人员掌握车辆运营状态。</p><p><strong>功能需求：</strong></p><ul><li>支持按车辆编号、品牌型号、车牌号、车辆类型、当前状态等查询条件；</li><li>展示车辆的基本信息、当前状态、是否可租、日租金等；</li><li>提供车辆历史服务记录及维修记录查看接口；</li><li>支持状态筛选（仅查看“空闲”车辆、仅查看“维修中”车辆等）；</li><li>可将车辆查询结果导出为表格或打印。</li></ul><h4 id="（4）查询客户租车记录："><a href="#（4）查询客户租车记录：" class="headerlink" title="（4）查询客户租车记录："></a>（4）查询客户租车记录：</h4><p>用于客户服务、信用评估、异常交易追踪等目的。</p><p><strong>功能需求：</strong></p><ul><li>可按客户编号、姓名进行查询；</li><li>展示所有历史租车记录，包括租赁时间段、车辆信息、费用、归还情况；</li><li>支持对租赁状态（已完成/逾期/未还）进行筛选；</li><li>记录中应包含每次租车的服务情况、是否存在违章或损坏；</li><li>可导出租赁记录明细用于对账、备份或追责。</li></ul><h2 id="2-用例图设计"><a href="#2-用例图设计" class="headerlink" title="2.用例图设计"></a>2.用例图设计</h2><h3 id="1-1-参与者（Actors）"><a href="#1-1-参与者（Actors）" class="headerlink" title="1.1 参与者（Actors）"></a>1.1 参与者（Actors）</h3><p>系统中主要的参与者有：</p><ul><li><strong>客户（Customer）</strong>：使用系统提交预定、查询租车记录等。</li><li><strong>工作人员（Staff）</strong>：负责审核预定、处理还车等。</li><li><strong>技术人员（Technician）</strong>：负责填写服务记录，更新车辆状态。</li><li><strong>管理员（Admin）</strong>：负责系统数据维护，包括添加/修改员工和车辆信息。</li></ul><h3 id="1-2-系统主要用例（Use-Cases）"><a href="#1-2-系统主要用例（Use-Cases）" class="headerlink" title="1.2 系统主要用例（Use Cases）"></a>1.2 系统主要用例（Use Cases）</h3><p>将前面分析过的功能模块转化为用例：</p><h4 id="（1）基本数据维护"><a href="#（1）基本数据维护" class="headerlink" title="（1）基本数据维护"></a>（1）基本数据维护</h4><ul><li>添加车辆信息</li><li>修改车辆信息</li><li>添加员工信息</li><li>修改员工信息</li></ul><h4 id="（2）基本业务操作"><a href="#（2）基本业务操作" class="headerlink" title="（2）基本业务操作"></a>（2）基本业务操作</h4><ul><li>填写租车预定申请</li><li>审核预定请求</li><li>填写车辆服务记录</li><li>处理还车请求</li></ul><h4 id="（3）信息查询"><a href="#（3）信息查询" class="headerlink" title="（3）信息查询"></a>（3）信息查询</h4><ul><li>查询客户信息</li><li>查询员工信息</li><li>查询车辆信息</li><li>查询客户租车记录</li></ul><h3 id="1-3-参与者与用例之间的关系"><a href="#1-3-参与者与用例之间的关系" class="headerlink" title="1.3 参与者与用例之间的关系"></a>1.3 参与者与用例之间的关系</h3><div class="table-container"><table><thead><tr><th>参与者</th><th>可执行的用例</th></tr></thead><tbody><tr><td>客户</td><td>填写租车预定申请、查询客户租车记录</td></tr><tr><td>普通工作人员（客服）</td><td>审核预定请求、处理还车请求、查询客户/车辆信息</td></tr><tr><td>技术人员</td><td>填写车辆服务记录</td></tr><tr><td>管理员</td><td>添加/修改车辆信息、添加/修改员工信息、查询员工信息</td></tr></tbody></table></div><h3 id="1-4可视化建议（在Rational-Rose中建图）："><a href="#1-4可视化建议（在Rational-Rose中建图）：" class="headerlink" title="1.4可视化建议（在Rational Rose中建图）："></a>1.4可视化建议（在Rational Rose中建图）：</h3><p>整体用一个系统边框（System）包住所有用例，命名为“汽车租赁系统”</p><p>创建4个Actor，分别命名为：</p><ul><li><code>客户</code></li><li><code>工作人员</code></li><li><code>技术人员</code></li><li><code>管理员</code></li></ul><p>创建12个用例（Use Case）：</p><p>每个功能点用椭圆表示，用线连接Actor与他们能够使用的用例</p><div class="table-container"><table><thead><tr><th>模块</th><th>用例（功能）名称</th><th>所属角色</th></tr></thead><tbody><tr><td>数据维护模块</td><td>添加车辆信息</td><td>管理员</td></tr><tr><td>数据维护模块</td><td>修改车辆信息</td><td>管理员</td></tr><tr><td>数据维护模块</td><td>添加员工信息</td><td>管理员</td></tr><tr><td>数据维护模块</td><td>修改员工信息</td><td>管理员</td></tr><tr><td>业务模块</td><td>填写租车预定申请</td><td>客户</td></tr><tr><td>业务模块</td><td>审核预定请求</td><td>工作人员</td></tr><tr><td>业务模块</td><td>填写服务记录</td><td>技术人员</td></tr><tr><td>业务模块</td><td>处理还车请求</td><td>工作人员</td></tr><tr><td>查询模块</td><td>查询客户信息</td><td>工作人员/管理员</td></tr><tr><td>查询模块</td><td>查询员工信息</td><td>管理员</td></tr><tr><td>查询模块</td><td>查询车辆信息</td><td>工作人员/管理员</td></tr><tr><td>查询模块</td><td>查询客户租车记录</td><td>客户/工作人员</td></tr></tbody></table></div><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>“参与者”是使用系统的人或角色</strong></li><li><strong>“用例”是系统提供的某项功能或服务</strong></li><li>一个参与者可以参与多个用例</li><li>一个用例也可以被多个参与者使用（例如查询车辆信息）</li></ul><h2 id="3-类图设计"><a href="#3-类图设计" class="headerlink" title="3.类图设计"></a>3.类图设计</h2><p><strong>类图说明系统的静态结构</strong>：有哪些类（实体），它们有哪些属性（字段）、方法（功能），以及类之间的关系（关联、继承、依赖等）。</p><h3 id="系统中的核心类"><a href="#系统中的核心类" class="headerlink" title="系统中的核心类"></a>系统中的核心类</h3><div class="table-container"><table><thead><tr><th>类名</th><th>上层继承/从属关系</th><th>关联对象</th><th>主要属性字段</th><th>主要方法（功能）</th></tr></thead><tbody><tr><td><strong>Person（抽象类）</strong></td><td>-</td><td>-</td><td>name、ID、address、phoneNo</td><td>getName()、setName() 等</td></tr><tr><td>├─ <strong>Customer</strong>（客户类）</td><td>Person</td><td>Rental（1对多）</td><td>编号、证件号、联系方式、租赁历史记录</td><td>提交预定申请()、查询租赁记录()</td></tr><tr><td>└── <strong>Employee（抽象类-员工）</strong></td><td>Person</td><td>无</td><td>编号、岗位、电话、账号密码</td><td>登录()、操作功能（由子类具体实现）</td></tr><tr><td>├── <strong><em>\</em>Admin**</strong>（<strong>管理员</strong>）</td><td>Employee</td><td>无</td><td>是否为高级管理员</td><td>添加员工()、添加车辆()</td></tr><tr><td>├── <strong>CommonWorker</strong>（一般员工-客服）</td><td>Employee</td><td>无</td><td>处理租赁流程</td><td>处理预定()、处理还车()</td></tr><tr><td>└── <strong>SkillWorker</strong>（技术人员）</td><td>Employee</td><td>ServiceRecord（1对多）</td><td>技能项、资格证书、服务记录</td><td>填写服务记录()</td></tr><tr><td><strong>Vehicle</strong>（车辆类）</td><td>-</td><td>Rental、ServiceRecord</td><td>编号、车牌、品牌、类型、状态、租金、维修记录</td><td>更新状态()、计算租金()</td></tr><tr><td><strong>Rental</strong>（租赁类）</td><td>-</td><td>Customer、Vehicle</td><td>租赁编号、客户编号、车辆编号、起止日期、费用、状态</td><td>创建租赁记录()、计算费用()</td></tr><tr><td><strong>ServiceRecord</strong>（服务记录类）</td><td>-</td><td>Vehicle、SkillWorker</td><td>服务编号、车辆编号、技术员编号、检查时间、状况、建议维修</td><td>提交服务记录()</td></tr></tbody></table></div><p><strong>思路：分两个类图画，一个客户及公司员工类图，一个汽车租赁系统类图</strong></p><h2 id="4-时序图设计"><a href="#4-时序图设计" class="headerlink" title="4.时序图设计"></a>4.时序图设计</h2><p>展示“对象间在某个业务过程中的交互顺序”。</p><p>时序图（Sequence Diagram）用于展示<strong>对象之间在某一用例中的交互过程</strong>，关注消息发送顺序。</p><p>基本元素包括：</p><ul><li><strong>参与对象（Actor 或类的实例）</strong>：上方水平排列</li><li><strong>生命线（Lifeline）</strong>：垂直虚线，表示对象的存活期</li><li><strong>消息（Message）</strong>：对象之间发送的请求，用箭头标示，按时间从上到下</li></ul><h3 id="（1）管理员查看工作记录时序图"><a href="#（1）管理员查看工作记录时序图" class="headerlink" title="（1）管理员查看工作记录时序图"></a>（1）管理员查看工作记录时序图</h3><p>该图描述了管理员在系统中查看普通工作人员的工作记录及其任务完成率的流程。该操作用于管理监督和绩效评估。</p><p><strong>参与对象</strong>：</p><ul><li><code>管理员</code>（Admin）</li><li><code>普通工作人员</code>（CommonWorker）</li><li><code>服务记录</code>（ServiceRecord）</li></ul><p><strong>交互顺序</strong>：</p><ol><li>管理员可根据任务情况进行评估与记录。</li><li><code>Admin</code> 登录系统并进入“员工管理”功能界面；</li><li>系统展示可查询员工列表；</li><li><code>Admin</code> 选定某位 <code>CommonWorker</code>，调用其方法 <code>查看工作记录()</code>；</li><li><code>CommonWorker</code> 返回其历史 <code>ServiceRecord</code>；</li><li><code>Admin</code> 要求评估任务完成情况，调用 <code>calculate()</code> 方法计算 <code>commissionRate</code>；</li><li><code>CommonWorker</code> 返回任务完成率给 <code>Admin</code>；</li></ol><h3 id="（2）客户预订车辆时序图"><a href="#（2）客户预订车辆时序图" class="headerlink" title="（2）客户预订车辆时序图"></a><strong>（2）客户预订车辆时序图</strong></h3><p>该图描述了客户通过系统发起租车申请并由工作人员处理的全过程。</p><p><strong>参与对象</strong>：</p><ul><li><code>客户</code>（Customer）</li><li><code>普通工作人员</code>（CommonWorker）</li><li><code>车辆</code>（Vehicle）</li><li><code>租赁记录</code>（Rental）</li></ul><p><strong>交互顺序</strong>：</p><blockquote><ol><li><code>Customer</code> 填写并提交租赁申请（调用 <code>提交预定申请()</code> 方法）；</li><li><code>CommonWorker</code> 接收申请并调用 <code>处理预定()</code> ；</li><li><code>CommonWorker</code> 通过 <code>Vehicle</code> 查询所需车型是否可租（调用 <code>更新状态()</code>、查询 <code>当前状态</code> 属性）；</li><li>若车辆空闲，则创建一个新的 <code>Rental</code> 实例；</li><li><code>Rental</code> 记录客户、车辆、起止时间等信息，并由 <code>CommonWorker</code> 完成预定处理；</li><li>返回预定结果给 <code>Customer</code>。</li></ol></blockquote><h3 id="（3）客户取车时序图"><a href="#（3）客户取车时序图" class="headerlink" title="（3）客户取车时序图"></a><strong>（3）客户取车时序图</strong></h3><p>该图展示了客户在预定成功后前往门店取车的业务流程。涉及对租赁状态确认、付款、车辆状态更新等关键操作。</p><p><strong>参与对象</strong>：</p><ul><li><code>客户</code>（Customer）</li><li><code>普通工作人员</code>（CommonWorker）</li><li><code>车辆</code>（Vehicle）</li><li><code>租赁记录</code>（Rental）</li><li><code>服务记录</code>（ServiceRecord`）（填写工作记录）</li></ul><p><strong>交互顺序</strong>：</p><ol><li><code>Customer</code> 按约定时间到店取车；</li><li><code>CommonWorker</code> 校验客户的身份和租赁状态；</li><li>若验证成功，提示 <code>Customer</code> 进行付款；</li><li>付款完成后，<code>CommonWorker</code> 填写 <code>ServiceRecord</code>（调用 <code>填写服务记录()</code> 方法，记录取车信息）；</li><li><code>CommonWorker</code> 调用 <code>Vehicle</code> 类方法 <code>更新状态()</code>，将车辆状态更新为“租赁中”；</li><li><code>Rental</code> 对象状态设置为“进行中”，系统完成租赁激活；</li><li>系统通知客户取车完成。</li></ol><h3 id="（4）客户还车时序图"><a href="#（4）客户还车时序图" class="headerlink" title="（4）客户还车时序图"></a><strong>（4）客户还车时序图</strong></h3><p>该图展示了客户完成用车后归还车辆的完整流程，包括车辆检查、费用结算、服务记录填写、状态更新等操作。</p><p><strong>参与对象</strong>：</p><ul><li><code>客户</code>（Customer）</li><li><code>普通工作人员</code>（CommonWorker）</li><li><code>技术人员</code>（SkillWorker）</li><li><code>车辆</code>（Vehicle）</li><li><code>租赁记录</code>（Rental）</li><li><code>服务记录</code>（ServiceRecord`）</li></ul><p><strong>交互顺序</strong>：</p><ol><li>Customer 按约定时间归还车辆；</li><li>SkillWorker 对 Vehicle 进行检查，确认车况并调用 填写服务记录()；</li><li>若车辆存在损坏，记录在 ServiceRecord 中，并提交维修建议；</li><li>CommonWorker 根据 Rental 中的起止时间与车辆状态，计算费用（调用 计算费用() 方法）；</li><li>若有损坏或违章，额外费用一并计算；</li><li>Vehicle 状态通过 更新状态() 方法设为“空闲”或“维护中”；</li><li>Rental 状态设为“已完成”，交易结束；</li></ol><h2 id="5-协作图设计"><a href="#5-协作图设计" class="headerlink" title="5.协作图设计"></a>5.协作图设计</h2><p>协作图（Collaboration Diagram）用于描述在某个用例场景中，参与对象之间为了完成任务所进行的交互行为。它重点突出对象之间的<strong>结构关系</strong>与<strong>消息传递顺序</strong>。</p><p>本系统协作图设计覆盖三个典型场景：</p><h3 id="（1）客户预订车辆协作图"><a href="#（1）客户预订车辆协作图" class="headerlink" title="（1）客户预订车辆协作图"></a>（1）客户预订车辆协作图</h3><p>该图描述客户发起租车请求并由系统处理的过程，突出“客户—工作人员—车辆—租赁记录”之间的协作关系。</p><p><strong>参与对象</strong>：</p><ul><li><code>客户</code>（Customer）</li><li><code>普通工作人员</code>（CommonWorker）</li><li><code>车辆</code>（Vehicle）</li><li><code>租赁记录</code>（Rental）</li></ul><p><strong>协作过程</strong>：</p><ol><li><code>Customer</code> 发起租车请求；</li><li><code>CommonWorker</code> 接收并检查请求；</li><li>向 <code>Vehicle</code> 查询当前状态（是否可租）；</li><li>如果可租，生成 <code>Rental</code> 记录并存储租期、费用等信息；</li><li>返回处理结果给 <code>Customer</code>。</li></ol><h3 id="（2）客户取车协作图"><a href="#（2）客户取车协作图" class="headerlink" title="（2）客户取车协作图"></a>（2）客户取车协作图</h3><p>客户在门店取车，由工作人员完成验证、记录与状态更新。</p><p><strong>参与对象</strong>：</p><ul><li><code>客户</code>（Customer）</li><li><code>普通工作人员</code>（CommonWorker）</li><li><code>车辆</code>（Vehicle）</li><li><code>服务记录</code>（ServiceRecord）</li><li><code>租赁记录</code>（Rental）</li></ul><p><strong>协作过程</strong>：</p><ol><li><code>Customer</code> 到达前台，出示身份信息；</li><li><code>CommonWorker</code> 校验信息与租赁状态；</li><li>要求付款并调用 <code>ServiceRecord</code> 填写记录；</li><li>修改 <code>Vehicle</code> 的状态为“租赁中”；</li><li>将 <code>Rental</code> 状态设为“进行中”；</li><li>通知 <code>Customer</code> 成功取车。</li></ol><h3 id="（3）客户还车协作图"><a href="#（3）客户还车协作图" class="headerlink" title="（3）客户还车协作图"></a>（3）客户还车协作图</h3><p>客户完成使用后归还车辆，系统进行检查、结算与状态同步。</p><p><strong>参与对象</strong>：</p><ul><li><code>客户</code>（Customer）</li><li><code>普通工作人员</code>（CommonWorker）</li><li><code>技术人员</code>（SkillWorker）</li><li><code>车辆</code>（Vehicle）</li><li><code>服务记录</code>（ServiceRecord）</li><li><code>租赁记录</code>（Rental）</li></ul><p><strong>协作过程</strong>：</p><ol><li><code>Customer</code> 提交还车；</li><li><code>SkillWorker</code> 检查车辆，填写 <code>ServiceRecord</code>；</li><li><code>CommonWorker</code> 根据 <code>Rental</code> 计算费用；</li><li>如有异常（如车辆损坏），加入额外罚金；</li><li>调用 <code>Vehicle</code> 更新状态为“空闲”或“维护中”；</li><li>更新 <code>Rental</code> 为“已完成”，关闭流程；</li><li>通知 <code>Customer</code> 交易结束。</li></ol><h2 id="6-活动图设计"><a href="#6-活动图设计" class="headerlink" title="6. 活动图设计"></a>6. 活动图设计</h2><p>活动图（Activity Diagram）用于表示系统中某个用例或业务流程的<strong>控制流程</strong>与<strong>状态流转</strong>，强调操作的执行顺序与并发结构。以下选取三个典型业务流程进行建模。</p><h3 id="（1）客户预订车辆活动图"><a href="#（1）客户预订车辆活动图" class="headerlink" title="（1）客户预订车辆活动图"></a>（1）客户预订车辆活动图</h3><p>该图描述了客户租车申请从填写表单到系统生成预定记录的全过程。</p><p><strong>流程说明</strong>：</p><ul><li>初始节点：客户登录系统；</li><li>填写租车申请表（车型、时间等）；</li><li>系统校验字段完整性；</li><li>系统检查该时间段内是否有可租车辆；<ul><li>若无车辆 → 流程结束，提示“预定失败”；</li><li>若有车辆 → 进入下一步；</li></ul></li><li>系统生成预定记录；</li><li>将预定状态设为“待审核”；</li><li>返回“预定提交成功”提示。</li></ul><h3 id="（2）客户取车活动图"><a href="#（2）客户取车活动图" class="headerlink" title="（2）客户取车活动图"></a>（2）客户取车活动图</h3><p>展示客户前往门店领取车辆的完整操作流程。</p><p><strong>流程说明</strong>：</p><ul><li>初始节点：客户到达门店；</li><li>出示身份信息；</li><li>工作人员验证预订状态；<ul><li>若状态异常 → 结束流程，提示“验证失败”；</li><li>若验证成功 → 进入下一步；</li></ul></li><li>系统提示付款；</li><li>客户付款；</li><li>工作人员填写服务记录；</li><li>更新车辆状态为“租赁中”；</li><li>结束流程，客户完成取车。</li></ul><h3 id="（3）客户还车活动图"><a href="#（3）客户还车活动图" class="headerlink" title="（3）客户还车活动图"></a>（3）客户还车活动图</h3><p>描述客户用车结束后归还车辆的业务流程。</p><p><strong>流程说明</strong>：</p><ul><li>初始节点：客户提交还车；</li><li>技术人员进行车辆检查；</li><li>系统记录服务检查结果；</li><li>工作人员根据租期与车况计算费用；</li><li>客户付款（含额外罚金）；</li><li>系统更新车辆状态（空闲/维护中）；</li><li>租赁记录设为“已完成”；</li><li>流程终止。</li></ul><h2 id="7-状态图设计"><a href="#7-状态图设计" class="headerlink" title="7. 状态图设计"></a>7. 状态图设计</h2><p>状态图（State Diagram）用于描述系统中某一对象在生命周期中所经历的<strong>状态变迁</strong>，以及引起这些状态变化的事件或条件。它对于理解对象行为及其触发逻辑尤为重要。</p><p>本系统重点绘制以下两个状态图：</p><h3 id="（1）车辆（Vehicle）状态图"><a href="#（1）车辆（Vehicle）状态图" class="headerlink" title="（1）车辆（Vehicle）状态图"></a>（1）车辆（Vehicle）状态图</h3><p>车辆在租赁生命周期中会经历多个状态变化，状态图可清晰展示其状态切换逻辑。</p><p><strong>状态节点</strong>：</p><ul><li>空闲（Idle）</li><li>已预定（Reserved）</li><li>租赁中（Rented）</li><li>检修中（Under Maintenance）</li></ul><p><strong>触发事件</strong>：</p><ul><li>客户提交预定申请 → 状态由“空闲”变为“已预定”</li><li>客户取车 → 状态变为“租赁中”</li><li>客户还车后车辆正常 → 状态变为“空闲”</li><li>客户还车后车辆损坏 → 状态变为“检修中”</li><li>检修完毕 → 状态恢复为“空闲”</li></ul><h3 id="（2）租赁记录（Rental）状态图"><a href="#（2）租赁记录（Rental）状态图" class="headerlink" title="（2）租赁记录（Rental）状态图"></a>（2）租赁记录（Rental）状态图</h3><p><code>Rental</code> 对象代表一次租赁交易，其状态流转反映交易的执行进度与完成情况。</p><p><strong>状态节点</strong>：</p><ul><li>待审核（Pending）</li><li>已批准（Approved）</li><li>进行中（Ongoing）</li><li>已完成（Completed）</li><li>被拒绝（Rejected）</li></ul><p><strong>触发事件</strong>：</p><ul><li>用户提交申请 → 状态设为“待审核”</li><li>工作人员审核通过 → 状态变为“已批准”</li><li>客户取车后 → 状态设为“进行中”</li><li>客户还车并结算完成 → 状态设为“已完成”</li><li>审核不通过 → 状态变为“被拒绝”</li></ul><p>以下附上实验报告</p><p><a href="https://www.legendkiller.xyz/wp-content/uploads/2025/05/计本2204-202214024112-王磊-1-3.doc">计本2204 202214024112 王磊</a><a href="https://www.legendkiller.xyz/wp-content/uploads/2025/05/计本2204-202214024112-王磊-1-3.doc">下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六级生词</title>
      <link href="/posts/3.html"/>
      <url>/posts/3.html</url>
      
        <content type="html"><![CDATA[<p>radiate 散发</p><p>herd 兽群</p><p>immerse 沉浸于</p><p>consent 同意</p><p>manipulate 暗中操作</p><p>relentless 不停的，持续的</p><p>fluctuate 波动</p><p>exotic 异国风情的，外来的</p><p>census 官方统计</p><p>simultaneous 同步的，同时存在</p><p>hinge 铰链</p><p>inevitable 不可避免的</p><p>impair 削弱</p><p>saturate 浸透，使饱和</p><p>crawl 爬行</p><p>retail 零售</p><p>insurance 保险</p><p>device 想出</p><p>dynamic 动态的，充满活力的</p><p>fiscal 财政的</p><p>patrol 巡逻</p><p>scrape 刮掉</p><p>pasture 牧场</p><p>metropolitan 大城市的</p><p>explicit 清楚的</p><p>institution 机构，习俗</p><p>crack 破裂</p><p>incorporate 包含，并入</p><p>conserve 节约</p><p>lever 操纵杆</p><p>utter 完全的</p><p>preliminary 初步的</p><p>harsh 严厉的</p><p>illuminate 照亮</p><p>ascend 上升</p><p>decay 腐烂</p><p>bizarre 奇异的，古怪的</p><p>sensitive 体贴的</p><p>diagnose 诊断</p><p>authentic 真品的</p><p>substantial 大量的</p><p>destined 命中注定的</p><p>contrive 设法做到</p><p>feeble虚弱无力的</p><p>cater 满足，迎合</p><p>catastrophe 重大灾难</p><p>correlate 相互关联</p><p>torture 拷打</p><p>perish 死亡</p><p>fragile 易碎的</p><p>peculiar 古怪的，奇怪的</p><p>cruise 乘船游览</p><p>parliament 议会</p><p>perpetual 长久的</p><p>reckless 鲁莽的</p><p>calorie 卡路里</p><p>intrigue 激起……兴趣</p><p>assemble 集合</p><p>estimate 估计</p><p>impulse 冲动</p><p>eligible 有资格的</p><p>deliver发表</p><p>avert防止</p><p>glitter 闪亮</p><p>consensus 一致看法</p><p>versus 与……相比</p><p>fabricate 捏造</p><p>tumble 跌倒</p><p>lure 引诱</p><p>spectrum 光谱，系列</p><p>aviation 航空</p><p>extinct 已灭绝的</p><p>tremendous 巨大的</p><p>priest 牧师</p><p>unveil 公布</p><p>renowned 有名的</p><p>signify 表示</p><p>designate 指定</p><p>insulate 使隔热，使隔音</p><p>inferior 较差的</p><p>proclaim 宣布，声明</p><p>vigorous 精力旺盛的</p><p>candidate 候选人</p><p>greed 贪婪</p><p>imperial 帝国的</p><p>inhibit 抑制</p><p>revolve 旋转</p><p>temperament 气质</p><p>corporate 公司的</p><p>substitute 代替者</p><p>compliment 称赞</p><p>contradict 反驳</p><p>fragile 易碎的</p><p>scare 缺乏的</p><p>ultimate 最终的</p><p>escalate 扩大</p><p>adolescent 青少年</p><p>mediate 调停</p><p>stroke 一击</p><p>collaboration 合作</p><p>monetary 货币的</p><p>clinic 诊所</p><p>suicide 自杀</p><p>interpret 解释，说明</p><p>conspicuous 易见的</p><p>evacuate 撤离</p><p>evoke 引起</p><p>profitable 盈利的</p><p>counsel 忠告，建议</p><p>aggressive 好斗的</p><p>pitch 球场</p><p>fatigue 疲惫的</p><p>legitimate 合法的</p><p>tropical 热带的</p><p>perceive 看待</p><p>prototype 原型</p><p>derail 脱轨</p><p>deficit 亏损</p><p>contract 合同</p><p>institute n.机构 v. 建立</p><p>catastrophe 重大灾难</p><p>recreation 娱乐</p><p>veteran 有经验的人，老手</p><p>eject 驱逐</p><p>plight 困境</p><p>ascribe 将…归因于</p><p>poll 民意调查</p><p>indigenous 当地的</p><p>advisable 明智的</p><p>chronic 慢性的</p><p>external 外部的</p><p>momentum 势头</p><p>gloomy 昏暗的</p><p>ingenious 精巧的</p><p>stagger 蹒跚</p><p>arrogant 傲慢的</p><p>exclude 将……排斥在外</p><p>retrieve 取回</p><p>workship 崇拜</p><p>biography 人物传记</p><p>ambiguous 模棱两可的</p><p>dispatch 派遣</p><p>concede 承认……属实</p><p>neutral 中立的</p><p>strive 努力</p><p>speculate 猜测</p><p>inventory 存货</p><p>coordinate 使……协调</p><p>dazzle 使目眩</p><p>transient 短暂的</p><p>ferry 渡船</p><p>lawsuit 诉讼</p><p>depict 描绘</p><p>fascinate 使着迷</p><p>moan 呻吟</p><p>dimension 尺寸</p><p>sway 摇摆</p><p>academic 学术的</p><p>applause 鼓掌</p><p>dictate 口述，命令</p><p>quote 引用</p><p>circulation 血液循环</p><p>ration 定量供应</p><p>odd 奇怪的</p><p>indicate 声明，暗示</p><p>eliminate 消除</p><p>municipal 城市的</p><p>migrate 迁移</p><p>rigor 严谨</p><p>merit 优秀品质</p><p>warrant 授权令，使合理</p><p>scenario 设想</p><p>exempt 被免除</p><p>coalition 联合体，联盟</p><p>expire 到期</p><p>coincide 同时发生</p><p>propel 推动</p><p>execute 执行</p><p>rage 暴怒</p><p>refine 提炼</p><p>rash 轻率的</p><p>cater 提供饮食，迎合</p><p>induce 引诱</p><p>permeate 渗透</p><p>spontaneous 自发的</p><p>robust 强健的</p><p>blend 融合</p><p>colonial 殖民地的</p><p>pedestrian 行人</p><p>antibiotic 抗生素的</p><p>simulate 假装</p><p>flee 逃离</p><p>hurricane 飓风</p><p>recipient 接受者</p><p>controversy 争论</p><p>confer 授予</p><p>refer 涉及</p><p>infer 推断</p><p>shuttle 航天飞机</p><p>intrinsic 本质的</p><p>sentiment 情绪</p><p>inquire询问</p><p>require需要</p><p>acquire获得</p><p>enquire询问</p><p>diligent 勤奋的</p><p>segregate 隔离</p><p>shatter 破碎</p><p>epidemic 流行病</p><p>enterprise 企业</p><p>viable 可行的</p><p>precise 精确的</p><p>manifest 显示，表明</p><p>esteem 尊重</p><p>premium 保险费</p><p>spectacle 眼睛，奇特的现象</p><p>prejudice 偏见</p><p>setback 挫折</p><p>buck 美元，抵制</p><p>drastic 严厉的</p><p>offspring 子女，后代</p><p>acquaint 使熟悉</p><p>demography 人口学的</p><p>nonetheless 尽管如此</p><p>scrutiny 彻底审查</p><p>disclose 透露</p><p>magnitude 巨大</p><p>retort 反驳</p><p>session 一场</p><p>therapy 疗法</p><p>predecessor 前任</p><p>formula 公式</p><p>ward 病房</p><p>expel 开除</p><p>gadget 小器具</p><p>pension 养老金</p><p>prosper 兴旺</p><p>fraud 诈骗</p><p>supervisor 监督者</p><p>toll 伤亡人数</p><p>descend 下来，下降</p><p>enormous 巨大的</p><p>furnish 布置</p><p>incentive 激励</p><p>refute 反驳</p><p>negotiate谈判</p><p>aggravate 加重</p><p>terminate 结束，终止</p><p>enlighten 启发</p><p>inertia 惯性</p><p>skeptical 怀疑的</p><p>chunk 厚块</p><p>brew 啤酒，酝酿</p><p>duplicate 复制</p><p>assess 评估</p><p>sake目的</p><p>narrative 叙事</p><p>purchase 购买</p><p>magnify放大</p><p>severe 严重的</p><p>installment 一期</p><p>assert 断言</p><p>boom 繁荣</p><p>hectic 忙碌的</p><p>dismay 使担心，使失望</p><p>democratic 民主的</p><p>justify 证明</p><p>conflict 冲突</p><p>dilemma 窘境，困境</p><p>peculiar 古怪的</p><p>tenant 房客</p><p>ascertain 弄清</p><p>heir继承人</p><p>chamber 房间，议院</p><p>detain 拘留</p><p>greedy 贪婪的</p><p>resort 求助</p><p>migrant 移民者</p><p>weird 古怪的</p><p>crucial 至关重要的</p><p>moreover 而且</p><p>agony 极度痛苦的</p><p>demonstrate 表明，证明</p><p>graphic 绘画的</p><p>vaccine 疫苗</p><p>cruise 乘船浏览</p><p>rational 合理的</p><p>domestic 国内的</p><p>accurate 准确的</p><p>ethnic 种族的</p><p>conducive 有助于的</p><p>remedy 解决方法</p><p>collide 碰撞</p><p>cripple 瘸子</p><p>livestock 牲畜</p><p>disgust 厌恶</p><p>envisage 设想</p><p>inherent 内在的</p><p>solemn 严肃的</p><p>concise 简洁的</p><p>condemn 谴责</p><p>augment增大</p><p>obedient 服从的</p><p>lane 小路</p><p>maneuver 策略</p><p>portray描述</p><p>surgeon 外科医生</p><p>forge 建立</p><p>reconcile 使和谐一致</p><p>liberal 自由的</p><p>accommodation 住宿</p><p>implement 履行</p><p>internal 国内的</p><p>navigate导航</p><p>mortgage 抵押</p><p>accessory 配件</p><p>executive 经理</p><p>exile 流行</p><p>dividend 红利</p><p>regulation 规章</p><p>correlate 相互关联</p><p>instruct 指示</p><p>kit 成套工具</p><p>arrogance 傲慢</p><p>unprecedented 史无前例的</p><p>swell 肿胀</p><p>amend 修订</p><p>extract 提取</p><p>intimate 亲密的</p><p>devastate 彻底破坏</p><p>withdraw 撤回</p><p>graze 吃青草</p><p>grope 摸索，寻找</p><p>distracted 注意力分散的</p><p>obscure 难以理解的，掩盖</p><p>subordinate 下级，下属</p><p>contaminate 弄脏，污染</p><p>retreat 撤退</p><p>cherish 珍爱</p><p>conscience 良心</p><p>erupt 火山爆发</p><p>subtle 细微的</p><p>unleash 释放</p><p>endorse 公开支持</p><p>flaw 瑕疵</p><p>publicity 关注</p><p>endurance 耐力</p><p>fabric 织物</p><p>discriminate 歧视</p><p>peer 同龄人</p><p>subsidy 补贴</p><p>prime 首要的</p><p>compatible 兼容的</p><p>facet 部分</p><p>bleak 没有希望的</p><p>scatter 散开，播撒</p><p>revive 苏醒</p><p>irritate 使烦躁</p><p>maturity 成熟</p><p>plausible 貌似合理的</p><p>trivial 琐碎的</p><p>circuit 电路</p><p>galaxy 星系</p><p>deplete 大量消耗</p><p>preception 理解</p><p>loyalty 忠诚</p><p>violate 违反</p><p>adhere 黏附</p><p>paradox 矛盾的人，悖论</p><p>presume 推测</p><p>quit 辞去</p><p>irrational 不合理的</p><p>notion 观念</p><p>guard 卫兵，看守</p><p>baffle 使…困惑</p><p>dub 将…戏称为</p><p>institution 机构</p><p>superior 更好的，上级</p><p>contest 比赛</p><p>amplify 放大</p><p>deduce 推断</p><p>dignity 尊严，自尊</p><p>monopoly 垄断</p><p>cognitive 认识的</p><p>episode 一段经历</p><p>exclusive 独占的</p><p>jerk 猛拽</p><p>commute 上下班往返</p><p>conceive 想象</p><p>undermine 逐渐削弱</p><p>comply 服从</p><p>sophisticated 精密的，见多识广的，老练的</p><p>malicious 恶毒的</p><p>guardian 监护人</p><p>multitude 众多</p><p>nurture 培养</p><p>proposition 提议</p><p>diesel 柴油</p><p>articulate 清楚地表达</p><p>precedent 先例</p><p>infinite 无限的</p><p>consolidate 加强</p><p>boost 使增长</p><p>relay 传递</p><p>downside 缺点</p><p>distinct 截然不同的</p><p>allege 断言</p><p>allocate 分配</p><p>ponder 沉思</p><p>sanctuary 禁猎区</p><p>vicinity 周围地区</p><p>initial 开始的，最初的</p><p>contempt 鄙视</p><p>overwhelm 击败</p><p>territory 领土</p><p>trillion 一万亿</p><p>outdated 过时的</p><p>real estate 房地产</p><p>specify 具体指明</p><p>delicate 微妙的</p><p>blunt 钝的</p><p>deprive 剥夺</p><p>declaration 宣布</p><p>barrel 桶</p><p>equation 等式</p><p>oppress 压迫</p><p>flourish 繁荣</p><p>handicap 生理缺陷</p><p>extravagant 奢侈的</p><p>erase 消除</p><p>brisk 轻快的</p><p>negligible 微不足道的</p><p>addict 瘾君子</p><p>continent 洲，大陆</p><p>patent 专利权</p><p>recession 经济衰退</p><p>rival 竞争者</p><p>detach 摆脱</p><p>integral 必不可少的</p><p>endow 捐款</p><p>immune 免疫的</p><p>wipe out 彻底消灭</p><p>implicit 含蓄的</p><p>render 使变得</p><p>prevail 盛行</p><p>slump 暴跌</p><p>disrupt 使中断</p><p>deteriorate 恶化</p><p>stake 股份</p><p>consecutive 连续的</p><p>turbulent 动荡的</p><p>anticipate 预料</p><p>via经过</p><p>startle 使…吓一跳</p><p>quota 限额</p><p>literal 字面上的</p><p>penalty 罚金</p><p>eccentric 古怪的</p><p>prospective 潜在的</p><p>plunge 暴跌</p><p>neglect 疏忽</p><p>stimulus 刺激物</p><p>intricate 错综复杂的</p><p>occasional 偶尔的</p><p>hierarchy 等级制度</p><p>scholarly 学术的</p><p>protein 蛋白质</p><p>evaporate 蒸发</p><p>outset 开始</p><p>tuition 教授</p><p>intimidate 恐吓</p><p>pharmacy 病房</p><p>optic 眼的，视力的</p><p>memorial 纪念碑</p><p>intuition 直觉</p><p>prestige 威信</p><p>trait 特征</p><p>mourn 哀悼</p><p>enroll 使加入，招收</p><p>bureau 局，司，处，办事处</p><p>milestone 里程碑</p><p>tangle 缠结在一起</p><p>cast 扔</p><p>involved 卷入的</p><p>obsess 使痴迷</p><p>stun 使震惊</p><p>toss 扔</p><p>justification 正当理由</p><p>integrity 正直</p><p>dedicate 献身</p><p>parliament 议会</p><p>beam 光束</p><p>assure 确保</p><p>navigation 导航</p><p>endeavor 努力</p><p>scope 范围</p><p>multiple 多个的</p><p>prominent 杰出的</p><p>luxury 奢侈</p><p>impractical 不切实际的</p><p>insight 洞悉，洞察力</p><p>deposit 存款</p><p>emulate 效仿</p><p>subsidiary 辅助的，次要的</p><p>drown 溺死</p><p>rein 控制</p><p>jeopardize 使处于危险境地，危及</p><p>proof 证据</p><p>formulate 规划</p><p>thermal 热的，热量的</p><p>curriculum 课程</p><p>prevalent 流行的</p><p>antique 古董</p><p>contemplate 打算，考虑</p><p>capture 抓住</p><p>elevate 提拔</p><p>debris 残骸</p><p>paradise 天堂</p><p>slack 懈怠的，松弛的</p><p>hazard 危险</p><p>senator 参议员</p><p>exert 施加</p><p>haunt 萦绕，长期困扰</p><p>mutual 相互的</p><p>ornament 装饰品</p><p>confront 直面，正视</p><p>slight 轻微的</p><p>incur 招致</p><p>sculpture 雕像</p><p>bare 赤裸的，荒芜的</p><p>irrigate 灌溉</p><p>vacant 空的</p><p>reproach 责备</p><p>twist 弯曲变形</p><p>routine 惯例，常规</p><p>reassure 使安心</p><p>descendant 后代，后裔</p><p>barren 贫瘠的，荒芜的</p><p>rescue 营救</p><p>grim 严肃的，令人沮丧的</p><p>negotiation 谈判</p><p>guilt 内疚</p><p>industrial 工业的</p><p>hijack 劫持，控制</p><p>overstate 夸大</p><p>porch 门廊</p><p>analogy 类比</p><p>vulnerable 脆弱的</p><p>assumption 假设</p><p>contradiction 矛盾</p><p>intend 计划打算</p><p>humane 人道的</p><p>fossil 化石</p><p>statue 雕像</p><p>alter 警觉的</p><p>transplant 移植</p><p>temptation 引诱</p><p>solitude 独处</p><p>eager 热切的</p><p>alternate 交替的</p><p>resign 辞职</p><p>curb 控制</p><p>revenge 报复</p><p>assault 攻击</p><p>liable 可能做…的</p><p>hatch 孵化</p><p>cable 电缆</p><p>pest 害虫</p><p>surge 激增</p><p>nominal 象征性的，名义上的</p><p>settlement 协议，和解</p><p>frontier 边界</p><p>concrete 确实的，具体的</p><p>summon 召唤</p><p>embark 从事，着手</p><p>occupation 职业</p><p>abrupt 突然的，意外的</p><p>reluctant 勉强的</p><p>crush 捣碎，压碎</p><p>dominant 占支配地位的</p><p>compensate 弥补，补偿</p><p>instrument 仪器，乐器</p><p>stance 态度，立场</p><p>commerce 商业，贸易</p><p>corrupt 腐败的，不道德的</p><p>redundant 多余的</p><p>jungle 热带丛林</p><p>stabilize 稳定</p><p>embed 使…嵌入</p><p>literature 文学作品</p><p>commence 开始，着手</p><p>surpass 超过</p><p>destiny 命运</p><p>comprehensive 全面的，综合性的</p><p>resume 继续，简历</p><p>synthetic 合成的，人造的</p><p>sufficient 充足的</p><p>soar 升空，猛增</p><p>bias 偏见</p><p>degrade 有辱…的人格</p><p>conference 会议</p><p>underestimate 低估</p><p>disorder 失调，紊乱</p><p>tough 艰难的</p><p>interact 互动</p><p>preserve 维护</p><p>devastating 毁灭性的</p><p>hemisphere 半球</p><p>appliance 装置，家电</p><p>autonomy 自治权</p><p>dwell 居住</p><p>stimulate 刺激，激发</p><p>intent 意图，目的</p><p>pessimistic 悲观的</p><p>superiority 优越</p><p>jury 陪审团</p><p>given 指定的</p><p>notorious 臭名昭著的</p><p>considerable 相当多的</p><p>compact 紧凑的</p><p>carton 硬纸盒</p><p>freight 货物</p><p>choke 窒息</p><p>fuss 紧张不安</p><p>entertain 使快乐，娱乐</p><p>prolong 延长</p><p>criterion 标准</p><p>tactic 策略</p><p>hypothesis 假说</p><p>consult 向…咨询，求救</p><p>imperative 紧急的</p><p>bonus 奖金</p><p>incidentally 顺便提一下，偶然地</p><p>regardless 不管，无论如何</p><p>surgery 外科手术</p><p>massive 巨大的</p><p>consistent 一贯的</p><p>collision 碰撞</p><p>resemble 看起来像</p><p>breakthrough 突破</p><p>federal 联邦制的</p><p>illustrate 说明</p><p>distinctive 独特的，有特色的</p><p>responsive 反应敏捷的</p><p>excess 过多</p><p>casualty 伤亡人员</p><p>testify 作证</p><p>specialise 专门从事</p><p>delegate 代表</p><p>solidarity 团结一致</p><p>drill 钻机，演习</p><p>transaction 交易，业务</p><p>immigrant 移民</p><p>generalize 概括，归纳</p><p>sober 冷静的</p><p>impetus 动力，促进</p><p>benign 和善的，良性的</p><p>reserve 预订，预约</p><p>triumph 成功，胜利</p><p>likelihood 可能性</p><p>contact 联系</p><p>malignant 恶意的，恶性的</p><p>liability 责任</p><p>renew 延长</p><p>authority 权威，权力</p><p>browse 浏览，吃草</p><p>mentor 导师</p><p>innocent 无罪的</p><p>repel 驱逐，赶走</p><p>distress 悲伤，忧虑</p><p>obese 病态肥胖的，臃肿的</p><p>vegetation 植被</p><p>discharge 排出，解雇</p><p>interaction 互动</p><p>ideal 理想的</p><p>suppress 镇压，压抑</p><p>illiterate 文盲</p><p>paralyze 使瘫痪</p><p>plentiful 丰富的</p><p>destined 命中注定的</p><p>discrepancy 差异</p><p>conception 构思，概念</p><p>recognition 认出，识别</p><p>affiliate 使隶属于，使紧密联系</p><p>conscientious 认真的，勤勤恳恳</p><p>manual 人力的，体力的</p><p>minister 部长，大臣</p><p>oppose 反对</p><p>distort 使变形，使扭曲</p><p>deploy 部署</p><p>intelligible 可理解的</p><p>intermittent 间歇的，断断续续的</p><p>formidable 令人敬畏的</p><p>indifferent 不感兴趣的</p><p>denial 否认</p><p>phase 阶段</p><p>substantial 大量的</p><p>pause 暂停</p><p>drought 干旱</p><p>sustainable 可持续的</p><p>intangible 无形的，难以描述地</p><p>expedition 远征，探险</p><p>indulge 沉迷，满足</p><p>quest 探索，寻求</p><p>disastrous 灾难性的</p><p>sensation 知觉，感觉能力</p><p>observe 观察</p><p>resent 怨恨，憎恶</p><p>disguise 装扮，假扮</p><p>feasible 可行的</p><p>provoke 激起</p><p>accumulate 积累</p><p>assurance 担保，保证</p><p>tackle 处理</p><p>feeble 虚弱无力的</p><p>pursuit 追求</p><p>accuse 职责</p><p>compile 汇编</p><p>cabinet 储藏柜</p><p>objection 反对</p><p>engage 从事，参加</p><p>vast 巨大的</p><p>preside 主持</p><p>suspicion 怀疑</p><p>particle 微粒，粒子</p><p>subsistence 勉强生存</p><p>racial 种族间的，种族的</p><p>persistence 毅力</p><p>blaze 闪耀</p><p>convene 召集，召开</p><p>console 安慰，控制台</p><p>transition 过渡，转变</p><p>competence 能力，才干</p><p>hostile 敌意的，反对的</p><p>erect 建造</p><p>haze 烟雾</p><p>authorize 批准，授权</p><p>alternative 可代替的</p><p>consultant 顾问</p><p>perference 偏好</p><p>pole 杆子，地级</p><p>prescribe 开药，规定</p><p>populate 居住于</p><p>drawback 缺点，不利条件</p><p>morality 道德</p><p>ritual 仪式</p><p>genetic 遗传的，基因的</p><p>ingredient 配料，成分，因素</p><p>layer 层</p><p>transcend 超出，超越</p><p>plate 盘</p><p>angle 角度</p><p>spotlight 聚光灯</p><p>eternal 永恒的</p><p>successive 连续的</p><p>separate 单独的</p><p>promising 大有希望的</p><p>sequence 一系列</p><p>priority 优先权</p><p>compel 强迫，逼迫</p><p>implication 暗示，可能的影响</p><p>prosperity 兴旺</p><p>sneak 偷偷地走，潜行</p><p>concession 让步，认输</p><p>hamper 妨碍，阻碍</p><p>initiate 开始，发起</p><p>essence 本质</p><p>contrive 设法做到，图谋</p><p>instinct 本能</p><p>identical 完全相同的</p><p>protest 抗议，反对</p><p>conformity 遵从，遵守</p><p>deliberate 故意的</p><p>luminous 发亮的，发光的</p><p>plead 恳求</p><p>outbreak 爆发</p><p>fraction 少量，一点儿</p><p>derive 起源于，来自</p><p>elastic 有弹性的</p><p>mislead 误导</p><p>engagement 订婚，参加</p><p>reliance 依赖，依靠</p><p>polar 极地的</p><p>prescription 处方</p><p>cumulative 累加的</p><p>commodity 商品</p><p>revelation 揭露</p><p>strike 罢工，打，击</p><p>reservation 预订</p><p>encounter 遭遇</p><p>dispose 丢掉</p><p>bypass 旁道</p><p>combat 战斗，搏斗</p><p>stick 棍，刺入插入</p><p>stride 大步走，步伐</p><p>glamour 魅力，吸引力</p><p>reap 获得</p><p>layman 外行，门外汉</p><p>polish 改善，润色</p><p>patch 小块，斑点</p><p>perish 死亡</p><p>plea 恳求</p><p>virgin 未开发的，原始状态的</p><p>exceptional 杰出的，非凡的</p><p>rural 乡下的，乡村的</p><p>breed 繁殖，饲养</p><p>threshold 门槛，起始点</p><p>additive 添加剂，添加物</p><p>turnover 营业额</p><p>presumably 很可能</p><p>overturn 推翻</p><p>cease 停止</p><p>elite 精英</p><p>intensive 密集的</p><p>harmonious 和睦的</p><p>circumstance 情况，情形</p><p>persist 顽强坚持，持续</p><p>tease 逗弄</p><p>elicit 引出</p><p>celebrity 名人，明星</p><p>recur 再次发生</p><p>barely 仅仅</p><p>extent 程度</p><p>disregard 不理会</p><p>integrate 合并</p><p>torture 拷打，拷问</p><p>nourish 给…提供营养</p><p>inhabitant 居民</p><p>suspend 暂停，中止</p><p>snap 啪嗒声，断裂</p><p>provocative 挑衅的，煽动的</p><p>autonomous 自治的</p><p>federation 联盟，联合会</p><p>pesticide 杀虫剂</p><p>potency 影响力</p><p>interactive 交互的</p><p>potent 有强效的，烈性的</p><p>deviate 背离，偏离</p><p>specification 规格</p><p>convention 习俗，大会</p><p>specific 明确具体的</p><p>terrify 使害怕，使恐惧</p><p>contention 看法，争论</p><p>vice 恶习，副的次的</p><p>submerge 使浸没，淹没</p><p>opponent 对手，竞争者</p><p>obesity 肥胖</p><p>defy 违抗</p><p>terrific 极好的</p><p>tragedy 不幸，悲剧</p><p>acquaintance 熟人，了解</p><p>detect 发现</p><p>glacier 冰川</p><p>probe 追问</p><p>frantic 发狂似的</p><p>practitioner 从业人员</p><p>fund 基金</p><p>cooperative 合作的</p><p>invoke 唤起，引用</p><p>compulsory 强制性的，义务的</p><p>craftsmanship 手艺</p><p>disposal 丢掉</p><p>intensity 强烈，剧烈</p><p>striking 显著的</p><p>elaborate 复杂的，详尽的</p><p>elementary 基本的</p><p>subsidize 给…发补贴，补助</p><p>disperse 扩散，散开</p><p>underlie 构成…的基础</p><p>storage 储藏</p><p>peak 顶峰</p><p>mechanical 机械的</p><p>likewise 同样地</p><p>testimony 证词</p><p>utilize 利用，使用</p><p>breakdown 故障</p><p>restraint 制止，克制</p><p>quantitative 数量的</p><p>excessive 过多的</p><p>recruit 招收，招聘</p><p>lens 镜片</p><p>strategic 战略性的</p><p>qualitative 质量的</p><p>invariably 总是，不变地</p><p>surgical 外科手术的</p><p>miniature 很小的，微型的</p><p>premises 前提</p><p>headline 重要新闻</p><p>nominate 提名</p><p>urgency 紧急</p><p>marginal 微不足道的</p><p>voyage 航行，航海</p><p>vicious 恶性的，残暴的</p><p>journalist 记者</p><p>misguide 错误地引导</p><p>monitor 监视</p><p>initiative 主动性</p><p>shrink 缩水</p><p>precaution 预防措施</p><p>currency 货币，通货</p><p>questionnaire 调查问卷</p><p>bureaucracy 官僚制度，官僚主义</p><p>crisp 脆的</p><p>expertise 专门技术</p><p>compassion 同情，怜悯</p><p>conventional 传统的</p><p>invisible 看不见的</p><p>compromise 折中，妥协，让步</p><p>heighten 加强，增加</p><p>composer 作曲家</p><p>comprise 包括</p><p>thereby 因此</p><p>exaggerate 夸大</p><p>psychological 心理的</p><p>coverage 新闻报道</p><p>orthodox 正统的</p><p>decent 像样的，得体的</p><p>doom 厄运，使…注定遭受</p><p>specialty 专业</p><p>crude 粗略的</p><p>masterpiece 杰作</p><p>ordeal 折磨，苦难的经历</p><p>intensify 加强</p><p>disposition 性情，布置</p><p>burden 负担</p><p>mechanism 机械装置，方法</p><p>syndrome 综合征</p><p>transmission 传输</p><p>underlying 深层的</p><p>extensive 广阔的</p><p>suspicious 觉得可疑的</p><p>plenty 大量</p><p>inclined 倾向于…的</p><h1 id="六级作文模版"><a href="#六级作文模版" class="headerlink" title="六级作文模版"></a>六级作文模版</h1><h2 id="议论文"><a href="#议论文" class="headerlink" title="议论文"></a>议论文</h2><p>开头 Living in an era of rapid technological development ,and continuous expansion of knowledge,(主题)have/has become increasingly important,which is significantly impacting ( 某人的生活/学校生活/个人经历 ) <strong>生活在技术快速发展、知识不断扩展的时代，sth已经变得越来越重要，这对影响了某人的生活/学校生活/个人经历</strong></p><ul><li><p>当主题是…的影响时： Therefore, it’s of great significance for sb to do sth ，The following reasons can account for this viewpoint. <strong>因此，某人做某事具有重要意义，以下原因可以解释这一观点。</strong></p></li><li><p>当主题是…的重要性时：Therefore,I deem that the (importance of AI …的重要性/要贴近主题) lies in the following aspects <strong>因此，我认为sth的重要性在于以下几个方面</strong></p></li></ul><p>论据+论点</p><ul><li><p>论点1：First and foremost,there is no doubt that （sth can enhance sb work/study efficiency,and offer tremendous convenience in our daily/school life） <strong>首先，毫无疑问（某物可以提高某人的工作/学习效率，为我们的日常/学校生活提供极大的便利）</strong></p></li><li><p>论据1：Based on the investigation of big data(Based on big data research), it can be found that，a majority of (Accomplished individuals) admitted that they’ve spent most of their time doing sth <strong>通过大数据调查可以发现，大多数（成功人士）承认，他们大部分时间都花在做某事上</strong></p></li><li><p>论点2：Moreover,it has formed a consensus that（it has become a general consensus） (by sth can acquire adequate knowledge and experience easily,it is an excellent way for sb to understand what they hope and need) <strong>而且，这已经形成了一个共识，即（通过某事可以轻松获得足够的知识和经验，这是让某人了解他们希望和需要什么的绝佳方式）</strong></p></li><li><p>论点3：Last but not least,I sincerely believe that(by sth can facilitate communication and collaboration,which helpful <strong>in broadening</strong> ours horizons) <strong>最后但同样重要的一点是，我真诚地相信（通过某事可以促进沟通和合作，有助于拓宽我们的视野）</strong></p></li></ul><p>结尾</p><p>In short, the above statement can lead us reach a conclusion <strong>简而言之，通过上述陈述我们可以得出结论</strong></p><p>sth is revolutionizing the way we live,it is predictable that if sb makes reasonable use of sth,the future of sth will be become more beautiful and hopeful <strong>某事物正在彻底改变我们每个人的生活方式，可以预见，如果某人合理地利用某事物，其未来将会变得更加美好和充满希望</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语六级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实战篇</title>
      <link href="/posts/6.html"/>
      <url>/posts/6.html</url>
      
        <content type="html"><![CDATA[<p>导读：实战篇我们要学习一些什么样的内容</p><ul><li>短信登录</li></ul><p>这一块我们会使用redis共享session来实现</p><ul><li>商户查询缓存</li></ul><p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p><ul><li>优惠卷秒杀</li></ul><p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p><ul><li>附近的商户</li></ul><p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p><ul><li>UV统计</li></ul><p>主要是使用Redis来完成统计功能</p><ul><li>用户签到</li></ul><p>使用Redis的BitMap数据统计功能</p><ul><li>好友关注</li></ul><p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p><ul><li>打人探店</li></ul><p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-24-1024x590.png" alt="img"></p><h2 id="1、短信登录"><a href="#1、短信登录" class="headerlink" title="1、短信登录"></a>1、短信登录</h2><h3 id="1-1、导入黑马点评项目"><a href="#1-1、导入黑马点评项目" class="headerlink" title="1.1、导入黑马点评项目"></a>1.1、导入黑马点评项目</h3><h4 id="1-1-1-、导入SQL（Mysql版本大于5-7）"><a href="#1-1-1-、导入SQL（Mysql版本大于5-7）" class="headerlink" title="1.1.1 、导入SQL（Mysql版本大于5.7）"></a>1.1.1 、导入SQL（Mysql版本大于5.7）</h4><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-25.png" alt="img"></p><h4 id="1-1-2、有关当前模型"><a href="#1-1-2、有关当前模型" class="headerlink" title="1.1.2、有关当前模型"></a>1.1.2、有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p><p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-26-1024x432.png" alt="img"></p><p>1.1.3、导入后端项目</p><p>注意要修改application.yaml文件里的mysql，redis地址信息</p><p>1.1.4、导入前端工程</p><p>1.1.5 运行前端项目</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">localhost</span>：<span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-27-1024x494.png" alt="img"></p><h3 id="1-3实现发送短信验证码"><a href="#1-3实现发送短信验证码" class="headerlink" title="1.3实现发送短信验证码"></a>1.3实现发送短信验证码</h3><p><strong>页面流程</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-29-1024x443.png" alt="img"></p><p>具体代码如下</p><ul><li><strong><em>发送验证码\</em></strong></li></ul><p>UserController</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送手机验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@PostMapping</span>(<span class="string">&quot;code&quot;</span>)</span><br><span class="line">public Result <span class="built_in">sendCode</span>(<span class="variable">@RequestParam</span>(<span class="string">&quot;phone&quot;</span>) String phone, HttpSession session) &#123;</span><br><span class="line">    <span class="comment">// TODO 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">userService</span><span class="selector-class">.sendCode</span>(phone, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IUserService</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">phone</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">session</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title class_">Result</span> <span class="title function_">sendCode</span>(<span class="title class_">String</span> phone, <span class="title class_">HttpSession</span> session);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">IUserServiceImpl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送验证码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">phone</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">session</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title class_">Result</span> <span class="title function_">sendCode</span>(<span class="params"><span class="title class_">String</span> phone, <span class="title class_">HttpSession</span> session</span>) &#123;</span><br><span class="line"> <span class="comment">// 1.校验手机号</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="title class_">RegexUtils</span>.<span class="title function_">isPhoneInvalid</span>(phone)) &#123;</span><br><span class="line"> <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Result</span>.<span class="title function_">fail</span>(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line"> <span class="title class_">String</span> code = <span class="title class_">RandomUtil</span>.<span class="title function_">randomNumbers</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line"> session.<span class="title function_">setAttribute</span>(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line"> <span class="comment">// 5.发送验证码</span></span><br><span class="line"> log.<span class="title function_">debug</span>(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line"> <span class="comment">// 返回ok</span></span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Result</span>.<span class="title function_">ok</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong><em>登录\</em></strong></li></ul><p>UserController</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录功能</span></span><br><span class="line"><span class="comment"> * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@PostMapping</span>(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">public Result <span class="built_in">login</span>(<span class="variable">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)&#123;</span><br><span class="line">    <span class="comment">// 实现登录功能</span></span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">userService</span><span class="selector-class">.login</span>(loginForm, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IUserService</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loginForm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IUserServiceImpl</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">loginForm</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">session</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">Result</span> <span class="title function_">login</span>(<span class="params"><span class="title class_">LoginFormDTO</span> loginForm, <span class="title class_">HttpSession</span> session</span>) &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="title class_">String</span> phone = loginForm.<span class="title function_">getPhone</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">RegexUtils</span>.<span class="title function_">isPhoneInvalid</span>(phone)) &#123;</span><br><span class="line">        <span class="comment">//如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Result</span>.<span class="title function_">fail</span>(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.校验验证码</span></span><br><span class="line">    <span class="title class_">Object</span> cacheCode = session.<span class="title function_">getAttribute</span>(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="title class_">String</span> code = loginForm.<span class="title function_">getCode</span>();</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.<span class="title function_">toString</span>().<span class="title function_">equals</span>(code)) &#123;</span><br><span class="line">        <span class="comment">//3.不一致，直接返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Result</span>.<span class="title function_">fail</span>(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">    <span class="title class_">User</span> user = <span class="title function_">query</span>().<span class="title function_">eq</span>(<span class="string">&quot;phone&quot;</span>, phone).<span class="title function_">one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//6。不存在，创建新用户并保存</span></span><br><span class="line">        user = <span class="title function_">createUserWithPhone</span>(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.存在，保存用户到session</span></span><br><span class="line">    session.<span class="title function_">setAttribute</span>(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.返回登录成功的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Result</span>.<span class="title function_">ok</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title class_">User</span> <span class="title function_">createUserWithPhone</span>(<span class="params"><span class="title class_">String</span> phone</span>) &#123;</span><br><span class="line">    <span class="comment">//1.创建用户</span></span><br><span class="line">    <span class="title class_">User</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.<span class="title function_">setPhone</span>(phone);</span><br><span class="line">    user.<span class="title function_">setNickName</span>(<span class="variable constant_">USER_NICK_NAME_PREFIX</span>+<span class="title class_">RandomUtil</span>.<span class="title function_">randomString</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">//2.保存用户到数据库 insert into tb_user values (null, ?, null)</span></span><br><span class="line">    <span class="title function_">save</span>(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-显示登录拦截"><a href="#1-4-显示登录拦截" class="headerlink" title="1.4 显示登录拦截"></a>1.4 显示登录拦截</h3><p><strong>tomcat的运行原理</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-53-1024x599.png" alt="img"></p><h4 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1. 建立连接"></a><strong>1. 建立连接</strong></h4><ul><li><strong>用户（客户端）</strong> 发起一个 HTTP 请求，首先会通过浏览器或其他客户端发起 <strong>TCP 连接</strong>。</li><li>这个连接由用户的 <strong>socket</strong> 建立，连接到服务器上指定的 <strong>端口号</strong>（Tomcat 注册的端口，如默认的 8080）。</li><li>Tomcat 在启动时，会开启一个 <strong>监听线程</strong>（Acceptor），专门负责监听该端口，等待接入的 socket 连接。</li></ul><h4 id="2-分发请求"><a href="#2-分发请求" class="headerlink" title="2. 分发请求"></a><strong>2. 分发请求</strong></h4><ul><li>一旦监听线程监听到客户端发来的连接请求，它就会：<ul><li><strong>接收 socket 连接</strong></li><li>将这个连接交给 <strong>工作线程池（Worker Thread Pool）</strong> 中的一个线程去处理。</li></ul></li><li>这一步很关键：<ul><li>每个请求都被分发给线程池中的一个工作线程，<strong>实现了多线程并发处理</strong>。</li><li>这个线程随后会负责整个请求的生命周期。</li></ul></li></ul><h4 id="3-处理请求"><a href="#3-处理请求" class="headerlink" title="3. 处理请求"></a><strong>3. 处理请求</strong></h4><ul><li><p>工作线程接手后，它会：</p><ul><li>读取客户端发送的 HTTP 请求数据。</li><li>把这些数据解析成标准的 <strong><code>HttpServletRequest</code></strong> 对象，并准备好一个空的 <strong><code>HttpServletResponse</code></strong>。</li></ul></li><li><p>然后请求进入你部署在 Tomcat 中的 </p><p>WebApp</p><p>（SpringMVC、Servlet 应用等）：</p><ul><li>依次经过：<ul><li><strong>Controller</strong>（接收请求，路由分发）</li><li><strong>Service</strong>（处理业务逻辑）</li><li><strong>DAO</strong>（访问数据库，获取或修改数据）</li></ul></li></ul></li><li><p>数据处理完成后，返回值会封装到 <code>response</code> 中。</p></li></ul><h4 id="4-返回响应"><a href="#4-返回响应" class="headerlink" title="4. 返回响应"></a><strong>4. 返回响应</strong></h4><ul><li>一旦业务处理完毕，线程将响应内容写入 <code>HttpServletResponse</code>。</li><li>然后再通过最初建立的 <strong>socket 连接</strong>，把响应数据发送回客户端（用户）。</li><li>至此，<strong>一个请求-响应生命周期完成</strong>，socket 连接可能被关闭或复用（根据是否使用 keep-alive）。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-54-1024x522.png" alt="img"></p><p>preHandle前置拦截：</p><p>postHandle后置拦截：</p><p>afterCompletion视图渲染之后返回给用户之前：</p><p>在utils下面编写一个LoginInterceptor类，实现preHandle和afterCompletion这两个方法（这里User和UserDto的问题，我推荐的是统一使用UserDto，采用BeanUtils里的copy方法即可）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//获取用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">        BeanUtils.copyProperties(user,userDTO);</span><br><span class="line">        <span class="comment">//存在，保存用户信息的ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​<br>在config下面创建一个MvcConfig类：</p><p>通过addInterceptors方法来添加拦截器，registry是拦截器的注册器。</p><p>用.excludePathPatterns来排除不需要拦截的路径。在这里code、login、bloghot、shop、shopType、upload和voucher等都不需要拦截。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">StringRedisTemplate</span> stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">addInterceptors</span>(<span class="params"><span class="title class_">InterceptorRegistry</span> registry</span>) &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.<span class="title function_">addInterceptor</span>(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .<span class="title function_">excludePathPatterns</span>(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).<span class="title function_">order</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.<span class="title function_">addInterceptor</span>(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).<span class="title function_">addPathPatterns</span>(<span class="string">&quot;/**&quot;</span>).<span class="title function_">order</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入手机号码点击获取验证码，写入返回后端的验证码，勾选协议之后，登录会直接返回首页，此时看我的个人主页没问题：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-55.png" alt="img"></p><h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p>在1.4已将User转为UserDTO返回给前端。</p><h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是<strong>session拷贝</strong>，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有<strong>两个大问题</strong></p><p>1、每台服务器中都有完整的一份session数据，<strong>服务器压力过大。</strong></p><p>2、session拷贝数据时，可能会出现<strong>延迟</strong></p><p>所以咱们后来采用的方案都是<strong>基于redis来完成</strong>，我们把session换成redis，<strong>redis数据本身就是共享的</strong>，就可以避免session共享的问题了</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-56-1024x444.png" alt="img"></p><h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><p>思考一下利用redis来存储数据，那么到底使用哪种结构呢</p><p>想要保存用户的登录信息有2种方法：1.用String类型。2.用Hash类型。</p><p>如下图，如果使用String，注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p><p>String类型是以JSON字符串格式来保存，比较简单直观，但是占用内存比较多（因为有name和age这类的json格式）：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-59.png" alt="img"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，并且内存占用更少：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-58.png" alt="img"></p><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p><h4 id="1-7-1在设计这个key的时候，需要满足两点"><a href="#1-7-1在设计这个key的时候，需要满足两点" class="headerlink" title="1.7.1在设计这个key的时候，需要满足两点"></a>1.7.1在设计这个key的时候，需要满足两点</h4><p>1、key要具有唯一性</p><p>2、key要方便携带</p><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，<strong>所以我们在后台生成一个随机串token</strong>，然后让前端带来这个token就能完成我们的整体逻辑了</p><h4 id="1-7-2-整体访问流程"><a href="#1-7-2-整体访问流程" class="headerlink" title="1.7.2 整体访问流程"></a>1.7.2 整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-60-1024x557.png" alt="img"></p><h3 id="1-8-基于Redis实现短信登录"><a href="#1-8-基于Redis实现短信登录" class="headerlink" title="1.8 基于Redis实现短信登录"></a>1.8 基于Redis实现短信登录</h3><p>在UserServiceImpl中写入如下代码（调用StringRedisTemplate中的set方法进行数据插入，最好在key的前面加入业务前缀以示区分，形成区分）：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate <span class="built_in">string</span>RedisTemplate;</span><br></pre></td></tr></table></figure><p>在sendCode这个方法里将保存验证码的代码替换为下面：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存验证码到redis</span></span><br><span class="line"><span class="symbol">stringRedisTemplate.opsForValue</span>()<span class="meta">.set</span>(LOGIN_CODE_KEY+phone,<span class="meta">code</span>,LOGIN_CODE_TTL, TimeUnit.MINUTES)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在login这个方法里进行如下2处修改：</p><p> 首先是校验验证码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验验证码</span></span><br><span class="line"><span class="built_in">String</span> cacheCode = stringRedisTemplate.opsForValue().<span class="keyword">get</span>(LOGIN_CODE_KEY + phone);</span><br></pre></td></tr></table></figure><p>然后是添加把用户信息添加到Redis的逻辑</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">    <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="built_in">String</span> token = UUID.randomUUID().toString(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.<span class="keyword">class</span>);</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> HashMap&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="keyword">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3.存储</span></span><br><span class="line">    <span class="built_in">String</span> tokenKey = LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MvcConfig类上有@Configuration注解，说明是由Spring来负责依赖注入。 </p><p>在MvcConfig类中要编写如下的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">StringRedisTemplate</span> stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">addInterceptors</span>(<span class="params"><span class="title class_">InterceptorRegistry</span> registry</span>)&#123;</span><br><span class="line">        registry.<span class="title function_">addInterceptor</span>(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .<span class="title function_">excludePathPatterns</span>(</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在utils下的LoginInterceptor中写入如下代码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//TODO；1.获取请求头中的token</span></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO：2.基于TOKEN获取redis的用户</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(userMap.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO：3.将查询到的Hash数据转化为UserDTO对象</span></span><br><span class="line">        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> UserDTO(), <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//TODO：4.存在，保存用户信息的ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">//TODO：5.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(LOGIN_USER_KEY + token,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：首先把Redis和数据库都启动。 原始的项目的Redis的服务器ID需要更改为自己的。点击发送验证码，redis中有记录，没问题：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-61-1024x369.png" alt="img"></p><p>但点击登录的时候会报一个无法将Long转String的错误。因为用的是stringRedisTemplate要求所有的字段都是string类型的。</p><p>需要对UserServiceImpl中如下的位置进行修改：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-62-1024x471.png" alt="img"></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="keyword">new</span> HashMap&lt;&gt;(),</span><br><span class="line">        CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                .setFieldValueEditor<span class="function"><span class="params">((fieldName,fieldValue)-&gt;fieldValue.toString())</span>);</span></span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-63-1024x391.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-64-1024x249.png" alt="img"></p><h3 id="1-9-解决状态登录刷新问题"><a href="#1-9-解决状态登录刷新问题" class="headerlink" title="1.9 解决状态登录刷新问题"></a>1.9 解决状态登录刷新问题</h3><h4 id="1-9-1-初始方案思路总结："><a href="#1-9-1-初始方案思路总结：" class="headerlink" title="1.9.1 初始方案思路总结："></a>1.9.1 初始方案思路总结：</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，<strong>假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行</strong>，所以这个方案他是存在问题的</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-65-1024x571.png" alt="img"></p><h4 id="1-9-2-优化方案"><a href="#1-9-2-优化方案" class="headerlink" title="1.9.2 优化方案"></a>1.9.2 优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，<strong>那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌</strong>，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-66-1024x507.png" alt="img"></p><h4 id="1-9-3-代码"><a href="#1-9-3-代码" class="headerlink" title="1.9.3 代码"></a>1.9.3 代码</h4><p>复制LoginInterceptor变成一份新的RefreshTokenInterceptor，把下面几处地方改为return true即可：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-67-1024x725.png" alt="img"></p><p>LoginInterceptor的代码变成如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span>(UserHolder.getUser()==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">//拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在还需要在MvcConfig里面对拦截器进行更新配置，需要（用order）调整拦截器的执行顺序： </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">StringRedisTemplate</span> stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">addInterceptors</span>(<span class="params"><span class="title class_">InterceptorRegistry</span> registry</span>)&#123;</span><br><span class="line">        registry.<span class="title function_">addInterceptor</span>(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .<span class="title function_">excludePathPatterns</span>(</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                ).<span class="title function_">order</span>(<span class="number">1</span>);</span><br><span class="line">        registry.<span class="title function_">addInterceptor</span>(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .<span class="title function_">addPathPatterns</span>(<span class="string">&quot;/**&quot;</span>).<span class="title function_">order</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、商户查询缓存"><a href="#2、商户查询缓存" class="headerlink" title="2、商户查询缓存"></a>2、商户查询缓存</h2><h3 id="2-1什么是缓存"><a href="#2-1什么是缓存" class="headerlink" title="2.1什么是缓存"></a>2.1什么是缓存</h3><p><strong>缓存(</strong>Cache),就是数据交换的<strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码一般<strong>读写性能较高</strong>，</p><p>例如:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="type">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.<span class="built_in">newBuilder</span>().<span class="built_in">build</span>(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="built_in">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;</p><p><strong>缓存作用</strong>：降低后端负载；提高读写的效率，降低响应时间。</p><p><strong>缓存成本</strong>：数据一致性成本（数据库里的数据如果发生变化，容易与缓存中的数据形成不一致）。代码维护成本高（搭建集群）。运营成本高。</p><p><strong>如何使用缓存</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-68-1024x432.png" alt="img"></p><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-77.png" alt="img"></p><p>在ShopController类的queryShopById方法中：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GetMapping</span>(<span class="string">&quot;/&#123;id&#125;&quot;</span>)</span><br><span class="line">public Result <span class="built_in">queryShopById</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) Long id) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">Result</span><span class="selector-class">.ok</span>(shopService.<span class="built_in">queryById</span>(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IShopService接口中编写如下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">IShopService</span> <span class="symbol">extends</span> <span class="symbol">IService</span>&lt;<span class="symbol">Shop</span>&gt; &#123;</span><br><span class="line">    Object queryById(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl类的queryById方法中编写具体代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl&lt;ShopMapper</span>, <span class="title">Shop&gt;</span> <span class="title">implements</span> <span class="title">IShopService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringRedisTemplate</span> stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Object</span> queryById(<span class="type">Long</span> id) &#123;</span><br><span class="line">        <span class="type">String</span> key = <span class="type">CACHE_SHOP_KEY</span> + id;</span><br><span class="line">        <span class="comment">//1.从Redis查询缓存</span></span><br><span class="line">        <span class="type">String</span> shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="type">StrUtil</span>.isNotBlank(shopJson))&#123;</span><br><span class="line">            <span class="comment">//3.存在，直接返回</span></span><br><span class="line">            <span class="type">Shop</span> shop = <span class="type">JSONUtil</span>.toBean(shopJson, <span class="type">Shop</span>.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Result</span>.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> shop = getById(id);</span><br><span class="line">        <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(shop==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Result</span>.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="type">JSONUtil</span>.toJsonStr(shop));</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Result</span>.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 核心是通过调用hutool工具包中的JSONUtil类来实现对象转JSON（方法：toJsonStr(对象)）和JSON转对象（方法：toBean(json,Bean的类型)）</p><p>TODO：对分类进行缓存。</p><p>在ShopController类的queryShopByList方法中：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">&quot;list&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function">Result <span class="title">queryTypeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        List&lt;ShopType&gt; typeList = typeService</span></span><br><span class="line"><span class="comment">//                .query().orderByAsc(&quot;sort&quot;).list();</span></span><br><span class="line">        List&lt;ShopType&gt; typeList = typeService.queryTypeList();</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">ok</span><span class="params">(typeList)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在IShopService接口中编写如下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">IShopTypeService</span> <span class="symbol">extends</span> <span class="symbol">IService</span>&lt;<span class="symbol">ShopType</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ShopType&gt; queryTypeList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShopTypeServiceImpl：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ShopTypeServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl&lt;ShopTypeMapper</span>, <span class="title">ShopType&gt;</span> <span class="title">implements</span> <span class="title">IShopTypeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringRedisTemplate</span> stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">List</span>&lt;<span class="type">ShopType</span>&gt; queryTypeList() &#123;</span><br><span class="line">        <span class="type">String</span> key = <span class="string">&quot;login:type&quot;</span>;</span><br><span class="line"><span class="comment">//        SetOperations&lt;String, String&gt; setOps = redisTemplate.opsForSet();</span></span><br><span class="line">        <span class="comment">// 1. 从redis查询商铺缓存</span></span><br><span class="line"><span class="comment">//        String shopTypeJson = setOps.members(key).toString();</span></span><br><span class="line">        <span class="type">String</span> shopTypeJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2. 判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">StrUtil</span>.isNotBlank(shopTypeJson)) &#123;</span><br><span class="line">            <span class="comment">// 3. 存在，转化为List返回</span></span><br><span class="line"><span class="comment">//            return objectMapper.readValue(shopTypeJson, new TypeReference&lt;List&lt;ShopType&gt;&gt;()&#123;&#125;);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">JSONUtil</span>.toList(shopTypeJson, <span class="type">ShopType</span>.<span class="keyword">class</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 不存在，查询数据库</span></span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">ShopType</span>&gt; typeList = <span class="keyword">this</span>.query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="comment">// 5. 不存在，返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> (typeList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6. 存在，写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="type">JSONUtil</span>.toJsonStr(typeList));</span><br><span class="line">        <span class="comment">// 7. 返回</span></span><br><span class="line">        <span class="keyword">return</span> typeList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是<strong>redis为了节约内存而设计出来的一个东西</strong>，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以<strong>redis会对部分数据进行更新</strong>，或者把他叫为淘汰更合适。</p><ul><li><strong>内存淘汰：redis自动进行</strong>，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</li><li><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，<strong>redis会将超时的数据进行删除</strong>，方便咱们继续使用缓存</li><li><strong>主动更新：</strong>我们可以<strong>手动调用方法</strong>把缓存删掉，通常用于解决缓存和数据库不一致问题</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-88.png" alt="img"></p><h4 id="2-3-1-数据库缓存不一致解决方案："><a href="#2-3-1-数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 数据库缓存不一致解决方案："></a>2.3.1 数据库缓存不一致解决方案：</h4><p><strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>。</p><p>解决方案：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-89.png" alt="img"></p><h4 id="2-3-2-数据库和缓存不一致采用什么方案"><a href="#2-3-2-数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 数据库和缓存不一致采用什么方案"></a>2.3.2 数据库和缓存不一致采用什么方案</h4><p>选择方案一：但是方案一调用者如何处理呢？这里有几个问题操作缓存和数据库时有三个问题需要考虑：</p><p>1.选择删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都会更新缓存，无效的写操作比较多。</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存。</li></ul><p>2.如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul><p>3.先操作缓存还是先操作数据库？</p><ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul><p>答：我们应当是<strong>先操作数据库，再删除缓存</strong>，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-90.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-91.png" alt="img"></p><h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>给查询商铺的缓存添加超时剔除和主动更新的策略。</p><p>修改ShopController中的业务逻辑，满足下面要求：</p><p>1.根据id查询商铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间。</p><p>2.根据id修改店铺时，先修改数据库，再删除缓存。</p><p>首先修改ShopServiceImpl的redis过期时间：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue()<span class="meta">.set</span>(key, <span class="keyword">JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, </span>TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><p>修改ShopController中的updateShop方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@PutMapping</span></span><br><span class="line">public Result <span class="built_in">updateShop</span>(<span class="variable">@RequestBody</span> Shop shop) &#123;</span><br><span class="line">    <span class="comment">// 写入数据库</span></span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">Result</span><span class="selector-class">.ok</span>(shopService.<span class="built_in">update</span>(shop));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向IShopService接口中添加update方法：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="class">Object</span></span> <span class="function"><span class="title">update</span>(<span class="variable">Shop</span> <span class="variable">shop</span>);</span></span><br></pre></td></tr></table></figure><p>向ShopServiceImpl类中添加update方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">update</span><span class="params">(Shop shop)</span> </span>&#123;</span><br><span class="line">    Long id = shop.getId();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;商铺id不存在&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    updateById(shop);</span><br><span class="line">    stringRedisTemplate.delete(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Result.<span class="title">ok</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：首先删除缓存中的数据，然后看SQL语句是否执行，是否加上了TTL过期时间。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-92.png" alt="img"></p><p>访问<a href="http://localhost:8081/shop，然后修改101茶餐厅为102茶餐厅：">http://localhost:8081/shop，然后修改101茶餐厅为102茶餐厅：</a></p><p> 注意要发送的是PUT请求，请求的内容如下：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-93.png" alt="img"></p><p>然后去数据库看是否名称更新为102茶餐厅，然后看缓存中的数据是否被删除，用户刷新页面看到102茶餐厅，缓存中会有最新的数据。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-94.png" alt="img"></p><h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：<strong>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</strong></p><p>常见的解决方案有两种：</p><ul><li>缓存空对象</li><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li><li>布隆过滤</li><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul><p>缓存空对象：</p><p>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，<strong>简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-95.png" alt="img"></p><p>布隆过滤：</p><p>布隆过滤器其实采用的是<strong>哈希思想</strong>来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式<strong>优点在于节约内存空间</strong>，<strong>缺点是存在误判</strong>，误判原因在于：<strong>布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-96.png" alt="img"></p><h3 id="2-6-编码解决商品查询的缓存穿透问题："><a href="#2-6-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.6 编码解决商品查询的缓存穿透问题："></a>2.6 编码解决商品查询的缓存穿透问题：</h3><p>下图是原始的：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-97.png" alt="img"></p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，<strong>这样是会存在缓存穿透问题的</strong></p><p>更改后的方案：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-98.png" alt="img"></p><p>如果这个数据不存在，我们不会返回404 ，还是<strong>会把这个数据写入到Redis中，并且将value设置为空</strong>，当再次发起查询时，我们如果发现命中之后，<strong>判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</strong></p><p>在ShopServiceImpl类里对queryById方法进行修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object queryById(<span class="built_in">Long</span> id) &#123;</span><br><span class="line">    String key = CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">//1.从Redis查询缓存</span></span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().<span class="keyword">get</span>(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        Shop shop = JSONUtil.toBean(shopJson, Shop.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面是有值的情况，下面是无值的2种情况：A：空字符串。B：null。</span></span><br><span class="line">    <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺信息不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span>(shop==<span class="literal">null</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().<span class="keyword">set</span>(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().<span class="keyword">set</span>(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>localhost:8080/api/shop/1此时是命中数据。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-99.png" alt="img"></p><p>localhost:8080/api/shop/0此时未命中数据。打开缓存可以看到缓存的是空，并且TTL是200秒</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-100.png" alt="img"></p><p><strong>小总结：</strong></p><p>1.缓存穿透产生的原因是什么？</p><p>答：<strong>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</strong></p><p>2.缓存穿透的解决方案有哪些？</p><p>答：</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="2-7-缓存雪崩问题及解决思路"><a href="#2-7-缓存雪崩问题及解决思路" class="headerlink" title="2.7 缓存雪崩问题及解决思路"></a>2.7 缓存雪崩问题及解决思路</h3><p>1.什么是缓存雪崩？</p><p>答：<strong>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</strong></p><p>2.缓存雪崩的解决方案有哪些？</p><p>答：</p><ul><li>给业务添加多级缓存</li><li>给不同的Key的TTL添加随机值（解决大量缓存key同时失效）</li><li>利用Redis集群提高服务的可用性（解决Redis宕机）</li><li>给缓存业务添加降级限流策略</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-102.png" alt="img"></p><h3 id="2-8-缓存击穿问题及解决思路"><a href="#2-8-缓存击穿问题及解决思路" class="headerlink" title="2.8 缓存击穿问题及解决思路"></a>2.8 缓存击穿问题及解决思路</h3><p>1.什么是缓存击穿？</p><p>答：缓存击穿问题也叫热点Key问题，<strong>就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</strong></p><p>2.缓存击穿的解决方案有哪些？</p><p>答：常见的解决方案有两种</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大     </p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-103.png" alt="img"></p><p><strong>解决方案一  使用锁互斥锁来解决：</strong></p><p>我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>分析：假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-104.png" alt="img"></p><p><strong>解决方案二 逻辑过期方案</strong></p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：<strong>这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理</strong>。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-105.png" alt="img"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于<strong>保证了互斥性，所以数据一致</strong>，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以<strong>没有额外的内存消耗</strong>，缺点在于有锁就有<strong>死锁问题的发生</strong>，且<strong>只能串行执行</strong>性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，<strong>性能好，有一个额外的线程持有锁去进行重构数据</strong>，<strong>但是在重构数据完成前，其他的线程只能返回之前的数据</strong>，且实现起来麻烦</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-106.png" alt="img"></p><h3 id="2-9-利用互斥锁解决缓存击穿问题"><a href="#2-9-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.9 利用互斥锁解决缓存击穿问题"></a>2.9 利用互斥锁解决缓存击穿问题</h3><p>思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-107.png" alt="img"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true， 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，<strong>我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程</strong>。</p><p>在ShopServiceImpl类中定义一个tryLock方法（在Redis中的setnx相当于setIfAbsent方法。）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">tryLock</span>(<span class="params"><span class="title class_">String</span> key</span>)&#123;</span><br><span class="line">    <span class="title class_">Boolean</span> flag = stringRedisTemplate.<span class="title function_">opsForValue</span>().<span class="title function_">setIfAbsent</span>(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, <span class="title class_">TimeUnit</span>.<span class="property">SECONDS</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">BooleanUtil</span>.<span class="title function_">isTrue</span>(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl类中定义一个unLock方法用于解锁。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span>(<span class="built_in">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">    stringRedisTemplate.<span class="property">delete</span>(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl类中定义一个queryWithPassThrough方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop queryWithPassThrough(<span class="built_in">Long</span> id)&#123;</span><br><span class="line">    String key = CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">//1.从Redis查询缓存</span></span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().<span class="keyword">get</span>(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        Shop shop = JSONUtil.toBean(shopJson, Shop.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面是有值的情况，下面是无值的2种情况：A：空字符串。B：null。</span></span><br><span class="line">    <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span>(shop==<span class="literal">null</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().<span class="keyword">set</span>(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().<span class="keyword">set</span>(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl类中定义一个queryWithMutex方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop queryWithMutex(<span class="built_in">Long</span> id)&#123;</span><br><span class="line">    String key = CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">//1.从Redis查询缓存</span></span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().<span class="keyword">get</span>(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        Shop shop = JSONUtil.toBean(shopJson, Shop.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面是有值的情况，下面是无值的2种情况：A：空字符串。B：null。</span></span><br><span class="line">    <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.实现缓存重建</span></span><br><span class="line">    <span class="comment">//4.1 获取互斥锁</span></span><br><span class="line">    String lockKey = LOCK_SHOP_KEY+id;</span><br><span class="line">    Shop shop = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boolean isLock = tryLock(lockKey);</span><br><span class="line">        <span class="comment">//4.2 判断是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            <span class="comment">//4.3 失败，则休眠并重试</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//4.4 获取互斥锁成功，根据id查询数据库</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        <span class="comment">//模拟重建的延时</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//5.数据库查询失败，返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(shop==<span class="literal">null</span>)&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().<span class="keyword">set</span>(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().<span class="keyword">set</span>(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> new RuntimeException(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//7.释放互斥锁</span></span><br><span class="line">        unLock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.返回</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl类中修改queryById，调用queryWithMutex：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">queryById</span>(<span class="params"><span class="title class_">Long</span> id</span>) &#123;</span><br><span class="line">    <span class="comment">//缓存穿透</span></span><br><span class="line">    <span class="comment">//Shop shop = queryWithPassThrough(id);</span></span><br><span class="line">    <span class="comment">//互斥锁解决缓存击穿</span></span><br><span class="line">    <span class="title class_">Shop</span> shop = <span class="title function_">queryWithMutex</span>(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Result</span>.<span class="title function_">ok</span>(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-利用逻辑过期解决缓存击穿问题"><a href="#2-10-利用逻辑过期解决缓存击穿问题" class="headerlink" title="2.10  利用逻辑过期解决缓存击穿问题"></a>2.10  利用逻辑过期解决缓存击穿问题</h3><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-108.png" alt="img"></p><p>如果封装数据，添加逻辑过期字段：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类</p><p>答：可以在utils包下定义RedisData类（可以让Shop继承RedisData类），也可以在RedisData中设置一个Shop类的data属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl类中定义saveShop2Redis方法：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> saveShop2Redis(Long <span class="built_in">id</span>,Long expireSeconds)&#123;</span><br><span class="line">    <span class="comment">//1.查询店铺数据</span></span><br><span class="line">    Shop shop <span class="operator">=</span> getById(<span class="built_in">id</span>);</span><br><span class="line">    <span class="comment">//2.封装逻辑过期时间</span></span><br><span class="line">    RedisData redisData <span class="operator">=</span> <span class="keyword">new</span> RedisData();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">    <span class="comment">//3.写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().<span class="built_in">set</span>(CACHE_SHOP_KEY<span class="operator">+</span><span class="built_in">id</span>,JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试，在test包下的HmDianPingApplicationTests中创建testSaveShop类写入测试代码（这里要注意的是输入alt+insert之后选择Test Method要选择Junit 5来进行测试方法的编写）：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HmDianPingApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="variable">@Resource</span></span><br><span class="line">    private ShopServiceImpl shopService;</span><br><span class="line"> </span><br><span class="line">    <span class="variable">@Test</span></span><br><span class="line">    void testSaveShop() &#123;</span><br><span class="line">        shopService.saveShop2Redis(1L,10L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到redis中确实存入了数据：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-109.png" alt="img"></p><p>在ShopServiceImpl中复制一份缓存穿透的代码，更改名称为queryWithLogicalExpire：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="title class_">ExecutorService</span> <span class="variable constant_">CACHE_REBUILD_EXECUTOR</span> = <span class="title class_">Executors</span>.<span class="title function_">newFixedThreadPool</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="title class_">Shop</span> <span class="title function_">queryWithLogicalExpire</span>(<span class="params"><span class="title class_">Long</span> id</span>)&#123;</span><br><span class="line">    <span class="title class_">String</span> key = <span class="variable constant_">CACHE_SHOP_KEY</span> + id;</span><br><span class="line">    <span class="comment">//1.从Redis查询缓存</span></span><br><span class="line">    <span class="title class_">String</span> shopJson = stringRedisTemplate.<span class="title function_">opsForValue</span>().<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">StrUtil</span>.<span class="title function_">isBlank</span>(shopJson))&#123;</span><br><span class="line">        <span class="comment">//3.不存在，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="title class_">RedisData</span> redisData = <span class="title class_">JSON</span>Util.<span class="title function_">toBean</span>(shopJson, <span class="title class_">RedisData</span>.<span class="property">class</span>);</span><br><span class="line">    <span class="title class_">JSON</span><span class="built_in">Object</span> data = (<span class="title class_">JSON</span><span class="built_in">Object</span>) redisData.<span class="title function_">getData</span>();</span><br><span class="line">    <span class="title class_">Shop</span> shop = <span class="title class_">JSON</span>Util.<span class="title function_">toBean</span>(data, <span class="title class_">Shop</span>.<span class="property">class</span>);</span><br><span class="line">    <span class="comment">//5.判断是否过期</span></span><br><span class="line">    <span class="comment">//5.1 未过期直接返回店铺信息</span></span><br><span class="line">    <span class="title class_">LocalDateTime</span> expireTime = redisData.<span class="title function_">getExpireTime</span>();</span><br><span class="line">    <span class="keyword">if</span>(expireTime.<span class="title function_">isAfter</span>(<span class="title class_">LocalDateTime</span>.<span class="title function_">now</span>()))&#123;</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.2 已过期重建缓存</span></span><br><span class="line">    <span class="comment">//6.缓存重建</span></span><br><span class="line">    <span class="comment">//6.1.获取互斥锁</span></span><br><span class="line">    <span class="title class_">String</span> lockKey = <span class="variable constant_">LOCK_SHOP_KEY</span> + id;</span><br><span class="line">    <span class="built_in">boolean</span> isLock = <span class="title function_">tryLock</span>(lockKey);</span><br><span class="line">    <span class="comment">//6.2.判断是否获取互斥锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="comment">//6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">        <span class="variable constant_">CACHE_REBUILD_EXECUTOR</span>.<span class="title function_">submit</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="title function_">saveShop2Redis</span>(id,20L); <span class="comment">//实际中应该设置为30分钟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="title function_">unLock</span>(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.4.失败，返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>先到数据库把102茶餐厅改为103茶餐厅（因为Redis之前插入了一条缓存为102茶餐厅，并且已经过期，此时数据库与缓存不一致），新的HTTP请求会将逻辑过期的数据删除，然后更新缓存。</p><p>线程数设置为100，Ramp-up时间设置为1</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-110.png" alt="img"></p><p>在查看结果树里面到中间某个HTTP请求会完成重建，响应数据会改变。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-111.png" alt="img"></p><p>1.安全性问题：在高并发情况下是否会有很多线程来做重建。</p><p>2.一致性问题：在重建完成之前得到的是否是旧的数据。</p><h3 id="2-11-封装Redis-工具类"><a href="#2-11-封装Redis-工具类" class="headerlink" title="2.11 封装Redis 工具类"></a>2.11 封装Redis 工具类</h3><p>背景：在高并发系统中，我们通常使用 Redis 缓存数据库查询结果，减轻数据库压力。但如果直接使用 Redis，可能会遇到以下问题：</p><ol><li><strong>缓存穿透</strong>：请求的数据既不在缓存里，也不在数据库里，会频繁打数据库。</li><li><strong>缓存击穿</strong>：热点key突然失效，导致大量请求同时打到数据库。</li><li><strong>缓存雪崩</strong>：大量key同时过期，引起瞬时流量打满数据库。</li></ol><p>因此我们基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题</li><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p><strong>具体实现</strong>：</p><p>在utils包下创建CacheClient类，先写入如下基础的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> final <span class="title class_">StringRedisTemplate</span> stringRedisTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">CacheClient</span>(<span class="title class_">StringRedisTemplate</span> stringRedisTemplate) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stringRedisTemplate</span> = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">set</span>(<span class="params"><span class="title class_">String</span> key, <span class="title class_">Object</span> value, <span class="title class_">Long</span> time, <span class="title class_">TimeUnit</span> unit</span>)&#123;</span><br><span class="line">        stringRedisTemplate.<span class="title function_">opsForValue</span>().<span class="title function_">set</span>(key,<span class="title class_">JSON</span>Util.<span class="title function_">toJsonStr</span>(value),time,unit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setWithLogicalExpire</span>(<span class="params"><span class="title class_">String</span> key, <span class="title class_">Object</span> value,<span class="title class_">Long</span> expire,<span class="title class_">TimeUnit</span> unit</span>)&#123;</span><br><span class="line">        <span class="comment">//设置逻辑过期</span></span><br><span class="line">        <span class="title class_">RedisData</span> redisData = <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.<span class="title function_">setExpireTime</span>(<span class="title class_">LocalDateTime</span>.<span class="title function_">now</span>().<span class="title function_">plusSeconds</span>(unit.<span class="title function_">toSeconds</span>(expire)));</span><br><span class="line">        redisData.<span class="title function_">setData</span>(value);</span><br><span class="line">        stringRedisTemplate.<span class="title function_">opsForValue</span>().<span class="title function_">set</span>(key,<span class="title class_">JSON</span>Util.<span class="title function_">toJsonStr</span>(redisData));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-119.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-120.png" alt="img"></p><p>在CacheClient类中编写缓存穿透的共性方法queryWithPassThrough： </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R,ID&gt; R queryWithPassThrough(String keyPrefix, ID id, Class&lt;R&gt; type,</span><br><span class="line">                                     Function&lt;ID,R&gt; dbFallBack,<span class="built_in">Long</span> time,TimeUnit unit)&#123;</span><br><span class="line">    String key = keyPrefix + id;</span><br><span class="line">    <span class="comment">//1.从Redis查询缓存</span></span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().<span class="keyword">get</span>(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面是有值的情况，下面是无值的2种情况：A：空字符串。B：null。</span></span><br><span class="line">    <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    R r = dbFallBack.apply(id);</span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span>(r==<span class="literal">null</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().<span class="keyword">set</span>(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">set</span>(key,r,time,unit);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-121.png" alt="img"></p><p>编写完queryWithPassThrough之后可以到ShopServiceImpl中直接调用新的方法（记得引入CacheClient类）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object queryById(<span class="built_in">Long</span> id) &#123;</span><br><span class="line">    <span class="comment">//调用工具类解决缓存击穿</span></span><br><span class="line">    Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.<span class="keyword">class</span>, <span class="keyword">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">if</span>(shop==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：成功会对不存在的店铺空值进行缓存。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-113.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-115.png" alt="img"></p><p>接下来拷贝queryWithLogicalExpire的代码到CacheClient类中进行改写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="title class_">ExecutorService</span> <span class="variable constant_">CACHE_REBUILD_EXECUTOR</span> = <span class="title class_">Executors</span>.<span class="title function_">newFixedThreadPool</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> &lt;R,<span class="variable constant_">ID</span>&gt; R <span class="title function_">queryWithLogicalExpire</span>(<span class="params"><span class="title class_">String</span> keyPrefix,ID id,<span class="title class_">Class</span>&lt;R&gt; <span class="keyword">type</span>,<span class="title class_">Function</span>&lt;ID,R&gt; dbFallBack,<span class="title class_">Long</span> time,<span class="title class_">TimeUnit</span> unit</span>)&#123;</span><br><span class="line">    <span class="title class_">String</span> key = keyPrefix + id;</span><br><span class="line">    <span class="comment">//1.从Redis查询缓存</span></span><br><span class="line">    <span class="title class_">String</span> shopJson = stringRedisTemplate.<span class="title function_">opsForValue</span>().<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">StrUtil</span>.<span class="title function_">isBlank</span>(shopJson))&#123;</span><br><span class="line">        <span class="comment">//3.不存在，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="title class_">RedisData</span> redisData = <span class="title class_">JSON</span>Util.<span class="title function_">toBean</span>(shopJson, <span class="title class_">RedisData</span>.<span class="property">class</span>);</span><br><span class="line">    <span class="title class_">JSON</span><span class="built_in">Object</span> data = (<span class="title class_">JSON</span><span class="built_in">Object</span>) redisData.<span class="title function_">getData</span>();</span><br><span class="line">    R r = <span class="title class_">JSON</span>Util.<span class="title function_">toBean</span>(data, <span class="keyword">type</span>);</span><br><span class="line">    <span class="comment">//5.判断是否过期</span></span><br><span class="line">    <span class="comment">//5.1 未过期直接返回店铺信息</span></span><br><span class="line">    <span class="title class_">LocalDateTime</span> expireTime = redisData.<span class="title function_">getExpireTime</span>();</span><br><span class="line">    <span class="keyword">if</span>(expireTime.<span class="title function_">isAfter</span>(<span class="title class_">LocalDateTime</span>.<span class="title function_">now</span>()))&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.2 已过期重建缓存</span></span><br><span class="line">    <span class="comment">//6.缓存重建</span></span><br><span class="line">    <span class="comment">//6.1.获取互斥锁</span></span><br><span class="line">    <span class="title class_">String</span> lockKey = <span class="variable constant_">LOCK_SHOP_KEY</span> + id;</span><br><span class="line">    <span class="built_in">boolean</span> isLock = <span class="title function_">tryLock</span>(lockKey);</span><br><span class="line">    <span class="comment">//6.2.判断是否获取互斥锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="comment">//6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">        <span class="variable constant_">CACHE_REBUILD_EXECUTOR</span>.<span class="title function_">submit</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//查询数据库</span></span><br><span class="line">                R r1 = dbFallBack.<span class="title function_">apply</span>(id);</span><br><span class="line">                <span class="comment">//写入redis</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setWithLogicalExpire</span>(key,r1,time,unit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="title function_">unLock</span>(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.4.失败，返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">tryLock</span>(<span class="params"><span class="title class_">String</span> key</span>)&#123;</span><br><span class="line">    <span class="title class_">Boolean</span> flag = stringRedisTemplate.<span class="title function_">opsForValue</span>().<span class="title function_">setIfAbsent</span>(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, <span class="title class_">TimeUnit</span>.<span class="property">SECONDS</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">BooleanUtil</span>.<span class="title function_">isTrue</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">unLock</span>(<span class="params"><span class="title class_">String</span> key</span>)&#123;</span><br><span class="line">    stringRedisTemplate.<span class="title function_">delete</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-125.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-126.png" alt="img"></p><p>改写test下的HmDianPingApplicationTests类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HmDianPingApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ShopServiceImpl shopService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveShop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopService.getById(<span class="number">1L</span>);</span><br><span class="line">        cacheClient.setWithLogicalExpire(CACHE_SHOP_KEY+<span class="number">1L</span>,shop,<span class="number">10L</span>,TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：首先运行HmDianPingApplicationTests类里的测试方法，10秒后逻辑过期，此时运行后台程序，修改数据库1号商铺的name字段，此时访问：localhost:8080/api/shop/1 会出现效果第1次访问为缓存旧值，然后发现缓存过期开始重建，第2次访问开始就是新值。数据库也只有1次重建。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-116.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-117.png" alt="img"></p><h2 id="3、优惠卷秒杀"><a href="#3、优惠卷秒杀" class="headerlink" title="3、优惠卷秒杀"></a>3、优惠卷秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 -全局唯一ID"></a>3.1 -全局唯一ID</h3><p>每个店铺都可以发布优惠券，当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID会存在一些问题。</p><p>1.id的规律性太明显。</p><p>2.受单表数据量的限制（分表之后每张表都自增长，id会出现重复）。</p><p><strong>全局ID生成器</strong>：是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><p>1.唯一性。2.高可用。3.高性能。4.递增性。5.安全性。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-127.png" alt="img"></p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p>ID的组成部分：符号位：1bit，永远为0代表整数</p><p>时间戳：31bit，以秒为单位，定义了一个起始时间，用当前时间减起始时间，预估可以使用69年。</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-128.png" alt="img"></p><h3 id="3-2-Redis实现全局唯一Id"><a href="#3-2-Redis实现全局唯一Id" class="headerlink" title="3.2 -Redis实现全局唯一Id"></a>3.2 -Redis实现全局唯一Id</h3><p>在utils包下定义一个RedisWorker类，是一个基于Redis的ID生成器。</p><p>如果只使用一个key来自增记录有一个坏处，最终key的自增数量会突破容量的上限，假如自增超过32位彼时便无法再存储新的数据，解决的方案是采用拼接日期。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">long</span> BEGIN_TIMESTAMP = <span class="number">1640995200</span>L;</span><br><span class="line">    <span class="comment">//序列号的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> COUNT_BITS=<span class="number">32</span>;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="built_in">long</span> nextId(String keyPrefix)&#123;</span><br><span class="line">        <span class="comment">//1.生成时间戳</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        <span class="built_in">long</span> timeStamp = now.toEpochSecond(ZoneOffset.UTC) - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2.生成序列号</span></span><br><span class="line">        <span class="comment">//2.1获取当前日期，精确到天</span></span><br><span class="line">        String <span class="built_in">date</span> = now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2自增长</span></span><br><span class="line">        <span class="built_in">long</span> <span class="keyword">count</span> = stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + <span class="built_in">date</span>);</span><br><span class="line">        <span class="comment">//3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timeStamp &lt;&lt; COUNT_BITS | <span class="keyword">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HmDianPingApplicationTests中写入如下的测试代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line"><span class="keyword">private</span> ShopServiceImpl shopService;</span><br><span class="line">@Resource</span><br><span class="line"><span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"><span class="keyword">private</span> ExecutorService es = Executors.<span class="built_in">newFixedThreadPool</span>(<span class="number">500</span>);</span><br><span class="line">@<span class="function">Test</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testIdWorker</span><span class="params">()</span> throws InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> <span class="built_in">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line">    Runnable task = ()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="type">long</span> id = redisIdWorker.<span class="built_in">nextId</span>(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;id=&quot;</span>+id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.<span class="built_in">countDown</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> begin = System.<span class="built_in">currentTimeMillis</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">300</span>;i++)&#123;</span><br><span class="line">        es.<span class="built_in">submit</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.<span class="built_in">await</span>();</span><br><span class="line">    <span class="type">long</span> end = System.<span class="built_in">currentTimeMillis</span>();</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">&quot;Result Time = &quot;</span> + (end-begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后可以看到以十进制输出的所有编号</p><p>可以在Redis中看到自增长的结果，1次是30000：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-130.png" alt="img"></p><p>大概2秒可以生成3万条，速度还是可以的。</p><p>全局唯一ID生成策略：</p><p>1.UUID利用JDK自带的工具类即可生成，生成的是16进制的字符串，无单调递增的特性。</p><p>2.Redis自增（每天一个key，方便统计订单量。时间戳+计数器的格式。）</p><p>3.snowflake雪花算法（不依赖于Redis，性能更好，对于时钟依赖）</p><p>4.数据库自增</p><h2 id="🧩-与其他-ID-生成方案对比"><a href="#🧩-与其他-ID-生成方案对比" class="headerlink" title="🧩 与其他 ID 生成方案对比"></a>🧩 与其他 ID 生成方案对比</h2><div class="table-container"><table><thead><tr><th>方法</th><th>特点</th><th>优缺点</th></tr></thead><tbody><tr><td><strong>UUID</strong></td><td>通过 JDK 提供 <code>UUID.randomUUID()</code></td><td>保证唯一，但无序、长度大，不适合排序和数据库主键</td></tr><tr><td><strong>Redis 自增（本例）</strong></td><td>时间戳 + 自增</td><td>并发高，易于控制和拆分，但依赖 Redis</td></tr><tr><td><strong>雪花算法（Snowflake）</strong></td><td>Twitter 开源的分布式 ID 方案</td><td>性能高，不依赖 Redis，但需要精确的机器时间</td></tr><tr><td><strong>数据库自增主键</strong></td><td>利用数据库主键自增</td><td>简单但性能差，分布式下易冲突或失效</td></tr></tbody></table></div><h3 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h3><p>每个店铺都可以发放优惠券，分为平价券和特价券。平价券可以任意抢购，特价券需要秒杀抢购。</p><p>tb_voucher：优惠券基本信息，优惠金额，使用规则等。</p><p>tb_seckill_voucher：优惠券的库存，开始抢购时间，结束抢购时间，只有特价优惠券才需要填写这些信息。</p><p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>请求的信息如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;shopId&quot;</span>:<span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;title&quot;</span>:<span class="string">&quot;100元代金券&quot;</span>,</span><br><span class="line"><span class="string">&quot;subTitle&quot;</span>:<span class="string">&quot;周一至周五均可使用&quot;</span>,</span><br><span class="line"><span class="string">&quot;rules&quot;</span>:<span class="string">&quot;全场通用<span class="char escape_">\n</span>无需预约<span class="char escape_">\n</span>可无限叠加<span class="char escape_">\不</span>兑现、不找零<span class="char escape_">\n</span>仅限堂食&quot;</span>,</span><br><span class="line"><span class="string">&quot;payValue&quot;</span>:<span class="number">8000</span>,</span><br><span class="line"><span class="string">&quot;actualValue&quot;</span>:<span class="number">10000</span>,</span><br><span class="line"><span class="string">&quot;type&quot;</span>:<span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;stock&quot;</span>:<span class="number">100</span>,</span><br><span class="line"><span class="string">&quot;beginTime&quot;</span>:<span class="string">&quot;2024-04-10T10:09:17&quot;</span>,</span><br><span class="line"><span class="string">&quot;endTime&quot;</span>:<span class="string">&quot;2024-04-11T12:09:04&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增普通卷代码：</strong></p><p> VoucherController</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@PostMapping</span></span><br><span class="line">public Result <span class="built_in">addVoucher</span>(<span class="variable">@RequestBody</span> Voucher voucher) &#123;</span><br><span class="line">    <span class="selector-tag">voucherService</span><span class="selector-class">.save</span>(voucher);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">Result</span><span class="selector-class">.ok</span>(voucher.<span class="built_in">getId</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@PostMapping</span>(<span class="string">&quot;seckill&quot;</span>)</span><br><span class="line">public Result <span class="built_in">addSeckillVoucher</span>(<span class="variable">@RequestBody</span> Voucher voucher) &#123;</span><br><span class="line">    <span class="selector-tag">voucherService</span><span class="selector-class">.addSeckillVoucher</span>(voucher);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">Result</span><span class="selector-class">.ok</span>(voucher.<span class="built_in">getId</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>VoucherServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-132.png" alt="img"></p><p>秒杀下单应该思考的内容：</p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-134.png" alt="img"></p><p>在VouchrOrderController类中：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RestController</span></span><br><span class="line"><span class="variable">@RequestMapping</span>(<span class="string">&quot;/voucher-order&quot;</span>)</span><br><span class="line">public class VoucherOrderController &#123;</span><br><span class="line">  <span class="variable">@Resource</span></span><br><span class="line">   private IVoucherService voucherService;</span><br><span class="line">   <span class="variable">@PostMapping</span>(<span class="string">&quot;seckill/&#123;id&#125;&quot;</span>)</span><br><span class="line">    public Result <span class="built_in">seckillVoucher</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) Long voucherId) &#123;</span><br><span class="line">           <span class="selector-tag">return</span> <span class="selector-tag">voucherService</span><span class="selector-class">.seckillVoucher</span>(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IVoucherOrderService中写入如下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">IVoucherOrderService</span> <span class="symbol">extends</span> <span class="symbol">IService</span> &#123;</span><br><span class="line">        Result seckillVoucher(Long voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在VoucherOrderServiceImpl中写入如下代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">VoucherOrderMapper</span>, <span class="title">VoucherOrder</span>&gt; <span class="keyword">implements</span> <span class="title">IVoucherOrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Result <span class="title">seckillVoucher</span><span class="params">(Long voucherId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.查询优惠券信息</span></span><br><span class="line">        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">        <span class="comment">//2.1秒杀尚未开始返回异常</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;秒杀尚未开始&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2秒杀已结束返回异常</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;秒杀已经结束&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getStock()&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//3.1库存不足返回异常</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;库存不足！&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2库存充足扣减库存</span></span><br><span class="line">        <span class="keyword">boolean</span> success = seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;库存不足！&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.创建订单，返回订单id</span></span><br><span class="line">        VoucherOrder voucherOrder = <span class="keyword">new</span> VoucherOrder();</span><br><span class="line">        <span class="keyword">long</span> orderId = redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);<span class="comment">//订单id</span></span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        Long userId = UserHolder.getUser().getId();<span class="comment">//用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);<span class="comment">//代金券id</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">ok</span><span class="params">(orderId)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h3><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p>正常逻辑：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-137.png" alt="img"></p><p>非正常逻辑：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-135.png" alt="img"></p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-138.png" alt="img"></p><p><strong>悲观锁：</strong></p><p>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p><strong>乐观锁：</strong></p><p>乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure><p><strong>课程中的使用方式：</strong></p><p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功</p><p><strong>版本号法：</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-139.png" alt="img"></p><p><strong>CAS法</strong>（版本号法的简化版）：查询的时候把库存查出来，更新的时候判断库存和之前查到的库存是否一致，如果一致则更新数据。</p><h3 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h3><p>只需加上下面这段代码即可：.eq(“stock”,voucher.getStock()) 。用于比较当前数据库的库存值和之前查询到的库存值是否相同，只有相同时才可以执行set语句。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//<span class="number">3.2</span>库存充足扣减库存</span><br><span class="line">boolean success = seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) //相当于set条件 set stock = stock - <span class="number">1</span></span><br><span class="line">        .e<span class="string">q(&quot;voucher_id&quot;, voucherId)</span> //相当于where条件 where id = ? <span class="keyword">and</span> stock = ?</span><br><span class="line">        .e<span class="string">q(&quot;stock&quot;,voucher.getStock()</span>).update();</span><br></pre></td></tr></table></figure><p>但经过测试现在出现了异常值偏高的问题，正常的请求大约只占10%。</p><p>原理是因为：假如一次有30个线程涌入，查询到库存值为100，只有1个线程能把值改为99，其它29个线程比对库存值99发现和自己查询到的库存值100不同，所以都认为数据已经被修改过，所以都失败了。</p><p>现在只需要保证stock&gt;0即可，只要存量大于0就可以任意扣减。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> success = seckillVoucherService.<span class="keyword">update</span>()</span><br><span class="line">        .setSql(&quot;stock = stock - 1&quot;) //相当于<span class="keyword">set</span>条件 <span class="keyword">set</span> stock = stock - <span class="number">1</span></span><br><span class="line">        .eq(&quot;voucher_id&quot;, voucherId) //相当于<span class="keyword">where</span>条件 <span class="keyword">where</span> id = ? <span class="keyword">and</span> stock = ?</span><br><span class="line">        .gt(&quot;stock&quot;,<span class="number">0</span>).<span class="keyword">update</span>();</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-141.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-143.png" alt="img"></p><p>乐观锁缺陷：</p><p>需要大量对数据库进行访问，容易导致数据库的崩溃。</p><p>总结：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-144.png" alt="img"></p><h3 id="3-7优惠券秒杀-一人一单"><a href="#3-7优惠券秒杀-一人一单" class="headerlink" title="3.7优惠券秒杀-一人一单"></a>3.7优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p>问题分析：优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p><p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-156.png" alt="img"></p><p>❌ 错误方式：锁整个方法（比如 <code>synchronized public void createVoucherOrder()</code>）</p><p><strong>问题</strong>：所有用户都会竞争同一个锁，系统性能会很差（串行执行，效率极低）</p><p>✅ 正确方式：只对同一个用户加锁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">synchronized</span>(<span class="params">userId.toString().intern()</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>.intern()</code> 会让字符串引用变成常量池中的共享对象，相同内容就是同一个锁。</p><p><strong>为什么用 <code>.intern()</code>？</strong></p><p>因为 <code>toString()</code> 每次是新对象，锁不生效。</p><p>但是因为事务是在函数执行结束之后由Spring进行提交，如果把锁加在createVoucherOrder内部其实有点小——因为如果解锁之后，其它线程可以进入，而此时事务尚未提交，仍然会导致安全性问题。</p><h3 id="🔁-事务控制注意事项"><a href="#🔁-事务控制注意事项" class="headerlink" title="🔁 事务控制注意事项"></a>🔁 <strong>事务控制注意事项</strong></h3><p><strong>问题点</strong>：Spring 的 <code>@Transactional</code> 只对代理对象生效。</p><p><strong>错误方式</strong>：直接在当前类中内部调用 <code>createVoucherOrder()</code>，事务不生效！</p><p><strong>解决方式</strong>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IVoucherOrderService proxy <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy()<span class="comment">;</span></span><br><span class="line">return proxy.createVoucherOrder(voucherId)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这就是用当前线程的代理对象来调用方法，事务才能起作用。</p><p><strong>因此最终方案</strong>是把synchronized加在createVoucherOrder的方法外部，锁住的是用户id。</p><p><code>seckillVoucher()</code> 方法（外层逻辑 + 加锁 + 事务代理调用）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized (userId.toString().intern()) &#123;</span><br><span class="line">    IVoucherOrderService proxy <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy()<span class="comment">;</span></span><br><span class="line">    return proxy.createVoucherOrder(voucherId)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="createVoucherOrder-方法（真正创建订单的逻辑，带事务）"><a href="#createVoucherOrder-方法（真正创建订单的逻辑，带事务）" class="headerlink" title="createVoucherOrder() 方法（真正创建订单的逻辑，带事务）"></a><code>createVoucherOrder()</code> 方法（真正创建订单的逻辑，带事务）</h4><ul><li>先查询是否已经有订单（保证一人一单）。</li><li>如果没有，再扣库存。</li><li>然后创建订单并保存。</li></ul><p>总结：关于代理对象事务的问题：通常情况下，当一个使用了@Transactional注解的方法被调用时，Spring会从上下文中获取一个代理对象来管理事务。</p><p>但是如果加@Transactional方法是被同一个类中的另一个方法调用时，Spring不会使用代理对象，而是直接调用该方法，导致事务注解失效。</p><p>为避免这种情况，可以使用AopContext.currentProxy方法获取当前的代理对象，然后通过代理对象调用被@Transactional注解修饰的方法，确保事务生效。</p><p>在VoucherOrderServiceImpl中写入如下代码（注意：ctrl+alt+m可以把含有return的代码段进行提取）：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">VoucherOrderMapper</span>, <span class="title">VoucherOrder</span>&gt; <span class="keyword">implements</span> <span class="title">IVoucherOrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Result <span class="title">seckillVoucher</span><span class="params">(Long voucherId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.查询优惠券信息</span></span><br><span class="line">        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">        <span class="comment">//2.1秒杀尚未开始返回异常</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;秒杀尚未开始&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2秒杀已结束返回异常</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;秒杀已经结束&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        voucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//3.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getStock()&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//3.1库存不足返回异常</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;库存不足！&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">            <span class="comment">//获取代理对象</span></span><br><span class="line">            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="function"><span class="keyword">return</span> proxy.<span class="title">createVoucherOrder</span><span class="params">(voucherId)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Result <span class="title">createVoucherOrder</span><span class="params">(Long voucherId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//6.一人一单</span></span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//6.1查询订单</span></span><br><span class="line">        <span class="keyword">int</span> count = query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">//6.2判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//用户已经购买过了</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;用户已经购买过一次！&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2库存充足扣减库存</span></span><br><span class="line">        <span class="keyword">boolean</span> success = seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">//相当于set条件 set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId) <span class="comment">//相当于where条件 where id = ? and stock = ?</span></span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;库存不足！&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.创建订单，返回订单id</span></span><br><span class="line">        VoucherOrder voucherOrder = <span class="keyword">new</span> VoucherOrder();</span><br><span class="line">        <span class="keyword">long</span> orderId = redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);<span class="comment">//订单id</span></span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);<span class="comment">//代金券id</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">ok</span><span class="params">(orderId)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IVoucherOrderService接口中加入下面这个方法：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="class">Result</span></span> <span class="function"><span class="title">createVoucherOrder</span>(<span class="variable">Long</span> <span class="variable">voucherId</span>);</span></span><br></pre></td></tr></table></figure><p>在pom.xml中引入如下的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 在启动类HmDianPingApplication上加如下注解：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(exposeProxy = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>测试： 成功实现一名用户只能领取一张优惠券。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-157-1024x137.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-158-1024x111.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-159.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-160.png" alt="img"></p><h3 id="3-8-集群环境下的并发问题"><a href="#3-8-集群环境下的并发问题" class="headerlink" title="3.8 集群环境下的并发问题"></a>3.8 集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>如下图可以设置项目启动的端口号，确保启动的项目之间端口号不同:</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-164.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-163.png" alt="img"></p><p>在nginx.conf中放开8082的这个配置：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-165.png" alt="img"></p><p>向下面这个页面发送请求：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>localhost:<span class="number">8080</span><span class="regexp">/api/</span>voucher<span class="regexp">/list/</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p> 可以看到请求会分别被8082和8081接收，是轮询的效果：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-166.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-167.png" alt="img"></p><p>首先到tb_voucher_order把之前的订单删除，到tb_seckill_voucher中把stock重新改回100。</p><p>准备2个相同的秒杀请求：要注意请求的地址是：<a href="http://localhost:8080/api/voucher-order/seckill/13">http://localhost:8080/api/voucher-order/seckill/13</a></p><p>我这里直接用Jemeter来进行测试，模拟高并发场景：</p><p>下面是效果：可以看到并发请求能够同时进入集群的每台结点。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-169.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-170.png" alt="img"></p><p>正常情况：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-172.png" alt="img"></p><h3 id="单机下的锁控制（第一张图）"><a href="#单机下的锁控制（第一张图）" class="headerlink" title="单机下的锁控制（第一张图）"></a>单机下的锁控制（第一张图）</h3><p>这一张图展示了多个线程在同一个 JVM 中操作的场景，用来说明单机下通过 <code>synchronized</code> 锁对象控制一人一单的机制 <strong>是有效的</strong>。</p><h4 id="✅-关键流程："><a href="#✅-关键流程：" class="headerlink" title="✅ 关键流程："></a>✅ 关键流程：</h4><ol><li><strong>线程1 和 线程2</strong> 分别尝试为同一用户下订单。</li><li>线程1 拿到了锁，执行完“查询是否已有订单”，判断没有，于是创建新订单，释放锁。</li><li>线程2 此时等待线程1释放锁，再做同样的流程。</li><li>但线程2执行到查询订单时，已经能查到订单，<strong>所以不会重复下单</strong>。</li></ol><h4 id="✅-结论："><a href="#✅-结论：" class="headerlink" title="✅ 结论："></a>✅ 结论：</h4><blockquote><p>单 JVM 下，同一个用户加锁是生效的，能有效防止并发时的重复下单。</p></blockquote><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-173.png" alt="img"></p><h3 id="❌-集群下的锁失效问题（第二张图）"><a href="#❌-集群下的锁失效问题（第二张图）" class="headerlink" title="❌ 集群下的锁失效问题（第二张图）"></a>❌ 集群下的锁失效问题（第二张图）</h3><h4 id="左侧：JVM1（Tomcat-A）"><a href="#左侧：JVM1（Tomcat-A）" class="headerlink" title="左侧：JVM1（Tomcat A）"></a>左侧：JVM1（Tomcat A）</h4><ul><li>线程1 加锁成功，正在下单；</li><li>线程2 来了，在等待释放锁。</li></ul><h4 id="右侧：JVM2（Tomcat-B）"><a href="#右侧：JVM2（Tomcat-B）" class="headerlink" title="右侧：JVM2（Tomcat B）"></a>右侧：JVM2（Tomcat B）</h4><ul><li>线程3 是同一个用户的请求，但由于 JVM2 的锁对象和 JVM1 的锁对象<strong>不是同一个实例</strong>，所以也能加锁成功；</li><li>同样线程4 跟进等待线程3；</li></ul><h4 id="🧨-问题产生："><a href="#🧨-问题产生：" class="headerlink" title="🧨 问题产生："></a>🧨 问题产生：</h4><p>虽然线程1和线程3锁的<strong>代码</strong>看起来是一样的，但因为<strong>JVM不一样，锁对象不是同一个</strong>，所以线程3并不知道线程1已经在处理下单逻辑了。</p><p>结果：</p><ul><li>JVM1 和 JVM2 各自都创建了一份订单，<strong>违反了一人一单的规则</strong>！</li></ul><p>现在就要实现让多个JVM使用的是同一把锁。跨JVM、跨进程的锁。</p><h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>什么是分布式锁?</p><p>满足分布式系统或集群模式下多进程可见并且互斥的锁.(所有服务器都能访问的共享锁系统)</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-174.png" alt="img"></p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><ul><li>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-175.png" alt="img"></p><p>常见的分布式锁有三种</p><ul><li>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</li><li>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</li><li>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-176.png" alt="img"></p><h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>你可以把它理解成在 Redis 里“占一个位置”，谁先占上就有执行权，其它人就得等。</p><p>实现分布式锁时需要实现的两个基本方法：</p><h4 id="4-2-1实现-Redis-锁最核心的就两个指令："><a href="#4-2-1实现-Redis-锁最核心的就两个指令：" class="headerlink" title="4.2.1实现 Redis 锁最核心的就两个指令："></a>4.2.1实现 Redis 锁最核心的就两个指令：</h4><p><strong>1. <code>SETNX</code>（Set if Not Exists）</strong></p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX <span class="keyword">lock</span> thread1</span><br></pre></td></tr></table></figure><p>意思是：“如果这个 <code>lock</code> 键不存在，就设置为 <code>thread1</code>。”</p><ul><li><strong>成功返回 1</strong>：说明你拿到锁了；</li><li><strong>失败返回 0</strong>：说明别人已经抢先拿到锁。</li></ul><h3 id="2-DEL：释放锁"><a href="#2-DEL：释放锁" class="headerlink" title="2. DEL：释放锁"></a>2. <code>DEL</code>：释放锁</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL <span class="keyword">lock</span></span><br></pre></td></tr></table></figure><p>释放锁，表示任务做完了，别人可以来了。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-177.png" alt="img"></p><h4 id="4-2-2设置过期时间，避免死锁"><a href="#4-2-2设置过期时间，避免死锁" class="headerlink" title="4.2.2设置过期时间，避免死锁"></a>4.2.2设置过期时间，避免死锁</h4><h3 id="为什么需要加-EXPIRE？"><a href="#为什么需要加-EXPIRE？" class="headerlink" title="为什么需要加 EXPIRE？"></a>为什么需要加 <code>EXPIRE</code>？</h3><p>假设：</p><ul><li>线程1 拿到了锁；</li><li>但它崩溃了，没来得及释放锁（<code>DEL</code> 没执行）；</li><li>那这把锁就<strong>永远卡在那里</strong>了，别人都拿不到！</li></ul><p>解决办法：<strong>设置锁的自动过期时间</strong>，例如 5 秒钟：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">EXPIRE</span> lock <span class="number">5</span></span><br></pre></td></tr></table></figure><p>然后可以用 <code>TTL lock</code> 查看锁剩下多少秒：</p><ul><li>正常返回剩余时间；</li><li>如果返回 -1，说明没有过期时间，会死锁；</li><li>如果返回 -2，说明锁已经不存在。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-178.png" alt="img"></p><h4 id="4-2-3避免-SETNX-和-EXPIRE-之间的间隙"><a href="#4-2-3避免-SETNX-和-EXPIRE-之间的间隙" class="headerlink" title="4.2.3避免 SETNX 和 EXPIRE 之间的间隙"></a>4.2.3避免 <code>SETNX</code> 和 <code>EXPIRE</code> 之间的间隙</h4><p>问题来了：<br>如果你分两步执行——先 <code>SETNX</code> 拿锁，再 <code>EXPIRE</code> 设置过期时间，在这中间一旦宕机，就会出问题。</p><p>正确做法：用 Redis 的一条原子指令</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">lock</span> thread EX <span class="number">10</span> NX</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>EX 10</code>：设置过期时间 10 秒；</li><li><code>NX</code>：只有在 key 不存在时才设置；</li><li>这是 Redis 的原子操作，<strong>设置值+过期+互斥一次完成</strong>！</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-179.png" alt="img"></p><p>加锁效果演示</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">lock</span> thread EX <span class="number">10</span> NXOK</span><br></pre></td></tr></table></figure><p>说明加锁成功。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">lock</span> thread EX <span class="number">10</span> NXnull</span><br></pre></td></tr></table></figure><p>说明锁已存在，加锁失败。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TTL <span class="keyword">lock</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>说明锁还有 7 秒就会自动释放。</p><h4 id="4-2-4加锁与释放的正确流程总结"><a href="#4-2-4加锁与释放的正确流程总结" class="headerlink" title="4.2.4加锁与释放的正确流程总结"></a>4.2.4加锁与释放的正确流程总结</h4><ul><li>获取锁：<ul><li>互斥性：确保只能有一个线程获取锁成功</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li><li>自动过期：避免死锁</li></ul></li><li>释放锁：<ul><li>手动释放（业务完成后 <code>DEL</code>）</li><li>超时释放：获取锁时添加一个超时时间</li></ul></li></ul><h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><p>在utils下面创建一个ILock接口：</p><p>这一步是做接口编程，便于后期扩展（比如换 Redisson 或 ZooKeeper 锁时，不改业务逻辑）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeoutSec)</span></span>;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在utils下面实现SimpleRedisLock类：</p><h3 id="细节解释："><a href="#细节解释：" class="headerlink" title="细节解释："></a>细节解释：</h3><ul><li><code>threadId</code>：当前线程的唯一标识，设置为锁的值，便于后期扩展安全性；</li><li><code>setIfAbsent</code>：就是 Redis 的 <code>SET key value NX EX</code> 操作；</li><li><code>timeoutSec</code>：自动过期时间，防止死锁；</li><li><code>delete</code>：释放锁，直接删掉对应 Redis key。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">StringRedisTemplate</span> stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">SimpleRedisLock</span>(<span class="title class_">String</span> name, <span class="title class_">StringRedisTemplate</span> stringRedisTemplate) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stringRedisTemplate</span> = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="title class_">String</span> <span class="variable constant_">KEY_PREFIX</span> = <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">tryLock</span>(<span class="params">long timeoutSec</span>) &#123;</span><br><span class="line">        <span class="comment">//获取线程标示</span></span><br><span class="line">        long threadId = <span class="title class_">Thread</span>.<span class="title function_">currentThread</span>().<span class="title function_">getId</span>();</span><br><span class="line">        <span class="title class_">Boolean</span> success = stringRedisTemplate.<span class="title function_">opsForValue</span>().<span class="title function_">setIfAbsent</span>(<span class="variable constant_">KEY_PREFIX</span>+name,threadId+<span class="string">&quot;&quot;</span>,timeoutSec, <span class="title class_">TimeUnit</span>.<span class="property">SECONDS</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Boolean</span>.<span class="property">TRUE</span>.<span class="title function_">equals</span>(success);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">unlock</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        stringRedisTemplate.<span class="title function_">delete</span>(<span class="variable constant_">KEY_PREFIX</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改VoucherOrderServiceImpl类中的seckillVoucher方法的代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Result <span class="title">seckillVoucher</span><span class="params">(Long voucherId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.查询优惠券信息</span></span><br><span class="line">    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">    <span class="comment">//2.1秒杀尚未开始返回异常</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;秒杀尚未开始&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.2秒杀已结束返回异常</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;秒杀已经结束&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    voucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">//3.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock()&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//3.1库存不足返回异常</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;库存不足！&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    SimpleRedisLock lock = <span class="keyword">new</span> SimpleRedisLock(<span class="string">&quot;order:&quot;</span>+userId,stringRedisTemplate);</span><br><span class="line">    <span class="keyword">boolean</span> isLock = lock.tryLock(<span class="number">1200</span>);</span><br><span class="line">    <span class="comment">//判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(!isLock) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;不允许重复下单&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="function"><span class="keyword">return</span> proxy.<span class="title">createVoucherOrder</span><span class="params">(voucherId)</span></span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心代码：</strong></p><p>在 <code>VoucherOrderServiceImpl</code> 里替换原来的加锁方式，改用 <code>SimpleRedisLock</code>：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleRedisLock <span class="keyword">lock</span> = <span class="built_in">new</span> SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br><span class="line"><span class="type">boolean</span> isLock = <span class="keyword">lock</span>.tryLock(<span class="number">1200</span>);</span><br></pre></td></tr></table></figure><p>如果加锁成功，就调用代理对象创建订单；失败就说明这个用户已经在处理中，拒绝重复下单。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;不允许重复下单&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="function"><span class="keyword">return</span> proxy.<span class="title">createVoucherOrder</span><span class="params">(voucherId)</span></span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试多台节点相同用户只能获取同一张优惠券成功： </p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-180.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-181.png" alt="img"></p><p>目前这个锁实现 <strong>仍有风险</strong>：</p><ul><li>❗️直接 delete key，<strong>没有验证是否是自己加的锁就删了</strong>（容易误删别人的锁）；</li><li>❗️如果执行时间超过了过期时间（比如 2 秒），锁会自动释放，但任务还没做完，另一个线程就可能抢到锁并重复执行！</li></ul><p>这些问题后面会通过加<strong>唯一标识 + Lua 脚本释放锁</strong>方式改进。</p><h3 id="4-4Redis分布式锁误删情况说明"><a href="#4-4Redis分布式锁误删情况说明" class="headerlink" title="4.4Redis分布式锁误删情况说明"></a>4.4Redis分布式锁误删情况说明</h3><p>如果你没有校验“这把锁是不是我加的”，就可能会发生这种错误：</p><blockquote><p>一个线程因为卡顿或网络问题，<strong>等它醒来时，这把锁已经被别人拿走了，但它还以为是自己的，就把别人的锁删了！</strong></p></blockquote><p>逻辑说明：</p><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><strong>总结一句话就是</strong>：<strong>不要用 <code>delete</code> 直接释放锁</strong>，一定要检查“这把锁是不是我加的”再删，<strong>用 Lua 脚本保证原子性</strong>，否则就会在多线程或多机器环境下删错别人的锁！</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-183-1024x428.png" alt="img"></p><h4 id="图中流程详解"><a href="#图中流程详解" class="headerlink" title="图中流程详解"></a>图中流程详解</h4><h4 id="▶-线程1："><a href="#▶-线程1：" class="headerlink" title="▶ 线程1："></a>▶ 线程1：</h4><ul><li>成功加锁并执行业务逻辑；</li><li>中途“卡住了”（可能是网络、GC 等卡顿）；</li><li>锁过期后，<strong>自动释放</strong>；</li><li>线程1 后续恢复，<strong>继续执行 delete</strong>，但这时锁已经不是它的了！</li></ul><h4 id="▶-线程2："><a href="#▶-线程2：" class="headerlink" title="▶ 线程2："></a>▶ 线程2：</h4><ul><li>线程1卡住时，锁过期；</li><li>它尝试加锁，成功（因为 Redis 已自动释放）；</li><li>它开始执行自己的业务。</li></ul><h4 id="▶-问题来了："><a href="#▶-问题来了：" class="headerlink" title="▶ 问题来了："></a>▶ 问题来了：</h4><ul><li>线程1 <strong>后知后觉</strong>地恢复并执行 <code>DEL lock</code>；</li><li>此时锁的值已变成线程2的标识；</li><li>但它仍然执行 delete，<strong>误删了线程2的锁</strong>！</li><li>线程3 也进来了，它就能获取锁，造成并发访问，<strong>逻辑错乱</strong>！</li></ul><h3 id="4-5-解决Redis分布式锁误删问题"><a href="#4-5-解决Redis分布式锁误删问题" class="headerlink" title="4.5 解决Redis分布式锁误删问题"></a>4.5 解决Redis分布式锁误删问题</h3><p>目标：锁释放前先校验“锁是我加的”</p><p>新需求：</p><ul><li>加锁时：存入<strong>线程标识</strong>（如：UUID + Thread ID）；</li><li>解锁时：先取出 Redis 里的标识；<ul><li>如果和当前线程一致：才能删锁；</li><li>否则：不删，防止误删。</li></ul></li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-184.png" alt="img"></p><p>首先要修改SimpleRedisLock里面的如下代码，主要是调用hutool工具包生成UUID（每次线程调用都会生成一个唯一的UUID），让Redis的前缀变成UUID+线程ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.fastUUID().toString(<span class="literal">true</span>)+<span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">//获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX+name,threadId,timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要修改的是SimpleRedisLock类里面的unlock方法，主要是比较当前线程的标示和Redis中锁的标示是否一致，只有标示一致才能释放锁：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">unlock</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//获取线程标示</span></span><br><span class="line">    <span class="title class_">String</span> threadId = <span class="variable constant_">ID_PREFIX</span> + <span class="title class_">Thread</span>.<span class="title function_">currentThread</span>().<span class="title function_">getId</span>();</span><br><span class="line">    <span class="comment">//获取锁中的标示</span></span><br><span class="line">    <span class="title class_">String</span> id = stringRedisTemplate.<span class="title function_">opsForValue</span>().<span class="title function_">get</span>(<span class="variable constant_">KEY_PREFIX</span> + name);</span><br><span class="line">    <span class="keyword">if</span>(threadId.<span class="title function_">equals</span>(id))&#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        stringRedisTemplate.<span class="title function_">delete</span>(<span class="variable constant_">KEY_PREFIX</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一句话：通过加“线程唯一标识”，并在释放锁时比对这个标识，成功解决 Redis 分布式锁的<strong>误删问题</strong>，确保只有“加锁者”才能“解锁”。</p><h3 id="4-6-分布式锁的原子性问题"><a href="#4-6-分布式锁的原子性问题" class="headerlink" title="4.6 分布式锁的原子性问题"></a>4.6 分布式锁的原子性问题</h3><p>更为极端的误删逻辑说明：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-186-1024x441.png" alt="img"></p><ul><li><strong>线程1</strong> 获取锁成功（锁标识是线程1的 UUID）；</li><li>执行业务；</li><li>准备释放锁，<strong>正在判断锁是不是自己的</strong>（这个时候判断成功）；</li><li>但是！<strong>就在这一步之后线程1突然被卡住</strong>（阻塞或宕机）；</li><li>锁超时后被 Redis 自动释放；</li><li><strong>线程2、线程3</strong> 先后获取锁并执行业务；</li><li>线程1 醒来，继续往下执行 delete，<strong>把线程2或3的锁删掉了</strong>！！</li></ul><h4 id="关键问题：判断-删除不是原子操作"><a href="#关键问题：判断-删除不是原子操作" class="headerlink" title="关键问题：判断 + 删除不是原子操作"></a>关键问题：<strong>判断 + 删除不是原子操作</strong></h4><p>这两个操作之间一旦出现“卡顿、延迟、调度切换”等非预期情况，就可能导致你<strong>误删了别人的锁</strong>，即便你之前已经做了线程标识校验。</p><p>解决方案：<strong>用 Lua 脚本让“判断+删除”原子执行</strong></p><h3 id="4-7-Lua脚本解决多条命令原子性问题"><a href="#4-7-Lua脚本解决多条命令原子性问题" class="headerlink" title="4.7 Lua脚本解决多条命令原子性问题"></a>4.7 Lua脚本解决多条命令原子性问题</h3><h4 id="为什么用-Lua？"><a href="#为什么用-Lua？" class="headerlink" title="为什么用 Lua？"></a>为什么用 Lua？</h4><blockquote><p>答：Redis 提供的 <code>EVAL</code> 命令支持在服务端运行 Lua 脚本，能让多个 Redis 命令组成 <strong>一个不可拆分的原子操作</strong>。</p></blockquote><p>Redis提供Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p><p>Lua是一种编程语言，它的基本语法可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p><h4 id="4-7-1Lua-脚本基本语法"><a href="#4-7-1Lua-脚本基本语法" class="headerlink" title="4.7.1Lua 脚本基本语法"></a>4.7.1Lua 脚本基本语法</h4><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="built_in">call</span>(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><p>例如，我们要执行set name jack，则脚本是这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 <span class="keyword">set</span> <span class="type">name</span> jack</span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 <span class="keyword">set</span> <span class="type">name</span> jack</span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 <span class="keyword">get</span> <span class="type">name</span></span><br><span class="line"><span class="keyword">local</span> <span class="type">name</span> = redis.<span class="keyword">call</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> <span class="type">name</span></span><br></pre></td></tr></table></figure><h4 id="4-7-2-使用-EVAL-调用脚本"><a href="#4-7-2-使用-EVAL-调用脚本" class="headerlink" title="4.7.2 使用 EVAL 调用脚本"></a>4.7.2 使用 EVAL 调用脚本</h4><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">EVAL</span> <span class="string">&quot;脚本内容&quot;</span> numkeys key1 [key2 …] arg1 [arg2 …]</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-187-1024x233.png" alt="img"></p><p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-188.png" alt="img"></p><h4 id="4-7-3-参数动态传入方式"><a href="#4-7-3-参数动态传入方式" class="headerlink" title="4.7.3. 参数动态传入方式"></a>4.7.3. 参数动态传入方式</h4><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-189-1024x137.png" alt="img"></p><ul><li><code>1</code>：表示有一个 key 参数</li><li><code>KEYS[1] = name</code>，<code>ARGV[1] = Rose</code></li></ul><p>接下来我们来回一下我们释放锁的逻辑：</p><p>目标：让以下逻辑变成一个原子操作：</p><ol><li>读取锁的值</li><li>比较值是否等于当前线程标识</li><li>如果一致，释放锁</li><li>如果不一致，不做任何操作</li></ol><p>如果用Lua脚本来表示则是这样的：</p><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="keyword">call</span>(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.<span class="keyword">call</span>(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="总结一句话"><a href="#总结一句话" class="headerlink" title="总结一句话"></a>总结一句话</h4><blockquote><p>把“判断是不是自己 + 删除锁”这两步放进 Lua 脚本中交给 Redis 原子执行，彻底解决分布式锁的并发安全问题。</p><h3 id="4-8-利用Java代码调用Lua脚本改造分布式锁"><a href="#4-8-利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="4.8 利用Java代码调用Lua脚本改造分布式锁"></a>4.8 利用Java代码调用Lua脚本改造分布式锁</h3><p>在SimpleRedisLock中写入如下的代码，因为我们希望的是在一开始就将Lua的脚本加载好，而不是等到要调用释放锁的时候再去加载Lua脚本，所以采用静态变量和静态代码块，这些部分在类初始化的时候就会被加载：</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;<span class="keyword">Long</span>&gt; UNLOCK_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">     UNLOCK_SCRIPT = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">     UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">     UNLOCK_SCRIPT.setResultType(<span class="keyword">Long</span>.<span class="keyword">class</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ul><li><code>DefaultRedisScript</code> 是 Spring 提供的类；</li><li><code>setLocation</code> 是加载 Lua 脚本文件；</li><li><code>setResultType</code> 是告诉 Redis 你这个脚本要返回什么类型。</li></ul><blockquote><p>在SimpleRedisLock类的unlock方法中写入如下的代码：</p><p>在 <code>SimpleRedisLock</code> 的 <code>unlock()</code> 方法中，替换原来的 delete 逻辑：</p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void <span class="built_in">unlock</span>() &#123;</span><br><span class="line">    <span class="selector-tag">stringRedisTemplate</span><span class="selector-class">.execute</span>(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.<span class="built_in">singletonList</span>(KEY_PREFIX+name),</span><br><span class="line">            ID_PREFIX + Thread.<span class="built_in">currentThread</span>().<span class="built_in">getId</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在执行 Lua 脚本时：</p><ul><li><code>KEYS[1] = lock:order:xxx</code>（锁的 key）；</li><li><code>ARGV[1] = UUID-threadId</code>（锁的值，用于身份验证）；</li></ul><p><strong>RedisTemplate 是如何执行 Lua 的？</strong></p><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-190-1024x476.png" alt="img"></p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><p>在程序1和程序2的下面这个位置打上断点：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-191.png" alt="img"></p><p>在测试API中测试访问如下的URL：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>localhost:<span class="number">8080</span><span class="regexp">/api/</span>voucher-order<span class="regexp">/seckill/</span><span class="number">14</span></span><br></pre></td></tr></table></figure><p>分别测试秒杀优惠券1和2：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-192.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-193.png" alt="img"></p><p>在Redis中能看到程序1获取锁成功，然后直接把lock锁删掉，模拟超时释放的情况：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-194.png" alt="img"></p><p>然后让程序2往下走一步，可以看到程序2获取到了锁</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-195.png" alt="img"></p><p>然后可以直接放行程序1，会看到结果是程序2加的锁没有被删除。</p><p>最后放行程序2，会看到程序2加的锁被删除。</p><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁</li><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>已经把 Redis 分布式锁从“能用”优化到“高并发可安全用”的版本，使用 Lua 脚本在 Java 中原子释放锁，是实现这一切的关键一步。</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><h2 id="5、分布式锁-redission"><a href="#5、分布式锁-redission" class="headerlink" title="5、分布式锁-redission"></a>5、分布式锁-redission</h2><h3 id="5-1-分布式锁-redission功能介绍"><a href="#5-1-分布式锁-redission功能介绍" class="headerlink" title="5.1 分布式锁-redission功能介绍"></a>5.1 分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><ol><li><strong>不可重入</strong></li></ol><ul><li>含义：同一个线程在还没释放锁时，又想再次获取这个锁，不能成功（会被自己阻塞）；</li><li>举例：就像你在方法 A 拿了锁，然后方法 A 又调用了 B，而 B 又要拿同一把锁，就挂住了；</li><li><strong>风险</strong>：递归调用/多层封装下容易死锁；</li><li><code>synchronized</code>/<code>ReentrantLock</code> 是可重入的，而原始 Redis 实现不是。</li><li><p><strong>不可重试</strong></p></li><li><p>含义：获取失败一次就放弃，没有“等待+重试”机制；</p></li><li><strong>问题</strong>：并发环境下，很多线程抢锁失败后立刻返回，<strong>不能等待排队</strong>，业务体验差。</li><li><p><strong>超时释放有风险</strong></p></li><li><p>加锁时设置了过期时间，防止死锁；</p></li><li><strong>但</strong>：如果业务执行时间过长，锁先过期了；</li><li>别人进来抢锁，你业务还没做完；</li><li>即使你用 Lua 判断 + 删除，也只能避免误删，但<strong>无法保证锁一定有效到你业务真正执行完毕</strong>；</li><li><strong>结论</strong>：需要“锁续期机制”来保持锁有效！</li><li><p><strong>主从一致性问题（分布式集群）</strong></p></li><li><p>Redis 使用主从集群时，写入数据是先写主节点，再同步给从节点；</p></li><li>如果在写成功前主节点挂了，但从节点没有拿到同步数据，<strong>从节点会认为锁没被加，导致锁被重复加</strong>；</li><li><strong>结果：多个线程同时进入临界区，锁形同虚设</strong>；</li><li>这个问题是 Redis 本身架构的弱点，单靠你手写逻辑不好处理。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-196.png" alt="img"></p><h4 id="总结一句话："><a href="#总结一句话：" class="headerlink" title="总结一句话："></a>总结一句话：</h4><blockquote><p>自己写的 Redis 分布式锁，虽然能用，但存在 <strong>不可重入、不可续期、无排队、不稳定</strong> 等问题，在真正生产环境里不够健壮。</p></blockquote><p><strong>什么是Redission呢</strong></p><p>Redisson 是一个基于 Redis 的 Java 客户端框架，它封装了很多分布式服务，其中包括各种类型的 <strong>分布式锁实现</strong>，还带有“自动续期”、“可重入”、“公平锁”、“读写锁”等高级功能。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-203.png" alt="img"></p><h3 id="5-2-分布式锁-Redission快速入门"><a href="#5-2-分布式锁-Redission快速入门" class="headerlink" title="5.2 分布式锁-Redission快速入门"></a>5.2 分布式锁-Redission快速入门</h3><p>第1步，先引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第2步，在config包下创建RedissonConfig类，写入如下代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Bean</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        Config config = <span class="keyword">new</span> <span class="built_in">Config</span>();</span><br><span class="line">        config.<span class="built_in">useSingleServer</span>().<span class="built_in">setAddress</span>(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .<span class="built_in">setPassword</span>(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.<span class="built_in">create</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h3><ul><li>创建并注册 <code>RedissonClient</code> Bean；</li><li>使用 <code>useSingleServer()</code> 表示你使用的是单机 Redis（后期可以切换为集群模式）；</li><li>注意地址前缀是 <code>redis://</code>；</li><li>密码如果 Redis 没设可以不写 <code>.setPassword(...)</code>。</li></ul><p>第3步，引入RedissonClient，调用getLock获取锁对象，然后用tryLock获取锁。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testRedisson</span>() throws Exception</span>&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    RLock <span class="keyword">lock</span> = redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    boolean isLock = <span class="keyword">lock</span>.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><code>tryLock(1, 10, TimeUnit.SECONDS)</code>：</p><ul><li><strong>1 秒内尝试获取锁</strong>（抢不到就放弃）；</li><li>锁持有 <strong>10 秒后自动释放</strong>；</li></ul><p><code>lock.unlock()</code>：安全释放锁，防止阻塞；</p><p>Redisson 内部已经自动实现了线程标识、防误删、自动续期等逻辑。</p><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Result <span class="title">seckillVoucher</span><span class="params">(Long voucherId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;秒杀尚未开始！&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;秒杀已经结束！&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;库存不足！&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//获取锁对象</span></span><br><span class="line">        <span class="keyword">boolean</span> isLock = lock.tryLock();</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(<span class="string">&quot;不允许重复下单&quot;</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="function"><span class="keyword">return</span> proxy.<span class="title">createVoucherOrder</span><span class="params">(voucherId)</span></span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h3><ul><li><code>lock:order:userId</code>：给每个用户设置唯一的锁，防止同一用户重复下单；</li><li>使用 <code>tryLock()</code> 获取锁（默认立即尝试获取一次）；</li><li>Redisson 自动处理续期和线程隔离（不需要你手动判断 UUID + 线程 ID）；</li><li>释放锁直接调用 <code>.unlock()</code>，更简单更安全。</li></ul><p>第4步，启动服务</p><p>发送下面的请求：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-198.png" alt="img"></p><p>在执行释放锁的语句前，可以看到Redis中有锁的记录：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-199.png" alt="img"></p><p>用jmeter来测试，可以发现没有出现并发安全问题：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-200.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-201.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-202.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-204.png" alt="img"></p><h3 id="5-3-分布式锁-redission可重入锁原理"><a href="#5-3-分布式锁-redission可重入锁原理" class="headerlink" title="5.3 分布式锁-redission可重入锁原理"></a>5.3 分布式锁-redission可重入锁原理</h3><h4 id="5-3-1重入锁的概念（本地锁和分布式锁通用）"><a href="#5-3-1重入锁的概念（本地锁和分布式锁通用）" class="headerlink" title="5.3.1重入锁的概念（本地锁和分布式锁通用）"></a>5.3.1<strong>重入锁的概念（本地锁和分布式锁通用）</strong></h4><p>可重入锁（Reentrant Lock）允许 <strong>同一个线程重复获取同一把锁</strong>。</p><ul><li>例如一个线程调用了两次 <code>lock.lock()</code>，只要线程一致，不会死锁。解锁时必须解锁两次才彻底释放。</li></ul><h4 id="5-3-2本地锁（如-Java-ReentrantLock）的实现机制"><a href="#5-3-2本地锁（如-Java-ReentrantLock）的实现机制" class="headerlink" title="5.3.2本地锁（如 Java ReentrantLock）的实现机制"></a>5.3.2<strong>本地锁（如 Java ReentrantLock）的实现机制</strong></h4><ul><li><p>通过一个 </p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile <span class="keyword">state</span></span><br></pre></td></tr></table></figure><p> 状态变量控制重入次数。</p><ul><li>初始状态：<code>state = 0</code> 表示没人持有。</li><li>第一次获取：<code>state = 1</code></li><li>同一线程再次获取：<code>state += 1</code></li><li>每次释放：<code>state -= 1</code></li><li>当 <code>state == 0</code>，锁释放成功。</li></ul></li></ul><h4 id="5-3-3Redisson-可重入分布式锁实现原理"><a href="#5-3-3Redisson-可重入分布式锁实现原理" class="headerlink" title="5.3.3Redisson 可重入分布式锁实现原理"></a>5.3.3<strong>Redisson 可重入分布式锁实现原理</strong></h4><h4 id="1-Redis-中如何存储锁？"><a href="#1-Redis-中如何存储锁？" class="headerlink" title="1. Redis 中如何存储锁？"></a>1. Redis 中如何存储锁？</h4><ul><li><p>使用 </p><p>Hash 结构</p><p> 存储：</p><ul><li>Key：锁的名称（如 <code>&quot;lock&quot;</code>）</li><li>Field（小key）：<code>UUID:ThreadId</code> 表示哪个线程持有锁</li><li>Value：重入次数，例如 <code>1</code> 表示加锁了一次</li></ul></li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock &#123;</span><br><span class="line">  thread1 : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.锁的获取逻辑</strong></p><p>情况1：锁不存在，直接加锁</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.<span class="keyword">call</span>(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">  redis.<span class="keyword">call</span>(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">  redis.<span class="keyword">call</span>(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> nil;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>判断锁是否存在（<code>exists</code>）</li><li>如果不存在，设置 hash <code>field = threadId</code>，值为 1（加锁一次）</li><li>设置过期时间（防止死锁）</li><li>返回 <code>nil</code>，表示加锁成功</li></ul><p>情况2：锁存在，且是自己线程持有（可重入）</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(<span class="string">&#x27;hexists&#x27;</span>, <span class="symbol">KEYS</span>[<span class="number">1</span>], <span class="symbol">ARGV</span>[<span class="number">2</span>]) == <span class="number">1</span> then</span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, <span class="symbol">KEYS</span>[<span class="number">1</span>], <span class="symbol">ARGV</span>[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, <span class="symbol">KEYS</span>[<span class="number">1</span>], <span class="symbol">ARGV</span>[<span class="number">1</span>]);</span><br><span class="line">  return nil;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>判断当前线程是否已持有（<code>hexists</code>）</li><li>如果是：<code>hincrby</code> 锁计数 +1</li><li>续期（<code>pexpire</code>）</li><li>返回 <code>nil</code> 表示加锁成功（重入）</li></ul><p>情况3：锁被其他线程持有</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">return</span> redis.<span class="title">call</span><span class="params">(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>返回剩余过期时间</li><li>Java 端根据返回值是否是 <code>null</code> 判断是否加锁成功，如果失败会进行 <strong>自旋重试</strong>（while(true) 循环）</li></ul><p>完整代码</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;</span>exists&#x27;, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> <span class="string">&quot; +</span></span><br><span class="line"><span class="string">                  &quot;</span>redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); <span class="string">&quot; +</span></span><br><span class="line"><span class="string">                  &quot;</span>redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); <span class="string">&quot; +</span></span><br><span class="line"><span class="string">                  &quot;</span><span class="keyword">return</span> nil; <span class="string">&quot; +</span></span><br><span class="line"><span class="string">              &quot;</span><span class="keyword">end</span>; <span class="string">&quot; +</span></span><br><span class="line"><span class="string">              &quot;</span><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span> <span class="string">&quot; +</span></span><br><span class="line"><span class="string">                  &quot;</span>redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); <span class="string">&quot; +</span></span><br><span class="line"><span class="string">                  &quot;</span>redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); <span class="string">&quot; +</span></span><br><span class="line"><span class="string">                  &quot;</span><span class="keyword">return</span> nil; <span class="string">&quot; +</span></span><br><span class="line"><span class="string">              &quot;</span><span class="keyword">end</span>; <span class="string">&quot; +</span></span><br><span class="line"><span class="string">              &quot;</span><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>5.3.4 释放锁的逻辑</p><ul><li>判断锁是不是自己加的（判断 field 是否是自己）</li><li><code>hincrby</code> 把锁值减1</li><li>如果减完为0，使用 <code>del</code> 删除整个锁</li><li>若不是自己线程，加锁失败</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-205-1024x443.png" alt="img"></p><p>代码说明：</p><ul><li>第一次 <code>tryLock()</code> 成功后，调用 <code>method2()</code> 再加一次锁，也成功，体现 <strong>可重入性</strong>。</li><li>每次 <code>unlock()</code> 只是让 <code>value -1</code>，直到为0，才释放 Redis 中的锁。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-207-1024x514.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-206-1024x468.png" alt="img"></p><h3 id="5-4-分布式锁-redission锁重试和WatchDog机制"><a href="#5-4-分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="5.4 分布式锁-redission锁重试和WatchDog机制"></a>5.4 分布式锁-redission锁重试和WatchDog机制</h3><h4 id="5-4-1Redisson-分布式锁中-tryLock-重试-WatchDog-自动续期的源码机制。"><a href="#5-4-1Redisson-分布式锁中-tryLock-重试-WatchDog-自动续期的源码机制。" class="headerlink" title="5.4.1Redisson 分布式锁中 tryLock 重试 + WatchDog 自动续期的源码机制。"></a>5.4.1Redisson 分布式锁中 tryLock 重试 + WatchDog 自动续期的源码机制。</h4><p>下面是对含有waitTime（等待时间）的tryLock的跟踪：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-208.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-209.png" alt="img"></p><p><strong>主题：<code>tryLock(long waitTime, TimeUnit unit)</code> 的源码调用链 + 默认看门狗时间为 30 秒</strong></p><p>你调用的是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tryLock</span><span class="params">(waitTime, unit)</span></span></span><br></pre></td></tr></table></figure><p>实际会调用重载方法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tryLock</span><span class="params">(waitTime, -<span class="number">1</span>L, unit)</span></span> <span class="comment">// -1 表示未指定超时时间</span></span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-210.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-211-1024x378.png" alt="img"></p><p>重点含义：</p><p><code>leaseTime = -1</code> 触发 <strong>WatchDog 看门狗机制</strong></p><p>默认配置 this.lockWatchdogTimeout = 30000L // 30秒</p><p>Lua 脚本说明</p><p>return redis.call(‘pttl’, KEYS[1]);</p><ul><li>返回当前锁剩余时间（毫秒）</li><li>如果锁被占用，则 Redisson 用这个值判断是否自旋重试</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-212.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-213.png" alt="img"></p><p><strong>主题：锁的获取流程和释放锁的 Lua 脚本实现逻辑</strong></p><p>获取锁逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 加锁成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则进入剩余时间判断：是否还有等待机会。</p><p>释放锁逻辑（Redis 脚本）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]); <span class="comment">// 发布解锁通知</span></span><br></pre></td></tr></table></figure><p>当锁释放时，通过 Redis <code>publish</code> 发消息，通知其他线程“锁已释放”，以唤醒它们继续抢锁。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-214.png" alt="img"></p><p>说明 subscriberFuture.await：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriberFuture.await(<span class="built_in">time</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><ul><li>等待一段时间内是否能收到锁释放的通知（订阅模式）</li><li>如果 <code>false</code>，表示<strong>超时未收到通知</strong></li></ul><p>后续继续抢锁：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tryAcquire</span><span class="params">(waitTime, leaseTime, unit, threadId)</span></span></span><br></pre></td></tr></table></figure><p>会再调用这个方法尝试重新获取锁。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-215.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-216.png" alt="img"></p><p>Redisson 并非死等，而是结合“等待发布+主动抢锁”，避免资源浪费。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-217.png" alt="img"></p><p>主题：触发 WatchDog 续期的逻辑（重点）</p><p>条件判断：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (leaseTime <span class="operator">=</span><span class="operator">=</span> -<span class="number">1</span>) // 表示未指定锁时间</span><br></pre></td></tr></table></figure><p>那么 Redisson 将默认使用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getLockWatchdogTimeout</span><span class="params">()</span></span> = <span class="number">30</span>_000 ms</span><br></pre></td></tr></table></figure><p>成功加锁后调用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scheduleExpirationRenewal</span>(threadId); <span class="comment">// 开启续约机制</span></span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-218.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-219.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-220.png" alt="img"></p><p>主题：WatchDog 定时任务如何每 10 秒自动续期</p><p>核心逻辑：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.<span class="built_in">int</span>ernalLockLeaseTime / <span class="number">3</span></span><br></pre></td></tr></table></figure><p>默认锁时间是 30 秒，所以每 <strong>10秒调用一次</strong> <code>renewExpiration()</code>，实现持续续期。</p><p>Lua脚本中的续期操作：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); <span class="comment">// 续期锁有效时间</span></span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-221.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-222.png" alt="img"></p><p>主题：取消看门狗续期任务（释放锁时触发）</p><p>解锁后调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.cancelExpirationRenewal(threadId)</span><br></pre></td></tr></table></figure><ul><li>作用：停止定时器，释放线程资源</li><li>只有当锁真正释放或者线程结束时，才会取消续期逻辑，确保资源不浪费</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-223.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-224.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-225-1024x524.png" alt="img"></p><h4 id="加锁逻辑总结："><a href="#加锁逻辑总结：" class="headerlink" title="加锁逻辑总结："></a>加锁逻辑总结：</h4><ul><li><p>ttl == null</p><p>：获取锁成功</p><ul><li>leaseTime == -1：开启自动续期（WatchDog）</li><li>leaseTime != -1：定时释放锁，不续期</li></ul></li><li><p>ttl != null</p><p>：获取锁失败</p><ul><li>剩余时间 &gt; 0：订阅解锁信号</li><li>等待并判断是否超时，进行下一轮尝试</li></ul></li></ul><h4 id="解锁逻辑："><a href="#解锁逻辑：" class="headerlink" title="解锁逻辑："></a>解锁逻辑：</h4><ul><li>成功释放后，<code>publish</code> 发布消息通知等待线程</li><li>取消续约任务，清理 <code>EXIPRATION_RENEWAL_MAP</code></li></ul><p><strong>总结一句话：Redisson 分布式锁 = <code>Redis + Lua + Java定时任务</code> 实现了一个 可重入、自动续期、带发布通知机制的分布式锁系统，健壮且高性能。</strong></p><h4 id="5-4-2Redisson-的两种加锁方式"><a href="#5-4-2Redisson-的两种加锁方式" class="headerlink" title="5.4.2Redisson 的两种加锁方式"></a>5.4.2Redisson 的两种加锁方式</h4><p>Redisson 的 <code>lock()</code> 方法分为两种情况：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>lock(long leaseTime, TimeUnit unit)</code></td><td><strong>指定锁的超时时间</strong>，不会启动看门狗</td></tr><tr><td><code>lock()</code>（无参）</td><td><strong>未指定锁超时时间</strong>，Redisson 会自动启动 <strong>WatchDog</strong> 定时续约机制</td></tr></tbody></table></div><h4 id="5-4-3lock-加锁流程回顾"><a href="#5-4-3lock-加锁流程回顾" class="headerlink" title="5.4.3lock() 加锁流程回顾"></a>5.4.3lock() 加锁流程回顾</h4><p>1.获取当前线程 ID</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long threadId <span class="operator">=</span> Thread.currentThread().getId()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>2.尝试加锁（tryAcquire）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Long</span> ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 加锁成功或重入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若返回值为 <code>null</code>，表示加锁成功（或是当前线程重入）<br>若返回 <code>ttl</code>（过期时间），表示锁被其他线程占用，进入 <code>while(true)</code> 自旋重试逻辑</p><h4 id="5-4-4三种加锁场景逻辑判断（tryAcquire-内部）"><a href="#5-4-4三种加锁场景逻辑判断（tryAcquire-内部）" class="headerlink" title="5.4.4三种加锁场景逻辑判断（tryAcquire 内部）"></a>5.4.4三种加锁场景逻辑判断（tryAcquire 内部）</h4><div class="table-container"><table><thead><tr><th>情况</th><th>Redis 逻辑</th><th>说明</th></tr></thead><tbody><tr><td>锁不存在</td><td><code>hset</code> + <code>pexpire</code></td><td>直接加锁成功</td></tr><tr><td>锁是当前线程持有</td><td><code>hincrby</code> + <code>pexpire</code></td><td>可重入，计数+1</td></tr><tr><td>锁存在，非当前线程</td><td>返回剩余过期时间</td><td>加锁失败，等待自旋重试</td></tr></tbody></table></div><h4 id="5-4-5-重试机制（循环抢锁）"><a href="#5-4-5-重试机制（循环抢锁）" class="headerlink" title="5.4.5 重试机制（循环抢锁）"></a>5.4.5 重试机制（循环抢锁）</h4><p>如果初始加锁失败，会进入以下逻辑：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    tryAcquire() <span class="comment">// 不断尝试获取锁</span></span><br><span class="line">    <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redisson 会自旋尝试，直到获取锁成功或超时。</p><h4 id="5-4-6-看门狗机制（WatchDog）"><a href="#5-4-6-看门狗机制（WatchDog）" class="headerlink" title="5.4.6 看门狗机制（WatchDog）"></a>5.4.6 看门狗机制（WatchDog）</h4><h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><p>调用 <code>lock()</code> <strong>无参</strong>版本时，不指定 <code>leaseTime</code>，Redisson 默认设置锁有效期为 <strong>30秒</strong>，并会启动 <strong>自动续期机制</strong>。</p><p>WatchDog 实现核心逻辑：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ttlRemainingFuture.onComplete<span class="function"><span class="params">((ttlRemaining, e) -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        scheduleExpirationRenewal(threadId);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span>;</span></span><br></pre></td></tr></table></figure><p>如果加锁成功，就调用 <code>scheduleExpirationRenewal()</code>，触发自动续期。</p><h4 id="5-4-7-续约机制源码分析（renewExpiration）"><a href="#5-4-7-续约机制源码分析（renewExpiration）" class="headerlink" title="5.4.7 续约机制源码分析（renewExpiration）"></a>5.4.7 续约机制源码分析（renewExpiration）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">renewExpiration</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 每次续期都会重新创建一个定时任务（10秒后触发）</span></span><br><span class="line">    <span class="title class_">Timeout</span> task = commandExecutor.<span class="title function_">getConnectionManager</span>().<span class="title function_">newTimeout</span>(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"><span class="title class_">Timeout</span> timeout</span>) &#123;</span><br><span class="line">            <span class="comment">// 仍持有锁 -&gt; 再续期30s</span></span><br><span class="line">            <span class="title function_">renewExpirationAsync</span>(threadId).<span class="title function_">onComplete</span>((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="title function_">renewExpiration</span>(); <span class="comment">// 递归设置下次续期</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, <span class="title class_">TimeUnit</span>.<span class="property">MILLISECONDS</span>); <span class="comment">// 默认是每10秒执行一次（30/3）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整体过程："><a href="#整体过程：" class="headerlink" title="整体过程："></a>整体过程：</h4><ol><li><strong>默认锁有效时间：30秒</strong></li><li><strong>每 10 秒（30/3）启动一个定时任务续期</strong></li><li>如果线程还活着且仍持有锁 → 重置锁的过期时间为 30秒</li><li>如果线程挂了（如宕机、异常） → 不再续期，锁自动过期释放</li></ol><h4 id="5-4-8-总结：Redisson-锁的核心机制"><a href="#5-4-8-总结：Redisson-锁的核心机制" class="headerlink" title="5.4.8 总结：Redisson 锁的核心机制"></a>5.4.8 总结：Redisson 锁的核心机制</h4><div class="table-container"><table><thead><tr><th>机制</th><th>功能</th></tr></thead><tbody><tr><td><code>tryAcquire()</code></td><td>尝试加锁逻辑，判断锁状态</td></tr><tr><td><code>while(true)</code></td><td>自旋重试机制，直到加锁成功</td></tr><tr><td><code>WatchDog</code>（看门狗）</td><td>自动续期，防止锁提前释放</td></tr><tr><td><code>renewExpiration()</code></td><td>启动定时任务每 10 秒续一次期</td></tr><tr><td>锁自动释放</td><td>线程挂掉不会续期，锁30秒后自动释放</td></tr></tbody></table></div><ul><li>看门狗机制是 <strong>线程持有锁自动续期的保障</strong>；</li><li>使用 <code>lock()</code>（无参）时 <strong>不要担心死锁</strong>，即使忘了释放锁，30秒后也会释放；</li><li>不传 <code>leaseTime</code> 才会触发 WatchDog；</li><li>Redisson 的重入锁依靠 <code>Hash结构 + 线程id + 计数</code> 实现。</li></ul><h3 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h3><p><strong>为什么需要 MultiLock？Redisson 锁丢失的背景</strong></p><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>主从同步延迟 + 宕机导致锁丢失</p><p>图中描述的是以下场景：</p><ol><li>Java 应用尝试获取 Redis 锁：<code>SET lock thread1 NX EX 10</code>（设置锁）</li><li>锁成功设置到 Redis <strong>主节点</strong>（Master）</li><li>Redis 主节点还未将锁同步到从节点（Slave）</li><li>此时主节点宕机了</li><li>Redis 自动从 Slave 中选出一个新的 Master（原来的从节点）</li><li>由于新 Master 上 <strong>没有锁数据</strong> → 锁丢失！💥</li></ol><p>这意味着：<strong>即使你刚加完锁，锁信息也可能因为主从未同步就丢失，造成并发安全隐患！</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-226-1024x487.png" alt="img"></p><p>为了避免上述锁丢失问题，<strong>Redisson 提出了 MultiLock</strong>，也叫“多节点锁”或“联合锁”。</p><h4 id="MultiLock-核心原理："><a href="#MultiLock-核心原理：" class="headerlink" title="MultiLock 核心原理："></a>MultiLock 核心原理：</h4><ul><li>如果任何一个节点失败，则失败的锁会回滚并释放 </li><li>同时向多个 Redis 主节点加锁（比如 Redis 主机集群）</li><li>只有 <strong>所有节点都加锁成功</strong>，才算真正获取到锁 </li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-227-1024x371.png" alt="img"></p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明:当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/1653553093967-1-1024x311.png" alt="img"></p><ol><li>收集多个锁</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LockList.<span class="built_in">add</span>(lock1, lock2, lock3)</span><br></pre></td></tr></table></figure><ul><li>收集所有待加锁的 Redis 实例</li><li>设置总加锁时间：</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总超时时间 <span class="operator">=</span> 锁数量 * <span class="number">1500</span>ms</span><br></pre></td></tr></table></figure><ul><li>例如：3 个锁 → 超时时间为 4500ms</li><li>加锁流程（伪代码）：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁失败时自动重试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历每个锁，逐一尝试加锁</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">lock</span> <span class="keyword">in</span> LockList) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boolean locked = <span class="keyword">lock</span>.tryLock(<span class="number">4500</span>ms, <span class="number">-1</span>); <span class="comment">// -1：表示触发自动续期</span></span><br><span class="line">        <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">            acquiredLocks.<span class="keyword">add</span>(<span class="keyword">lock</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 加锁失败中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-成功判定条件："><a href="#5-成功判定条件：" class="headerlink" title="5. 成功判定条件："></a>5. 成功判定条件：</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果 acquiredLocks.size == LockList.size <span class="comment">// 所有锁都成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="6-如果有锁失败，回滚所有已获取的锁："><a href="#6-如果有锁失败，回滚所有已获取的锁：" class="headerlink" title="6. 如果有锁失败，回滚所有已获取的锁："></a>6. 如果有锁失败，回滚所有已获取的锁：</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlockInner(acquiredLocks); <span class="comment">// 释放所有已加锁的节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-230.png" alt="img"></p><h2 id="6、秒杀优化"><a href="#6、秒杀优化" class="headerlink" title="6、秒杀优化"></a>6、秒杀优化</h2><h3 id="6-1-秒杀优化-异步秒杀思路"><a href="#6-1-秒杀优化-异步秒杀思路" class="headerlink" title="6.1 秒杀优化-异步秒杀思路"></a>6.1 秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p><ul><li>1、查询优惠卷</li><li>2、判断秒杀库存是否足够</li><li>3、查询订单</li><li>4、校验是否是一人一单</li><li>5、扣减库存</li><li>6、创建订单</li></ul><p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-231-1024x503.png" alt="img"></p><p>原始秒杀流程（未优化）</p><p>这张图描述的是传统的秒杀请求处理流程：</p><p>流程步骤：</p><ol><li>用户发起秒杀请求，请求被 Nginx 接收并转发到 Tomcat</li><li>Tomcat 中执行串行逻辑（每一步都访问数据库）：<ul><li>查询优惠券</li><li>判断库存</li><li>查询订单（是否重复）</li><li>校验一人一单</li><li>扣减库存</li><li>创建订单</li></ul></li></ol><p>问题：</p><ul><li>所有操作都在主线程中串行执行，访问数据库频繁</li><li>请求高峰期，数据库压力爆炸，响应速度慢</li><li>容易引发 <strong>超卖</strong> 或 <strong>性能瓶颈</strong></li></ul><p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-232-1024x484.png" alt="img"></p><p>前端请求流程变更：</p><ol><li><p>用户请求发送到 Nginx</p></li><li><p>Nginx 将请求发给 Redis 进行</p><p>快速判断</p><p>：</p><ul><li>秒杀库存是否足够</li><li>是否一人一单</li></ul></li></ol><blockquote><p>   3.这两个逻辑在 Redis 中执行，响应极快，避免 Tomcat 阻塞。</p></blockquote><p>   4.后台 Tomcat 消费消息队列中的数据，执行真正的下单流程（慢慢完成）</p><p>   5.判断通过后，Redis 将 <strong>userId、orderId 等信息</strong> 存入 <strong>消息队列</strong></p><p>优势：</p><ul><li>高并发下不会压垮数据库</li><li>秒杀操作近似“无锁”，吞吐高</li><li>用户体验好（快速响应）</li><li>可扩展性强（异步处理易于伸缩）</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-233-1024x482.png" alt="img"></p><p>Redis Lua 脚本保障 <strong>库存判断 + 一人一单判断 + 写入状态</strong> 的<strong>原子性</strong>，这是关键！</p><p>Redis 数据结构设计</p><div class="table-container"><table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody><tr><td><code>stock:vid:7</code></td><td>秒杀库存（例如100）</td></tr><tr><td><code>order:vid:7</code></td><td>用户ID列表（如Set/Stream）记录下单人</td></tr></tbody></table></div><p>Lua 脚本逻辑图（左下）：</p><ol><li>判断库存是否充足（<code>if stock &lt;= 0</code>）</li><li>判断用户是否已下单（是否在 set 集合中）</li><li>若均通过：<ul><li>扣减库存</li><li>将用户加入 set 集合（防止重复）</li><li>返回成功码 <code>0</code></li></ul></li></ol><p>后续处理（右侧流程）：</p><ol><li>执行 Lua 脚本</li><li>如果返回结果为 0，说明可以下单</li><li>将 couponId、userId、orderId 加入消息队列</li><li>后台线程消费消息，执行真正的：<ul><li>校验库存（可选）</li><li>创建订单</li><li>持久化入数据库</li></ul></li></ol><h3 id="6-2-秒杀优化-Redis完成秒杀资格判断"><a href="#6-2-秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="6.2 秒杀优化-Redis完成秒杀资格判断"></a>6.2 秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p><ul><li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li><li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li><li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ul><p>这个阶段我们要实现的是：</p><div class="table-container"><table><thead><tr><th>功能</th><th>技术方案</th></tr></thead><tbody><tr><td>秒杀资格判断（库存 &amp; 一人一单）</td><td>使用 Redis + Lua 脚本，原子判断</td></tr><tr><td>异步下单处理</td><td>Redis Stream 队列 + 后台线程消费</td></tr><tr><td>快速响应用户</td><td>Redis 脚本立即返回结果（成功/失败）</td></tr><tr><td>延迟落库</td><td>后台线程根据消息内容执行真正的下单操作</td></tr></tbody></table></div><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-234.png" alt="img"></p><p>在VoucherServiceImpl的addSeckillVoucher方法的末尾添加下面这段代码把秒杀的库存保存到Redis中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存秒杀的库存到Redis</span></span><br><span class="line">stringRedisTemplate<span class="selector-class">.opsForValue</span>()<span class="selector-class">.set</span>(RedisConstants.SECKILL_STOCK_KEY +voucher.getId(),voucher<span class="selector-class">.getStock</span>()<span class="selector-class">.toString</span>());</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>SECKILL_STOCK_KEY</code> 前缀常量为 <code>&quot;seckill:stock:&quot;</code></li><li>Redis 中会生成一个 Key，例如：<code>seckill:stock:17</code>，值为库存数量</li><li>相当于秒杀券一上架，就把库存同步到了 Redis 里，后续不再访问数据库判断库存</li></ul><p>发送请求，新增一份优惠券： </p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-236.png" alt="img"></p><p>可以看到在Redis中记录了优惠券的记录：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-238.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-239.png" alt="img"></p><p>完整的VoucherServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整lua表达式</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(tonumber(redis.<span class="keyword">call</span>(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.<span class="keyword">call</span>(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="解析一下这个lua脚步"><a href="#解析一下这个lua脚步" class="headerlink" title="解析一下这个lua脚步"></a>解析一下这个lua脚步</h4><p>（1）<strong>判断库存是否足够</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>库存不足返回 1，结束逻辑</li></ul><p>（2）<strong>判断是否重复下单</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.<span class="keyword">call</span>(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">2</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><code>orderKey</code> 是 <code>seckill:order:&lt;voucherId&gt;</code>，用 Set 保存已下单用户</li></ul><p>（3）<strong>扣库存、记录下单用户</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="built_in">call</span>(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line">redis.<span class="built_in">call</span>(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br></pre></td></tr></table></figure><p>（4）<strong>写入消息队列 Stream</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="built_in">call</span>(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br></pre></td></tr></table></figure><p>使用 Redis Stream 作为消息队列，后续后台线程从这里消费数据，实现异步下单。</p><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><p>VoucherOrderServiceImpl</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Result <span class="title">seckillVoucher</span><span class="params">(Long voucherId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">long</span> orderId = redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    Long result = stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">int</span> r = result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> Result.<span class="title">ok</span><span class="params">(orderId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本执行后返回值含义：</p><div class="table-container"><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td><code>1</code></td><td>库存不足</td></tr><tr><td><code>2</code></td><td>重复下单</td></tr><tr><td><code>0</code></td><td>有秒杀资格，成功入队，异步下单中</td></tr></tbody></table></div><p>测试：</p><p>在Apifox中发送测试数据，秒杀下单，成功后返回订单id：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-240-1024x601.png" alt="img"></p><p>在Redis中库存成功扣减1，order有缓存</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-241.png" alt="img"></p><p>如果再次发送会提示不能重复下单：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-242-1024x600.png" alt="img"></p><p>准备在Jemeter中测试，首先把缓存中的优惠券库存改为200：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-243.png" alt="img"></p><p>测试后库存减为0，新增200条订单记录：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-244.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-245.png" alt="img"></p><p>可以看到平均响应时间减少10倍，最快响应时间减少60倍，最大响应时间缩短：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-246-1024x491.png" alt="img"></p><h3 id="6-3-秒杀优化-基于阻塞队列实现秒杀优化"><a href="#6-3-秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="6.3 秒杀优化-基于阻塞队列实现秒杀优化"></a>6.3 秒杀优化-基于阻塞队列实现秒杀优化</h3><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-235.png" alt="img"></p><p>阻塞队列：尝试从队列获取元素，如果没有元素会被阻塞，直到队列中有元素才会被唤醒，获取元素。 </p><p>只要类一启动，用户随时都有可能来抢购，因此VoucherOrderHandler这个类的初始化必须在类初始化后执行。</p><p>在VoucherOrderServiceImpl类中，首先要新增一个orderTasks阻塞队列，然后设置一个线程池和run方法。</p><p>在run方法中调用阻塞队列的take方法，orderTasks.take方法是一个阻塞方法，如果队列中有元素会获取，如果队列中无元素则阻塞等待。</p><p>这里相当于是开启了一个全新的线程来执行获取队列中订单信息和异步创建订单的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">seckill_order_executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">/**orderTasks 是一个阻塞队列，用来存储待处理的订单。seckill_order_executor 是一个单线程的执行器，用来处理队列中的订单任务。**/</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    seckill_order_executor.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;<span class="comment">//在 @PostConstruct 注解的方法中，启动了一个新线程来不断地从队列中取出订单信息并处理：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.获取队列中的订单信息</span></span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                <span class="comment">//2.创建订单</span></span><br><span class="line">                handleVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理订单异常&quot;</span>,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//take() 方法是阻塞的，只有队列中有元素时才会返回，如果没有元素，则当前线程会阻塞，直到有新元素加入队列。</span></span><br></pre></td></tr></table></figure><p>然后新增一个handleVoucherOrder方法，，首先通过 <strong>Redisson 分布式锁</strong> 来确保 <strong>一人一单</strong> 逻辑的原子性，防止同一个用户多次下单。：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IVoucherOrderService proxy ;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleVoucherOrder</span>(<span class="params">VoucherOrder voucherOrder</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取用户</span></span><br><span class="line">    Long userId = voucherOrder.getUserId();</span><br><span class="line">    <span class="comment">//2.创建锁对象</span></span><br><span class="line">    RLock <span class="keyword">lock</span> = redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span>+userId);</span><br><span class="line">    <span class="comment">//3.获取锁</span></span><br><span class="line">    boolean isLock = <span class="keyword">lock</span>.tryLock();</span><br><span class="line">    <span class="comment">//4.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(!isLock) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取锁后，调用 <code>createVoucherOrder</code> 方法来扣减库存并保存订单。</li><li>如果锁获取失败，说明该用户已经下单，直接返回。</li></ul><p>createVoucherOrder方法主要是用来对数据库操作，比如扣减库存，然后保存订单的信息到数据库，会有额外的对一人一单和库存数量的判断，虽然这些在Redis中已经判断过，但这里是双重保险。</p><p>异步处理不需要再返回给前端任何东西。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void createVoucherOrder(VoucherOrder voucherOrder) &#123;</span><br><span class="line">    <span class="comment">//6.一人一单</span></span><br><span class="line">    Long userId = voucherOrder.getUserId();</span><br><span class="line">    <span class="comment">//6.1查询订单</span></span><br><span class="line">    int <span class="keyword">count</span> = <span class="keyword">query</span>().<span class="keyword">eq</span>(<span class="string">&quot;user_id&quot;</span>, userId).<span class="keyword">eq</span>(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).<span class="keyword">count</span>();</span><br><span class="line">    <span class="comment">//6.2判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">count</span>&gt;0)&#123;</span><br><span class="line">        <span class="comment">//用户已经购买过了</span></span><br><span class="line">        <span class="keyword">log</span>.<span class="keyword">error</span>(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2库存充足扣减库存</span></span><br><span class="line">    boolean success = seckillVoucherService.<span class="keyword">update</span>()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">//相当于set条件 set stock = stock - 1</span></span><br><span class="line">            .<span class="keyword">eq</span>(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()) <span class="comment">//相当于where条件 where id = ? and stock = ?</span></span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>,0).<span class="keyword">update</span>();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="keyword">log</span>.<span class="keyword">error</span>(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    long orderId = redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);<span class="comment">//订单id</span></span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(voucherOrder.getVoucherId());<span class="comment">//代金券id</span></span><br><span class="line">    <span class="keyword">save</span>(voucherOrder);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">下面是对seckillVoucher的简单修改：seckillVoucher 方法在执行 Lua 脚本后，判断用户是否有秒杀资格。如果有，则将订单信息封装并添加到阻塞队列中</span><br></pre></td></tr></table></figure><p>public Result seckillVoucher(Long voucherId) {</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//1.执行Lua脚本</span></span><br><span class="line">Long result = stringRedisTemplate.execute(</span><br><span class="line">        SECKILL_SCRIPT,</span><br><span class="line">        Collections.emptyList(),</span><br><span class="line">        voucherId.toString(),</span><br><span class="line">        UserHolder.getUser().getId().toString()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">int</span> r = result.intValue();</span><br><span class="line"><span class="keyword">if</span>(r != <span class="number">0</span>)&#123; <span class="comment">//2.判断结果是否为0,不为0,代表没有购买资格</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(r==<span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span>:<span class="string">&quot;不能重复下单&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.2.为0,有购买资格,把下单信息保存到阻塞队列</span></span><br><span class="line"><span class="keyword">long</span> orderId = redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"><span class="comment">//封装</span></span><br><span class="line">VoucherOrder voucherOrder = <span class="keyword">new</span> VoucherOrder();</span><br><span class="line">voucherOrder.setId(orderId);<span class="comment">//订单id</span></span><br><span class="line">voucherOrder.setUserId(UserHolder.getUser().getId());<span class="comment">//用户id</span></span><br><span class="line">voucherOrder.setVoucherId(voucherId);<span class="comment">//代金券id</span></span><br><span class="line"><span class="comment">//保存阻塞队列</span></span><br><span class="line">orderTasks.add(voucherOrder);</span><br><span class="line"><span class="comment">//获取代理对象</span></span><br><span class="line">proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line"><span class="comment">//3.返回订单id</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> Result.<span class="title">ok</span><span class="params">(orderId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程总结</p><ul><li><strong>秒杀资格判断</strong>：通过 Lua 脚本判断库存是否充足、是否重复下单。</li><li><strong>封装订单信息</strong>：如果有资格，封装订单信息并保存到阻塞队列。</li><li><strong>异步下单</strong>：通过新线程异步处理订单，防止阻塞前端。</li><li><strong>双重保险</strong>：Redis 和数据库中都进行库存与一人一单的判断，保证数据一致性</li></ul><p>测试：</p><p>先把tb_voucher_order内容清空。把tb_seckill_voucher的stock库存改为200。</p><p>然后把Redis中对应优惠券的库存改为200。清空之前生成的订单。检查是否有1000个用户的token。</p><p>先用Apifox进行测试，测试一人一单的情况：第2次下单显示不能重复下单。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-247.png" alt="img"></p><p>检查数据库是否多1条订单记录，库存是否减少1，缓存中库存是否减少1。</p><p>接下来用Jemeter进行测试，会发现库存扣减为0，数据库中多200条数据，缓存中的库存也扣减到0。</p><p>看聚合报告的结果如下：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-248-1024x240.png" alt="img"></p><p>因为做了异步下单，会占用一定的CPU，所以平均值要比第2次更长。</p><p>和下面前2次的结果进行对比可以发现，响应的平均值比最初提高10倍，最快响应时间提高了80倍，最慢响应时间提高了6倍。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-249-1024x475.png" alt="img"></p><p>秒杀业务的优化思路：</p><p>1.先利用Redis完成库存量、一人一单的判断，完成抢单业务。</p><p>2.将下单业务放入阻塞队列，利用独立线程异步下单。</p><p>基于阻塞队列的异步秒杀存在哪些问题：</p><p>1.内存限制问题。使用的是jdk提供的阻塞队列，使用的是JVM的内存，在一开始写死了队列空间的大小，如果在高并发的情况下，队列很快会被占满，如果不对队列的空间加以限制，很容易造成内存的溢出。</p><p>2.数据安全问题。缺乏持久化机制，是基于内存来保存信息，如果服务突然宕机，内存中保存的信息都会丢失。如果任务被取出，但由于突然发生事故异常，导致任务没有被消费，任务丢失，会造成数据不一致问题。</p><h2 id="7、Redis消息队列"><a href="#7、Redis消息队列" class="headerlink" title="7、Redis消息队列"></a>7、Redis消息队列</h2><h3 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h3><p>什么是消息队列：</p><p><strong>消息队列</strong> 是一种以异步通信为基础的机制，在分布式系统中应用广泛。它的作用就是 <strong>存储和管理消息</strong>，并通过 <strong>消息中间件（Message Broker）</strong> 来实现消息的传递。最基本的消息队列包含了三个主要角色：</p><ol><li><strong>生产者（Producer）</strong>：发送消息到队列。</li><li><strong>消息队列（Message Queue）</strong>：存储和管理消息。</li><li><strong>消费者（Consumer）</strong>：从队列中获取消息并进行处理。</li></ol><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-250.png" alt="img"></p><p><strong>示例说明：</strong></p><p>通过生活中的例子来帮助理解消息队列的作用：</p><ul><li><strong>生产者</strong>：就像一个 <strong>快递员</strong>，他负责将快递从商家拿到快递站点（消息队列），等待送货。</li><li><strong>消息队列</strong>：快递站点，在这里所有的快递都暂时存放，等待被派送到消费者。</li><li><strong>消费者</strong>：类似 <strong>收件人</strong>，他们接收到快递，处理自己的需求。</li></ul><p>为什么使用消息队列？</p><p><strong>提高效率</strong>：消息队列帮助系统处理并发，生产者可以快速发送消息，而消费者会异步处理。</p><p><strong>解耦</strong>：生产者和消费者的工作可以解耦开，生产者无需关心消费者的处理速度，反之亦然。</p><p>这种场景在我们秒杀中就变成了：</p><ol><li><strong>用户发起秒杀请求</strong>：用户点击秒杀按钮，系统作为 <strong>生产者</strong> 将秒杀请求（消息）发送到 Redis 消息队列。</li><li><strong>系统判断库存</strong>：队列中的消息进入处理流程，由 <strong>消费者</strong> 负责从 Redis 消息队列中取出消息并执行相应的处理，如判断库存、生成订单等。</li><li><strong>异步处理</strong>：消费者处理完消息后，最终结果会异步返回到</li></ol><p>Redis提供了3种不同的方式来实现消息队列：</p><ul><li>1.list结构：基于List结构模拟消息队列。</li><li>2.PubSub（发布订阅）：基本的点对点消息模型。</li><li>3.Stream：比较完善的功能强大的消息队列模型。</li></ul><h3 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个<strong>双向链表</strong>，因此支持从两端进行操作，能够实现队列的 <strong>先进先出</strong>（FIFO）模式。</p><p>关键命令：</p><ul><li><strong>LPUSH</strong>：将一个或多个元素插入到列表的 <strong>头部</strong>。用于生产者将消息发送到队列。</li><li><strong>RPOP</strong>：移除并返回列表的 <strong>尾部</strong> 元素。用于消费者从队列获取消息。</li><li><strong>BRPOP</strong>：当队列为空时，阻塞等待，直到有消息加入队列中</li></ul><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ul><li><code>BRPOP</code> 和 <code>RPOP</code> 命令在队列为空时会返回 <code>null</code>，这与 <strong>JVM 阻塞队列</strong> 不同，JVM 阻塞队列会直接阻塞线程，直到队列有可用元素。</li><li>Redis 中使用 <code>BRPOP</code> 来实现 <strong>阻塞式队列</strong>，使得消费者可以在队列为空时阻塞等待。</li></ul><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-252.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-253.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-251.png" alt="img"></p><p>基于List的消息队列有哪些优缺点？ 优点：</p><ul><li><strong>利用 Redis 存储</strong>，不依赖于 JVM 内存中的队列，保证了消息队列的 <strong>持久性</strong> 和 <strong>高可用性</strong>。</li><li><strong>跨进程、跨平台</strong>：Redis 可以用于多台机器间的消息传递，适用于分布式系统。</li><li><strong>安全性</strong>：数据存储在 Redis 中，确保了消息不会丢失，特别是在 <strong>Redis 持久化</strong>（AOF 或 RDB）开启的情况下。</li></ul><p>缺点：</p><ul><li><strong>无法强制消费者处理消息的顺序</strong>：因为 Redis 是基于 List 实现的，所以 <strong>多个消费者</strong> 可能会错过某些消息，或消费顺序不保证。</li><li><strong>没有内建的消息确认机制</strong>：消费者可能会消费同一个消息，若处理失败时缺乏补偿机制。</li></ul><h3 id="7-3-Redis消息队列-基于PubSub的消息队列"><a href="#7-3-Redis消息队列-基于PubSub的消息队列" class="headerlink" title="7.3 Redis消息队列-基于PubSub的消息队列"></a>7.3 Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p>SUBSCRIBE channel [channel] ：订阅一个或多个频道 PUBLISH channel msg ：向一个频道发送消息 PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-254.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-255.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-257.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-256.png" alt="img"></p><p>基于PubSub的消息队列有哪些优缺点？ 优点：</p><ul><li><strong>支持多生产者、多消费者</strong>：一个频道可以有多个生产者发布消息，多个消费者订阅并处理这些消息。</li><li><strong>灵活的订阅方式</strong>：可以精确订阅某个频道，也可以通过模式匹配（PSUBSCRIBE）订阅多个频道。</li><li><strong>实时性高</strong>：一旦消息发布，所有订阅者可以即时收到，适用于对实时性要求高的场景。</li></ul><p>缺点：</p><ul><li><strong>不支持数据持久化</strong>：Redis Pub/Sub 不会将消息持久化到磁盘，数据丢失风险较大。</li><li><strong>无法避免消息丢失</strong>：如果消费者在订阅时没有准备好，或 Redis 服务重启等原因，会丢失消息。</li><li><strong>消息堆积有限制</strong>：如果消息队列堆积过多，超出了 Redis 的内存限制，可能会导致消息丢失。</li></ul><h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-258-1024x150.png" alt="img"></p><ul><li><strong>key</strong>：指定 Stream 的名称。</li><li><strong>field</strong> 和 <strong>value</strong>：消息的字段和值，每条消息会有多个字段和值。</li></ul><p>例如：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-259.png" alt="img"></p><p>这条命令会将 <code>&quot;name&quot;</code> 和 <code>&quot;age&quot;</code> 这两个字段及其对应的值 <code>&quot;jack&quot;</code> 和 <code>&quot;21&quot;</code> 添加到名为 <code>users</code> 的 Stream 中，同时 Redis 会自动为该消息生成一个 <strong>唯一的 ID</strong>（如 <code>1644085070523-0</code>）。</p><p>读取消息的方式之一：XREAD，需要注意的是key和<em>|ID中间那俩参数是<em>*可选参数</em></em>，一个是用来判断是否自动创建队列，一个是用来设置队列最大消息数量。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-260.png" alt="img"></p><p>例如，使用XREAD读取第一个消息：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-261.png" alt="img"></p><p>这条命令会从名为 <code>users</code> 的 Stream 中读取消息，从 ID 为 <code>0</code> 的位置开始，最多读取 1 条消息。</p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-262.png" alt="img"></p><ul><li><strong>BLOCK 1000</strong> 表示阻塞等待最多 1000 毫秒，直到队列中有新的消息，或超时。</li><li><strong>$</strong> 代表读取最新的消息。</li></ul><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-263.png" alt="img"></p><ul><li>该循环会不断执行 <code>XREAD</code> 命令，直到有新消息进入队列。</li><li>每次从 Stream 中读取消息并执行 <code>handleMessage()</code> 处理消息。</li></ul><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。消费者之间是竞争关系。</p><p>具备下列特点：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-264.png" alt="img"></p><p>创建消费者组：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-265.png" alt="img"></p><ul><li>key：队列名称</li><li>groupName：消费者组名称</li><li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息</li><li>MKSTREAM：队列不存在时自动创建队列</li></ul><p>其它常见命令：</p><p><strong>删除指定的消费者组</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">XGROUP DESTORY key groupName</span></span><br></pre></td></tr></table></figure><p><strong>给指定的消费者组添加消费</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">XGROUP CREATECONSUMER key groupname consumername</span></span><br></pre></td></tr></table></figure><p><strong>删除消费者组中的指定消费者</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">XGROUP DELCONSUMER key groupname consumername</span></span><br></pre></td></tr></table></figure><p>创建消费者组：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-269.png" alt="img"></p><p><strong>从消费者组读取消息：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[BLOCK milliseconds]</span> <span class="selector-attr">[NOACK]</span> STREAMS key <span class="selector-attr">[key ...]</span> ID <span class="selector-attr">[ID ...]</span></span><br></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>可以发现在同一个消费者组里的消费者对消息不会重复读取，而是依次读取，已被读取的消息不会再次被读取。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-270.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-271.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-272.png" alt="img"></p><p> <strong>消费者确认消息：</strong></p><p>XACK key group ID </p><ul><li>key：是队列名称。</li><li>group：是消费者组名称。</li><li>ID：是接收到的消息的ID。</li></ul><p><strong>查看Pending-list队列的信息：</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-273.png" alt="img"></p><ul><li>key：是队列名称。</li><li>group：是组名称。</li></ul><p>下面是消息确认：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-274.png" alt="img"></p><p>对消息进行确认，确认完消息会被移除：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-275.png" alt="img"></p><p>Pending-list队列里面存储的是已经读取，但是还没确认的消息。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-276.png" alt="img"></p><p>假如一台节点读取完消息还没却来得及确认就宕机了，可以通过以下的方法解决：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-277.png" alt="img"></p><p>正常情况下先用&gt;，如果出现异常，信息会进入到Pending-list，把ID从&gt;改为0，此时取的就是在Pending-list里的消息。</p><p>消费者监听消息的基本思路：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-266.png" alt="img"></p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li><li>支持消息持久化</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-267.png" alt="img"></p><h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：在这个场景中，我们需要通过 <strong>Redis Stream</strong> 来实现一个 <strong>异步秒杀下单</strong> 的消息队列。步骤如下：</p><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li></ul><p>直接通过控制台创建一个stream.orders队列：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-278.png" alt="img"></p><p>直接在Lua脚本中编写代码（主要增加一个局部变量）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.参数列表</span></span><br><span class="line"><span class="comment">--1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">--1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">--2.数据key</span></span><br><span class="line"><span class="comment">--2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">--2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"> </span><br><span class="line"><span class="comment">--3.脚本业务</span></span><br><span class="line"><span class="comment">--3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(tonumber(redis.<span class="keyword">call</span>(<span class="string">&#x27;get&#x27;</span>,stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--3.1.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.<span class="keyword">call</span>(<span class="string">&#x27;sismember&#x27;</span>,orderKey,userId)==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--3.2.1.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--3.3.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;incrby&#x27;</span>,stockKey,<span class="number">-1</span>)</span><br><span class="line"><span class="comment">--3.4.下单 sadd orderKey userId</span></span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;sadd&#x27;</span>,orderKey,userId)</span><br><span class="line"><span class="comment">--3.5.发送消息到队列中 XADD stream.orders * k1 v1 k2 v2</span></span><br><span class="line">redis.<span class="keyword">call</span>(<span class="string">&#x27;xadd&#x27;</span>,<span class="string">&#x27;stream.orders&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;userId&#x27;</span>,userId,<span class="string">&#x27;voucherId&#x27;</span>,voucherId,<span class="string">&#x27;orderId&#x27;</span>,orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>xadd</code></strong> 命令将 <code>userId</code>、<code>voucherId</code> 和 <code>orderId</code> 发送到名为 <code>stream.orders</code> 的队列中。</li><li>消息被发送到队列后，消费者可以异步处理这个消息。</li></ul><p>在VoucherOrderServiceImpl类中修改seckillVoucher方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Result <span class="title">seckillVoucher</span><span class="params">(Long voucherId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取订单id</span></span><br><span class="line">    <span class="keyword">long</span> orderId = redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">//1.执行Lua脚本(判断用户是否有购买资格，消息发出)</span></span><br><span class="line">    Long result = stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString(),</span><br><span class="line">            String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">int</span> r = result.intValue();</span><br><span class="line">    <span class="keyword">if</span>(r != <span class="number">0</span>)&#123; <span class="comment">//2.判断结果是否为0,不为0,代表没有购买资格</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> Result.<span class="title">fail</span><span class="params">(r==<span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span>:<span class="string">&quot;不能重复下单&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="comment">//3.返回订单id</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> Result.<span class="title">ok</span><span class="params">(orderId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行 Lua 脚本来进行秒杀资格的判断，并将订单信息发送到 <code>stream.orders</code> 队列。</p><p>在VoucherOrderServiceImpl中修改VoucherOrderHandler方法的代码：</p><p>代码思路如下：</p><p>1.从消息队列中尝试读消息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>.<span class="number">1</span>.获取失败，继续循环。</span><br></pre></td></tr></table></figure><p>2.获取成功，进行解析和转换。</p><p>3.调用createVoucherOrder(voucherOrder)方法完成下单。</p><p>4.ACK确认</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">4.1</span>.确认失败，调用<span class="title function_">handlePendingList</span>()方法进行处理。</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">ExecutorService</span> seckill_order_executor = <span class="title class_">Executors</span>.<span class="title function_">newSingleThreadExecutor</span>();</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">init</span>(<span class="params"></span>)&#123;</span><br><span class="line">    seckill_order_executor.<span class="title function_">submit</span>(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="title class_">String</span> queueName = <span class="string">&quot;stream.order&quot;</span>;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS streams.order &gt;</span></span><br><span class="line">                <span class="title class_">List</span>&lt;<span class="title class_">MapRecord</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>, <span class="title class_">Object</span>&gt;&gt; list = stringRedisTemplate.<span class="title function_">opsForStream</span>().<span class="title function_">read</span>(</span><br><span class="line">                        <span class="title class_">Consumer</span>.<span class="title function_">from</span>(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        <span class="title class_">StreamReadOptions</span>.<span class="title function_">empty</span>().<span class="title function_">count</span>(<span class="number">1</span>).<span class="title function_">block</span>(<span class="title class_">Duration</span>.<span class="title function_">ofSeconds</span>(<span class="number">2</span>)),</span><br><span class="line">                        <span class="title class_">StreamOffset</span>.<span class="title function_">create</span>(queueName, <span class="title class_">ReadOffset</span>.<span class="title function_">lastConsumed</span>())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">//2.判断消息获取是否成功</span></span><br><span class="line">                <span class="keyword">if</span>(list==<span class="literal">null</span> || list.<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">                    <span class="comment">//2.1.获取失败，没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3.解析消息中的订单信息</span></span><br><span class="line">                <span class="title class_">MapRecord</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>, <span class="title class_">Object</span>&gt; record = list.<span class="title function_">get</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//4.获取成功，可以下单</span></span><br><span class="line">                <span class="title class_">Map</span>&lt;<span class="title class_">Object</span>, <span class="title class_">Object</span>&gt; values = record.<span class="title function_">getValue</span>();</span><br><span class="line">                <span class="comment">//3.创建订单</span></span><br><span class="line">                <span class="title class_">VoucherOrder</span> voucherOrder = <span class="title class_">BeanUtil</span>.<span class="title function_">fillBeanWithMap</span>(values, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="title function_">createVoucherOrder</span>(voucherOrder);</span><br><span class="line">                <span class="comment">//4.ACK确认</span></span><br><span class="line">                stringRedisTemplate.<span class="title function_">opsForStream</span>().<span class="title function_">acknowledge</span>(queueName,<span class="string">&quot;g1&quot;</span>,record.<span class="title function_">getId</span>());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">                log.<span class="title function_">debug</span>(<span class="string">&quot;处理订单异常&quot;</span>,e);</span><br><span class="line">                <span class="title function_">handlePendingList</span>();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>XREAD</code></strong> 命令从 <code>stream.orders</code> 队列中读取消息。</li><li>读取到消息后，调用 <code>createVoucherOrder()</code> 方法来处理订单。</li><li>使用 <strong>ACK 确认</strong> 来确保消息被正确消费。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure><p>在VoucherOrderServiceImpl中添加handlePendingList()方法的代码：</p><p>下面有几个修改点：1.XREADGROUP语句末尾改为0，表示读Pending-list队列。2.Pending-list消息获取失败结束循环。3.如果抛异常只是暂停一下，然后会继续循环读。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">handlePendingList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取Pending-List中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS streams.order 0</span></span><br><span class="line">            <span class="title class_">List</span>&lt;<span class="title class_">MapRecord</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>, <span class="title class_">Object</span>&gt;&gt; list = stringRedisTemplate.<span class="title function_">opsForStream</span>().<span class="title function_">read</span>(</span><br><span class="line">                    <span class="title class_">Consumer</span>.<span class="title function_">from</span>(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    <span class="title class_">StreamReadOptions</span>.<span class="title function_">empty</span>().<span class="title function_">count</span>(<span class="number">1</span>),</span><br><span class="line">                    <span class="title class_">StreamOffset</span>.<span class="title function_">create</span>(queueName, <span class="title class_">ReadOffset</span>.<span class="title function_">from</span>(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//2.判断消息获取是否成功</span></span><br><span class="line">            <span class="keyword">if</span>(list==<span class="literal">null</span> || list.<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">                <span class="comment">//2.1.获取失败，说明Pending-list里没有异常消息，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.解析消息中的订单信息</span></span><br><span class="line">            <span class="title class_">MapRecord</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>, <span class="title class_">Object</span>&gt; record = list.<span class="title function_">get</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//4.获取成功，可以下单</span></span><br><span class="line">            <span class="title class_">Map</span>&lt;<span class="title class_">Object</span>, <span class="title class_">Object</span>&gt; values = record.<span class="title function_">getValue</span>();</span><br><span class="line">            <span class="comment">//3.创建订单</span></span><br><span class="line">            <span class="title class_">VoucherOrder</span> voucherOrder = <span class="title class_">BeanUtil</span>.<span class="title function_">fillBeanWithMap</span>(values, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4.ACK确认</span></span><br><span class="line">            stringRedisTemplate.<span class="title function_">opsForStream</span>().<span class="title function_">acknowledge</span>(queueName,<span class="string">&quot;g1&quot;</span>,record.<span class="title function_">getId</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">            log.<span class="title function_">debug</span>(<span class="string">&quot;处理Pending-list异常&quot;</span>,e);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="title class_">Thread</span>.<span class="title function_">sleep</span>(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><strong>异步下单</strong>：通过 Redis Stream 实现秒杀下单的异步处理，避免了前端用户的阻塞。</li><li><strong>消息队列</strong>：使用 Redis Stream 存储消息，确保每个秒杀请求可以被异步处理。</li><li><strong>消息确认机制</strong>：使用 ACK 确认确保消息被成功消费，并通过 Pending List 处理异常消息，防止丢失。</li></ul><p>测试：</p><p>用Apifox进行测试，测试接口请求发送成功：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-280-1024x590.png" alt="img"></p><p>测试成功后可以看到：tb_voucher_order表多了1条记录，tb_seckill_voucher表对应优惠券的库存-1；在Redis中seckill:order下出现订单记录，在stockill:stock下的库存-1，在stream.orders下出现1条新的记录。</p><p>然后用Jmeter进行测试：可以发现相较于未做异步处理的情况性能仍有较大提升。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-279-1024x264.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-281-1024x479.png" alt="img"></p><h2 id="8、达人探店"><a href="#8、达人探店" class="headerlink" title="8、达人探店"></a>8、达人探店</h2><h3 id="8-1、达人探店-发布探店笔记"><a href="#8-1、达人探店-发布探店笔记" class="headerlink" title="8.1、达人探店-发布探店笔记"></a>8.1、达人探店-发布探店笔记</h3><p>发布探店笔记</p><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-283.png" alt="img"></p><p><strong>具体发布流程</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-284.png" alt="img"></p><p>上传接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">&quot;upload&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Result</span> <span class="title function_">uploadImage</span>(<span class="params"><span class="meta">@RequestParam</span>(<span class="string">&quot;file&quot;</span>) <span class="title class_">MultipartFile</span> image</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="title class_">String</span> originalFilename = image.<span class="title function_">getOriginalFilename</span>();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="title class_">String</span> fileName = <span class="title function_">createNewFileName</span>(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.<span class="title function_">transferTo</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="title class_">SystemConstants</span>.<span class="property">IMAGE_UPLOAD_DIR</span>, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.<span class="title function_">debug</span>(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Result</span>.<span class="title function_">ok</span>(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-285-1024x179.png" alt="img"></p><p>BlogController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="string">&quot;/blog&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result saveBlog(<span class="meta">@RequestBody</span> Blog blog) &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        UserDTO user = UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-达人探店-查看探店笔记"><a href="#8-2-达人探店-查看探店笔记" class="headerlink" title="8.2 达人探店-查看探店笔记"></a>8.2 达人探店-查看探店笔记</h3><p>探店笔记要包含笔记的内容和博主的相关信息。所以选择在Blog表中添加如下2个字段，这两个字段需要后续我们手动维护（赋值）。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-286-1024x814.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-287.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-289.png" alt="img"></p><p>在BlogController类里添加一个queryBlogById方法（虽然Controller里不应该出现业务代码，但鉴于只是简单的查询操作，就不必在意细节了）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="string">&quot;/&#123;id&#125;&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> Result queryBlogById(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> <span class="built_in">Long</span> id)&#123;</span><br><span class="line">    Blog blog = blogService.getById(id);</span><br><span class="line">    <span class="keyword">if</span>(blog==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    User user = userService.getById(id);</span><br><span class="line">    blog.setIcon(user.getIcon());</span><br><span class="line">    blog.setName(user.getNickName());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-达人探店-点赞功能"><a href="#8-3-达人探店-点赞功能" class="headerlink" title="8.3 达人探店-点赞功能"></a>8.3 达人探店-点赞功能</h3><p>现在的点赞逻辑是，一个人可以对同一篇笔记点赞无数次。</p><p>需求：</p><ul><li>1.同一个用户只能点赞一次，如果再次点击则取消点赞。</li><li>2.如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>分析：</p><ul><li>1.给Blog类中添加一个isLike字段，标示是否被当前用户点赞。</li><li>2.修改点赞功能，利用Redis的Set集合判断是否点赞过，未点赞则点赞数+1，已点赞则点赞数-1。</li><li>3.修改分页查询Blog业务和根据id查询Blog的业务，判断当前用户是否点赞过，赋值给isLike字段。</li><li>4.修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>为什么采用set集合：</p><p>Redis 的 Set 是一个不允许重复元素的集合，特别适合用于存储用户是否点赞的状态。</p><p>代码如下：</p><p>在BlogController类中新增likeBlog方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@PutMapping</span>(<span class="string">&quot;/like/&#123;id&#125;&quot;</span>)</span><br><span class="line">public Result <span class="built_in">likeBlog</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) Long id) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">blogService</span><span class="selector-class">.likeBlog</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>@PutMapping</code> 表示用户点赞或取消点赞。</li><li>调用 <code>likeBlog</code> 方法来执行点赞逻辑。</li></ul><p>在IBlogService接口中添加方法声明：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="class">Result</span></span> <span class="function"><span class="title">likeBlog</span>(<span class="variable">Long</span> <span class="variable">id</span>);</span></span><br></pre></td></tr></table></figure><p>在BlogServiceImpl类中添加下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BlogServiceImpl</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">    <span class="comment">//2.判断当前用户是否已经点赞过</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span> +id;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">    <span class="keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;</span><br><span class="line">        <span class="comment">//3.未点赞，可以点赞</span></span><br><span class="line">        <span class="comment">//3.1.数据库点赞数+1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked=liked+1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">//3.2.保存用户到Redis</span></span><br><span class="line">        <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().add(key,userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//4.已点赞，取消点赞</span></span><br><span class="line">        <span class="comment">//4.1.数据库点赞数-1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked=liked-1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">//4.2.把用户从Redis的set集合移除</span></span><br><span class="line">        stringRedisTemplate.opsForSet().remove(key,userId.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>点赞</strong>：如果 Redis Set 中没有当前用户的 ID，说明用户还未点赞，执行数据库更新（点赞数+1），并将用户 ID 存入 Redis Set。</li><li><p><strong>取消点赞</strong>：如果 Redis Set 中有当前用户的 ID，说明用户已点赞，执行数据库更新（点赞数-1），并将用户 ID 从 Redis Set 中移除。</p><p>因为我的queryBlogById和queryHotBlog的业务代码都沿用原本的代码写在BlogController中，因此我是直接在BlogController中写入isBlogLiked代码：</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">Boolean</span> isBlogLiked(Blog blog) &#123;</span><br><span class="line"><span class="built_in">Long</span> userId = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取登录用户</span></span><br><span class="line">userId = UserHolder.getUser().getId();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.debug(<span class="string">&quot;用户未登录！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.判断当前用户是否已经点赞过</span></span><br><span class="line">String key = <span class="string">&quot;blog:liked:&quot;</span> +blog.getId();</span><br><span class="line"><span class="built_in">Boolean</span> isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">blog.setIsLike(BooleanUtil.isTrue(isMember));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.debug(<span class="string">&quot;点赞信息为空！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isMember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断用户是否点赞</strong>：通过 Redis 判断当前登录用户是否已点赞，如果点赞，则将 <code>isLike</code> 字段设置为 <code>true</code>，前端根据该字段值来控制点赞按钮的显示状态</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-291.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-290.png" alt="img"></p><p>总结：</p><ul><li><strong>点赞操作</strong>：使用 Redis Set 来存储每个用户对博客的点赞记录，确保每个用户只能对同一篇文章点赞一次。</li><li><strong>异步更新</strong>：通过 Redis 存储点赞状态，减少数据库操作频率，提高性能。</li><li><strong>前端交互</strong>：根据 <code>isLike</code> 字段，前端动态更新点赞按钮的状态，实现高亮显示和取消高亮。</li><li><strong>缓存优化</strong>：使用 Redis 快速检查用户的点赞状态，避免频繁访问数据库，提高系统响应速度。</li></ul><p>测试效果：点赞一次高亮，点赞两次取消。在缓存中有相应的记录</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-294.png" alt="img"></p><h3 id="8-4-达人探店-点赞排行榜"><a href="#8-4-达人探店-点赞排行榜" class="headerlink" title="8.4 达人探店-点赞排行榜"></a>8.4 达人探店-点赞排行榜</h3><p>需求：在探店笔记详情页面，按照时间排序，把最早点赞的TOP5列举出来，形成点赞排行榜。</p><p>之前的点赞是放到set集合，但是<strong>set集合是不能排序的</strong>，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p><p><strong>SortedSet（有序集合）</strong> 是 Redis 中一个重要的数据结构，支持按 <strong>score</strong> 值排序，这非常适合用于排名等场景。我们需要根据 <strong>score</strong>（通常是时间戳或者用户的点赞数等）来排序。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-295.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-292.png" alt="img"></p><p>可以用ZADD命令添加元素，ZSCOPE来获得分数对应的元素，ZRANGE来</p><p>Redis 中通过 <strong>ZADD</strong> 命令来向 <strong>SortedSet</strong> 中添加元素，元素会根据 <strong>score</strong> 值排序。每个元素有两个部分：</p><ul><li><strong>Member</strong>：表示元素。</li><li><strong>Score</strong>：表示排序值，Redis 会根据这个值对元素进行排序。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-296.png" alt="img"></p><ul><li><code>ZADD</code> 添加了 3 个元素，分别为 m1、m2、m3，且分别赋予了不同的 <strong>score</strong>。</li><li><code>ZRANGE</code> 命令按 <strong>score</strong> 升序排列，并返回指定范围的元素。</li></ul><p>修改以下几点</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-297-1024x584.png" alt="img"></p><ul><li><strong>ZADD</strong> 用来将用户 ID 和当前时间戳（作为 <code>score</code>）加入到 Redis 的 SortedSet 中。</li><li><strong>ZREM</strong> 用来移除已点赞用户的记录，进行取消点赞操作。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-298.png" alt="img"></p><p>在Redis缓存中多了一个score：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-299.png" alt="img"></p><p>在BlogController类中添加如下方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GetMapping</span>(<span class="string">&quot;/likes/&#123;id&#125;&quot;</span>)</span><br><span class="line">public Result <span class="built_in">queryBlogLikes</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) Long id) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">blogService</span><span class="selector-class">.queryBlogLikes</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>BlogController</code> 类中新增查询接口方法 <code>queryBlogLikes</code>：</p><ul><li><strong>GET</strong> 请求 <code>/blog/likes/&#123;id&#125;</code> 查询某篇博客的 <strong>TOP 5 点赞用户</strong>。</li><li><p>返回结果是一个 <code>List&lt;UserDTO&gt;</code>，包含了点赞最多的用户。</p><p>在IBlogService接口中添加如下方法：</p></li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="class">Result</span></span> <span class="function"><span class="title">queryBlogLikes</span>(<span class="variable">Long</span> <span class="variable">id</span>);</span></span><br></pre></td></tr></table></figure><p>在BlogServiceImpl类中添加如下方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Result queryBlogLikes(<span class="keyword">Long</span> id) &#123;</span><br><span class="line">    String key = RedisConstants.BLOG_LIKED_KEY +id;</span><br><span class="line">    <span class="comment">//1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(top5==<span class="keyword">null</span> || top5.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.解析出其中的用户id</span></span><br><span class="line">    List&lt;<span class="keyword">Long</span>&gt; ids = top5.stream().map(<span class="keyword">Long</span>::valueOf).<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">    <span class="comment">//3.根据用户id查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.<span class="keyword">class</span>))</span><br><span class="line">            .<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在会出现左图问题，先点赞的反而被排到后面了：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-300.png" alt="img"></p><p>下面是修改后的queryBlogLikes：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Result queryBlogLikes(<span class="keyword">Long</span> id) &#123;</span><br><span class="line">    String key = RedisConstants.BLOG_LIKED_KEY +id;</span><br><span class="line">    <span class="comment">//1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(top5==<span class="keyword">null</span> || top5.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.解析出其中的用户id</span></span><br><span class="line">    List&lt;<span class="keyword">Long</span>&gt; ids = top5.stream().map(<span class="keyword">Long</span>::valueOf).<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">    <span class="comment">//3.根据用户id查询用户</span></span><br><span class="line">    String idStr = StrUtil.<span class="keyword">join</span>(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>,ids)</span><br><span class="line">            .last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span>+idStr+<span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.<span class="keyword">class</span>))</span><br><span class="line">            .<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够正常展示：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-301.png" alt="img"></p><h2 id="9、好友关注"><a href="#9、好友关注" class="headerlink" title="9、好友关注"></a>9、好友关注</h2><h3 id="9-1-好友关注-关注和取消关注"><a href="#9-1-好友关注-关注和取消关注" class="headerlink" title="9.1 好友关注-关注和取消关注"></a>9.1 好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-302-1024x506.png" alt="img"></p><p>实现思路：</p><p>需求：基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-303-1024x213.png" alt="img"></p><p>关注是给表新增记录，取关是删除表中记录。</p><p>在FollowController类中写入如下代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="variable">@PutMapping</span>(<span class="string">&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;</span>)</span><br><span class="line">public Result <span class="built_in">follow</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) Long followUserId, <span class="variable">@PathVariable</span>(<span class="string">&quot;isFollow&quot;</span>) Boolean isFollow) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">followService</span><span class="selector-class">.follow</span>(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line">@<span class="selector-tag">GetMapping</span>(<span class="string">&quot;/or/not/&#123;id&#125;&quot;</span>)</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">Result</span> <span class="selector-tag">isFollow</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) Long followUserId) &#123;</span><br><span class="line">      <span class="selector-tag">return</span> <span class="selector-tag">followService</span><span class="selector-class">.isFollow</span>(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关注接口（PUT 请求）</strong>：</p><ul><li>路由：<code>/follow/&#123;id&#125;/&#123;isFollow&#125;</code></li><li>功能：判断是关注还是取消关注，通过 <code>isFollow</code> 参数来区分。如果 <code>isFollow</code> 为 <code>true</code>，则表示关注；如果为 <code>false</code>，则表示取消关注。</li></ul><p><strong>取消关注接口（GET 请求）</strong>：</p><ul><li>路由：<code>/or/not/&#123;id&#125;</code></li><li>功能：判断当前用户是否已关注目标用户。</li></ul><p>在IFollowService中写入如下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">IFollowService</span> <span class="symbol">extends</span> <span class="symbol">IService</span>&lt;<span class="symbol">Follow</span>&gt; &#123;</span><br><span class="line">    Result follow(Long followUserId, Boolean isFollow); <span class="comment">// 关注或取关</span></span><br><span class="line">    Result isFollow(Long followUserId); <span class="comment">// 判断是否关注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FollowServiceImpl类中写入如下代码：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Service</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FollowServiceImpl</span> <span class="title">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">FollowMapper</span>, <span class="title">Follow</span>&gt; <span class="title">implements</span> <span class="title">IFollowService</span> </span>&#123;</span><br><span class="line">    // 关注与取消关注操作</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public Result follow(Long followUserId, Boolean isFollow) &#123;</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        <span class="regexp">//</span><span class="number">1</span>.判断是关注还是取关</span><br><span class="line">        <span class="keyword">if</span>(isFollow)&#123;</span><br><span class="line">            <span class="regexp">//</span><span class="number">2</span>.关注，新增数据</span><br><span class="line">            Follow follow = new Follow();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            save(follow);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="regexp">//</span><span class="number">3</span>.取关，删除记录</span><br><span class="line">            remove(new QueryWrapper&lt;Follow&gt;()</span><br><span class="line">                    .e<span class="string">q(&quot;user_id&quot;, userId)</span>.e<span class="string">q(&quot;follow_user_id&quot;, followUserId)</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断当前用户是否已关注目标用户</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public Result isFollow(Long followUserId) &#123;</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        <span class="regexp">//</span><span class="number">1</span>.查询是否关注</span><br><span class="line">        Integer count = query().e<span class="string">q(&quot;user_id&quot;, userId)</span>.e<span class="string">q(&quot;follow_user_id&quot;, followUserId)</span>.count();</span><br><span class="line">        <span class="regexp">//</span><span class="number">2</span>.判断是否关注</span><br><span class="line">        <span class="keyword">return</span> Result.ok(count&gt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>关注操作</strong>：首先获取当前登录的 <code>userId</code>，然后根据 <code>followUserId</code> 创建一个 <code>Follow</code> 实体对象，并将其保存到数据库中。</li><li><strong>取消关注操作</strong>：根据当前用户的 <code>userId</code> 和目标用户的 <code>followUserId</code> 删除 <code>tb_follow</code> 表中的记录，表示取消关注。</li><li><strong>判断是否已关注</strong></li><li><strong>isFollow 方法</strong>：该方法通过查询 <code>tb_follow</code> 表来判断当前用户是否已经关注某个目标用户。如果存在对应记录，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul><p>测试：点击关注显示关注成功，数据库里会有记录。取消关注后删除消息。</p><h3 id="9-2-好友关注-共同关注"><a href="#9-2-好友关注-共同关注" class="headerlink" title="9.2 好友关注-共同关注"></a>9.2 好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><p>1、去查询用户的详情</p><p>2、去查询用户的笔记</p><p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserController 根据id查询用户</span></span><br><span class="line"><span class="meta">@GetMapping(<span class="string">&quot;/&#123;id&#125;&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> Result queryUserById(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> <span class="built_in">Long</span> userId)&#123;</span><br><span class="line"><span class="comment">// 查询详情</span></span><br><span class="line">User user = userService.getById(userId);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line">UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.<span class="keyword">class</span>);</span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlogController  根据id查询博主的探店笔记</span></span><br><span class="line"><span class="meta">@GetMapping(<span class="string">&quot;/of/user&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> Result queryBlogByUserId(</span><br><span class="line"><span class="meta">@RequestParam(value = <span class="string">&quot;current&quot;</span>, defaultValue = <span class="string">&quot;1&quot;</span>)</span> Integer current,</span><br><span class="line"><span class="meta">@RequestParam(<span class="string">&quot;id&quot;</span>)</span> <span class="built_in">Long</span> id) &#123;</span><br><span class="line"><span class="comment">// 根据用户查询</span></span><br><span class="line">Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">.eq(<span class="string">&quot;user_id&quot;</span>, id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line"><span class="comment">// 获取当前页数据</span></span><br><span class="line">List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line"><span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-304-1024x403.png" alt="img"></p><p>功能实现的思路是：</p><ul><li><strong>关注操作</strong>：当用户关注另一个用户时，不仅要在数据库表中插入记录，还需要将关注的用户ID存储在Redis的 <code>Set</code> 集合中。</li><li><strong>取消关注操作</strong>：当用户取消对另一个用户的关注时，除了删除数据库中的记录，还需要从Redis中移除对应的用户ID。</li><li><strong>共同关注操作</strong>：通过Redis的 <code>SINTER</code> 命令，获取当前用户与目标用户关注的交集，进而查询这些共同关注的用户信息。</li></ul><p>首先要更改FollowServiceImpl代码中的follow方法，主要在关注时把被关注用户的id放入redis，取关时从redis中移除id：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> IUserService userService;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FollowServiceImpl</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">//1.判断是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span>(isFollow)&#123;</span><br><span class="line">        <span class="comment">//2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">            <span class="comment">//把关注用户的id放入redis的set集合</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(key,followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3.取关，删除记录</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">            <span class="comment">//把关注用户的id从Redis移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key,followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>关注操作</strong>：当用户关注某人时，我们在数据库中插入关注记录，并将被关注用户的 <code>userId</code> 存入 Redis 的 <code>Set</code> 集合。</li><li><strong>取消关注操作</strong>：当用户取消关注时，我们从数据库删除对应的关注记录，并将该用户的 <code>userId</code> 从 Redis 中的 <code>Set</code> 集合移除。</li></ul><p>下面进行简单测试，关注时数据存入redis没问题： </p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-305.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-306.png" alt="img"></p><p>点击共同关注报错，但发出了请求，原因是还没编写方法：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-307-1024x272.png" alt="img"></p><p>可以通过SINTER命令求出交集：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-308.png" alt="img"></p><p>在 <code>FollowController</code> 中添加路由,在FollowController中写入下面代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GetMapping</span>(<span class="string">&quot;/common/&#123;id&#125;&quot;</span>)</span><br><span class="line">public Result <span class="built_in">followCommons</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) Long id)&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">followService</span><span class="selector-class">.followCommons</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>IFollowService</code> 接口中声明,在IFollowService中写入下面代码：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="class">Result</span></span> <span class="function"><span class="title">followCommons</span>(<span class="variable">Long</span> <span class="variable">id</span>);</span></span><br></pre></td></tr></table></figure><p>在 <code>FollowServiceImpl</code> 类中实现,在FollowServiceImpl类中写入下面代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Result followCommons(<span class="keyword">Long</span> id) &#123;</span><br><span class="line">    <span class="comment">//求的是目标用户和当前用户关注的交集</span></span><br><span class="line">    <span class="comment">//1.获取key</span></span><br><span class="line">    <span class="keyword">Long</span> userId = UserHolder.getUser().getId();</span><br><span class="line">    String key1 = <span class="string">&quot;follows:&quot;</span>+userId; <span class="comment">// 当前用户关注的集合</span></span><br><span class="line">    String key2 = <span class="string">&quot;follows:&quot;</span>+id; <span class="comment">// 目标用户关注的集合</span></span><br><span class="line">    <span class="comment">//2.使用Redis的SINTER命令求交集</span></span><br><span class="line">    Set&lt;String&gt; <span class="keyword">intersect</span> = stringRedisTemplate.opsForSet().<span class="keyword">intersect</span>(key1, key2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">intersect</span>==<span class="keyword">null</span>||<span class="keyword">intersect</span>.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.解析id集合,将交集中的用户ID转换成Long类型</span></span><br><span class="line">    List&lt;<span class="keyword">Long</span>&gt; ids = <span class="keyword">intersect</span>.stream().map(<span class="keyword">Long</span>::valueOf).<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">    <span class="comment">//4. 查询共同关注的用户信息</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.<span class="keyword">class</span>))</span><br><span class="line">            .<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取共同关注用户</strong>：首先，我们获取当前用户和目标用户的关注列表（存储在 Redis 的 <code>Set</code> 集合中），然后使用 <code>SINTER</code> 命令获取它们的交集（即共同关注的用户）。接着，我们将这些用户ID查询出来，并返回用户信息。</p><p>像我现在关注的是小鱼同学和可可今天不吃肉。接下来换号，换成小鱼同学，电话：13686869696，让小鱼同学关注我和可可今天不吃肉。以小鱼同学的视角来查看我，可以看到我们共同关注了可可今天不吃肉。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-309.png" alt="img"></p><h3 id="9-3-好友关注-Feed流实现方案"><a href="#9-3-好友关注-Feed流实现方案" class="headerlink" title="9.3 好友关注-Feed流实现方案"></a>9.3 好友关注-Feed流实现方案</h3><p><strong>Feed流</strong>，即动态消息流，是社交平台用来为用户持续提供内容的一种方式。通过Feed流，用户能够无需主动查找，系统自动推送符合其兴趣的内容，提供更加沉浸式的体验。常见的例子有社交网络的动态时间线（Timeline），例如Facebook、Instagram、Twitter等。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-310.png" alt="img"></p><h4 id="Feed流的两种模式："><a href="#Feed流的两种模式：" class="headerlink" title="Feed流的两种模式："></a><strong>Feed流的两种模式：</strong></h4><ol><li><p>Timeline模式</p><p>：</p><ul><li><strong>定义</strong>：不对内容进行筛选，按内容的发布时间排序，通常用于好友或关注的人发布的内容，例如社交平台的动态。</li><li><strong>优点</strong>：信息全面，不会缺失任何内容；实现较为简单。</li><li><strong>缺点</strong>：可能存在信息噪音，用户未必感兴趣，导致内容获取效率低。</li></ul></li><li><p>智能排序</p><p>：</p><ul><li><strong>定义</strong>：通过智能算法筛选出用户感兴趣的内容，同时屏蔽掉违规或不感兴趣的内容。这样，系统推送的内容更符合用户的偏好。</li><li><strong>优点</strong>：用户能够获得更符合其兴趣的内容，增加用户粘性，可能让用户更沉浸在平台内。</li><li><strong>缺点</strong>：如果推荐算法不准确，可能会误推送不相关或让用户不满意的内容。</li></ul></li></ol><p>本例中，我们使用的是 <strong>Timeline模式</strong>，即基于用户关注的好友信息，按照时间顺序展示内容。</p><p>因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当用户想查看好友的动态时，系统会从用户关注的好友中拉取最新的内容。系统会根据用户关注的人群，拉取这些人发布的信息，并进行排序。</p><p>优点：</p><ul><li><strong>节约空间</strong>：数据仅在用户需要时才进行读取，减少了重复存储。</li><li>用户读取完信息后，可以清空收件箱，避免存储大量未读数据。</li></ul><p>缺点：</p><ul><li><strong>延迟性</strong>：用户在读取信息时才会去拉取，若用户关注了大量的人，系统可能需要一次性拉取大量的内容，增加服务器负担。</li><li>在数据量大时，可能会导致延时较高。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-311-1024x443.png" alt="img"></p><p><strong>推模式</strong>：也叫做写扩散。</p><p>当用户（如博主）发布新的内容时，系统会主动将内容推送到关注他的粉丝的收件箱中。这避免了用户每次都要去拉取数据。</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-312.png" alt="img"></p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案</p><ul><li><strong>普通用户</strong>：普通用户发布的内容会直接推送到其粉丝的收件箱中。</li><li><strong>大V用户</strong>：对于大V，系统会先将其内容写入到发件箱，再将内容推送到活跃粉丝的收件箱中；对于不活跃的粉丝，内容会存入发件箱，等他们上线时再拉取。</li></ul><p><strong>优点</strong>：</p><ul><li><strong>折中方案</strong>：既有推送的实时性，又能避免大V账号产生过大内存压力。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-313-1024x454.png" alt="img"></p><h3 id="9-4-好友关注-推送到粉丝收件箱"><a href="#9-4-好友关注-推送到粉丝收件箱" class="headerlink" title="9.4 好友关注-推送到粉丝收件箱"></a>9.4 好友关注-推送到粉丝收件箱</h3><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>情景解释</p><ul><li>假设你首先请求了动态的第一页（<code>page=1</code>，每页5条数据），然后你会得到类似10、11、12、13、14这样的数据。</li><li>接着你请求第二页（<code>page=2</code>），你会期望得到接下来的数据（例如15、16、17等）。</li><li>然而，如果在你请求数据的过程中，动态流（feed）有新内容发布，那么你的请求就可能会获取到不一致的数据。</li></ul><p><strong>潜在问题</strong>：</p><ul><li>如果第一页的数据是在<code>t1</code>时刻请求的，而新数据（比如“Feed: 11”）是在<code>t3</code>时刻发布的，那么第二页获取的数据可能会和第一页重叠。</li><li>这会导致分页数据的重复或者错乱，因为Feed在更新时，数据会发生变化。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-314-1024x454.png" alt="img"></p><p>Feed流的滚动分页</p><ul><li>这里提出的解决方法是记录每次请求的最后一个数据ID（<code>lastId</code>），这样可以确保每次分页请求都知道从哪里开始获取数据。</li><li>比如，如果你已经获取到的最后一个ID是<code>6</code>，那么第二页的数据应该从ID为<code>6</code>的下一条数据开始，这样可以避免重复获取已读过的数据。</li></ul><p>举个例子：我每次请求时，保存当前最后读取的数据ID。</p><p>当请求下一页时，通过<code>lastId</code>来确认从哪里继续读取数据，确保不会重复或者遗漏。</p><p>这种方式确保了分页的数据不会受动态流中间更新的影响。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-315-1024x536.png" alt="img"></p><p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p><p>在BlogController里面写入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 保存探店博文</span></span><br><span class="line">    blogService.saveBlog(blog);</span><br><span class="line">    <span class="comment">// 返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IBlogService接口里面写入如下代码：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="class">Result</span></span> <span class="function"><span class="title">saveBlog</span>(<span class="variable">Blog</span> <span class="variable">blog</span>);</span></span><br></pre></td></tr></table></figure><p>在BlogServiceImpl类中写入如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">//2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.查询笔记作业的所有粉丝</span></span><br><span class="line">    <span class="comment">//select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">//4.推送笔记id给粉丝</span></span><br><span class="line">    <span class="keyword">for</span>(Follow follow : follows)&#123;</span><br><span class="line">        <span class="comment">//4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">//4.2.推送到粉丝收件箱是sortedSet</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;feed::&quot;</span>+userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key,blog.getId().toString(),System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5好友关注-实现分页查询收邮箱的思路"><a href="#9-5好友关注-实现分页查询收邮箱的思路" class="headerlink" title="9.5好友关注-实现分页查询收邮箱的思路"></a>9.5好友关注-实现分页查询收邮箱的思路</h3><p>ZRANGE是按照角标从小到大排序：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-316.png" alt="img"></p><p>这个命令返回一个有序集合中成员的范围，可以根据给定的最小值和最大值来限制返回的元素。</p><p>ZREVRANGE是按照角标从大到小排序：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-317.png" alt="img"></p><p>这个命令与 <code>ZRANGE</code> 类似，不过它是倒序返回集合中的元素。</p><p>ZREVRANGEBYSCORE是按照分数从大到小排序：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-318.png" alt="img"></p><p>这个命令根据分数进行过滤，返回分数范围内的成员，通常用来处理时间线或者排名之类的数据。</p><p>滚动查询：每次分页查询都会获取上一次查询返回的最小值，并将其作为下一次查询的最大值。这样确保每次查询返回的数据是连续的，不会重复或者遗漏。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-319.png" alt="img"></p><p>例如，当你使用 <code>ZRANGE</code> 或 <code>ZREVRANGE</code> 进行分页查询时，你可以设置 <code>LIMIT</code> 参数来限制返回的结果数量。第一次查询时，你会从第一个成员开始，后续每次查询会根据上一次查询的结果来调整开始的地方。</p><p>规律：分数最小值和查的数量固定不变。最大值为上一次查询的最小值、偏移量第1次给0，第1次后给在上一次的结果中，与最小值一样的元素的个数。</p><p>当分数一致出现问题：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-320.png" alt="img"></p><ul><li>分数相同的成员将被视为具有相同的顺序。</li><li>当分数相同的成员出现在两次分页查询的结果中时，它们会按照第一次查询的结果顺序被返回。</li><li>比如，当第一次查询返回分数为 6 的成员时，第二次查询会继续返回分数为 6 的成员，这样保证了分页的连续性。</li></ul><p>如果 <code>z1</code> 集合中有几个分数为 <code>6</code> 的元素，第一次查询返回了这些元素后，下一次查询会从上一次查询的结果继续获取数据。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-321.png" alt="img"></p><h3 id="9-6好友关注-实现滚动分页查询"><a href="#9-6好友关注-实现滚动分页查询" class="headerlink" title="9.6好友关注-实现滚动分页查询"></a>9.6好友关注-实现滚动分页查询</h3><p>需求：在实现<strong>滚动分页查询</strong>时，目的是在用户的个人主页展示他们关注的博客内容。每次查询返回一定数量的数据，同时将最小时间戳和偏移量作为查询条件传递给下一次查询。</p><p>具体操作如下：</p><p>1.<strong>获取最小时间戳</strong>：每次查询结束后，分析出返回数据中的最小时间戳，这个时间戳将作为下一次查询的条件，用于获取比当前查询时间更新的博客。</p><p>2.<strong>计算偏移量</strong>：偏移量是上次查询中返回的数据条目数，目的是跳过已经查询过的数据，从而确保每次查询都能获取新的数据。</p><p>3.<strong>请求参数</strong>：每次请求时需要携带 <code>lastId</code>（即上一次查询的最小时间戳）和 <code>offset</code>（即偏移量）这两个参数。第一次查询时，前端会指定这两个参数，之后的查询由后台根据上一次的查询结果进行传递。</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><p>首先定义出来具体的返回值实体类</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">List</span>&lt;<span class="string">?&gt;</span> list;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Long</span> minTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Integer</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ScrollResult</code> 类用于封装查询结果，包含三个字段：</p><ul><li><code>list</code>：存储查询到的博客列表。</li><li><code>minTime</code>：本次查询返回数据中的最小时间戳，用于下一次查询的条件。</li><li><code>offset</code>：偏移量，表示这次查询返回的数据数量，下一次查询需要跳过这些数据。</li></ul><p>在BlogController中写入下面代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GetMapping</span>(<span class="string">&quot;/of/follow&quot;</span>)</span><br><span class="line">public Result <span class="built_in">queryBlogOfFollow</span>(<span class="variable">@RequestParam</span>(<span class="string">&quot;lastId&quot;</span>) Long max,<span class="variable">@RequestParam</span>(value = <span class="string">&quot;offset&quot;</span>,defaultValue = <span class="string">&quot;0&quot;</span>) Integer offset) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">blogService</span><span class="selector-class">.queryBlogOfFollow</span>(max,offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口接收两个请求参数：</p><ul><li><code>lastId</code>：上次查询的最小时间戳。</li><li><code>offset</code>：本次查询的偏移量，默认值为 0。</li></ul><p>在IBlogService写入如下代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Result</span> queryBlogOfFollow(Long max, <span class="type">Integer</span> <span class="keyword">offset</span>);</span><br></pre></td></tr></table></figure><p> 在BlogServiceImpl中写入如下代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result queryB<span class="keyword">log</span>OfFollow(Long <span class="keyword">max</span>, Integer offset) &#123;</span><br><span class="line">    //<span class="number">1</span>.获取当前用户</span><br><span class="line">    Long <span class="keyword">user</span>Id = UserHolder.getUser().getId();</span><br><span class="line">    //<span class="number">2</span>.查询收件箱 ZREVRANGEBYSCORE key Max M<span class="keyword">in</span> LIMIT offset count</span><br><span class="line">    String key = FEED_KEY+<span class="keyword">user</span>Id;</span><br><span class="line">    Set<span class="variable">&lt;ZSetOperations.TypedTuple&lt;String&gt;</span>&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, <span class="keyword">max</span>, offset, <span class="number">3</span>);</span><br><span class="line">    //<span class="number">2.1</span>.非空判断</span><br><span class="line">    if(typedTuples==null || typedTuples.isEmpty())&#123;</span><br><span class="line">        return Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    //<span class="number">3</span>.解析数据：blogId、<span class="keyword">min</span>Time(时间戳)、offset</span><br><span class="line">    List<span class="variable">&lt;Long&gt;</span> ids = new ArrayList<span class="variable">&lt;&gt;</span>(typedTuples.size());</span><br><span class="line">    long <span class="keyword">min</span>Time = <span class="number">0</span>;</span><br><span class="line">    int <span class="keyword">os</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ZSetOperations.TypedTuple<span class="variable">&lt;String&gt;</span> tuple:typedTuples)&#123;</span><br><span class="line">        //<span class="number">4.1</span>.获取id</span><br><span class="line">        String idStr = tuple.getValue();</span><br><span class="line">        ids.add(Long.valueOf(idStr));</span><br><span class="line">        //<span class="number">4.2</span>.获取分数</span><br><span class="line">        long time = tuple.getScore().longValue();</span><br><span class="line">        if(time == <span class="keyword">min</span>Time)&#123;</span><br><span class="line">            <span class="keyword">os</span>++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            <span class="keyword">min</span>Time = time;</span><br><span class="line">            <span class="keyword">os</span>=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //<span class="number">4</span>.根据id查询blog</span><br><span class="line">    String idStr = StrUtil.join(<span class="string">&quot;,&quot;</span>,ids);</span><br><span class="line">    List<span class="variable">&lt;Blog&gt;</span> blogs = query().<span class="keyword">in</span>(<span class="string">&quot;id&quot;</span>,ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span>+idStr+<span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">    <span class="keyword">for</span> (B<span class="keyword">log</span> blog : blogs) &#123;</span><br><span class="line">        isB<span class="keyword">log</span>Liked(blog);</span><br><span class="line">        User <span class="keyword">user</span> = <span class="keyword">user</span>Service.getById(blog.getUserId());</span><br><span class="line">        blog.<span class="built_in">set</span>Name(<span class="keyword">user</span>.getNickName());</span><br><span class="line">        blog.<span class="built_in">set</span>Icon(<span class="keyword">user</span>.getIcon());</span><br><span class="line">    &#125;</span><br><span class="line">    //<span class="number">5</span>.封装并返回</span><br><span class="line">    ScrollResult r = new ScrollResult();</span><br><span class="line">    r.<span class="built_in">set</span>List(blogs);</span><br><span class="line">    r.<span class="built_in">set</span>Offset(<span class="keyword">os</span>);</span><br><span class="line">    r.<span class="built_in">set</span>M<span class="keyword">in</span>Time(<span class="keyword">min</span>Time);</span><br><span class="line">    return Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取当前用户</strong>：</p><ul><li>使用 <code>UserHolder.getUser().getId()</code> 获取当前登录用户的 ID。</li></ul><p><strong>查询动态流</strong>：</p><ul><li>使用 Redis 的 <code>reverseRangeByScoreWithScores</code> 命令按时间戳倒序获取动态流中的博客 ID。查询范围是从时间戳 0 到 <code>max</code>（即上次查询的最小时间戳），偏移量为 <code>offset</code>，每次查询 3 条数据。</li></ul><p><strong>处理查询结果</strong>：</p><ul><li>遍历查询结果，提取出博客的 ID 和时间戳。根据时间戳判断是否与上一次的最小时间戳相同，若相同，则偏移量加 1，若不同，则更新最小时间戳并重置偏移量。</li></ul><p><strong>查询博客信息</strong>：</p><ul><li>使用 <code>query().in(&quot;id&quot;, ids)</code> 根据查询到的博客 ID 查询博客详细信息，使用 <code>ORDER BY FIELD</code> 确保返回的博客顺序与 ID 列表一致。</li></ul><p><strong>返回结果</strong>：</p><ul><li>将查询到的博客信息、最小时间戳和偏移量封装在 <code>ScrollResult</code> 对象中，并返回给前端。</li></ul><p>效果图如下（我关注了小鱼同学，于是我可以看到小鱼同学发布的文章）： </p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-322.png" alt="img"></p><h2 id="10、附近商户"><a href="#10、附近商户" class="headerlink" title="10、附近商户"></a>10、附近商户</h2><h3 id="10-1、附近商户-GEO数据结构的基本用法"><a href="#10-1、附近商户-GEO数据结构的基本用法" class="headerlink" title="10.1、附近商户-GEO数据结构的基本用法"></a>10.1、附近商户-GEO数据结构的基本用法</h3><p>GEO是Geolocation的简写形式，代表地理坐标，在Redis的3.2版本后加入了GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。</p><p>常见的命令有：</p><ol><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ol><h3 id="10-2、-附近商户-导入店铺数据到GEO"><a href="#10-2、-附近商户-导入店铺数据到GEO" class="headerlink" title="10.2、 附近商户-导入店铺数据到GEO"></a>10.2、 附近商户-导入店铺数据到GEO</h3><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-323-1024x421.png" alt="img"></p><p><strong>为什么使用 Redis GEO</strong>：</p><p>Redis 提供的 GEO 数据结构支持存储基于地理位置的成员，可以通过经纬度来存储地理坐标，并支持非常高效的基于距离的查询。这使得我们可以非常方便地进行以下操作：</p><ul><li><strong>插入商户的地理位置信息</strong>：将商户的经纬度和商户ID存入 Redis。</li><li><strong>根据距离查询商户</strong>：基于用户的当前位置，查询指定范围内的商户。</li></ul><p>具体场景说明：</p><p>当用户点击“美食”后，后台会根据用户的地理位置查询出周边的商户。查询的方式是：通过用户提供的地理坐标作为圆心，在 Redis 中根据经纬度存储商户信息，按距离来排序商户。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-324.png" alt="img"></p><p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p><p>在src/test/java/com/hmdp的HmDianPingApplicationTests类中写入如下的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="type">StringRedisTemplate</span> stringRedisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">void loadShopData()&#123;</span><br><span class="line">    <span class="comment">//1.查询店铺信息</span></span><br><span class="line">    <span class="type">List</span>&lt;<span class="type">Shop</span>&gt; list <span class="operator">=</span> shopService.list();</span><br><span class="line">    <span class="comment">//2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    <span class="type">Map</span>&lt;<span class="type">Long</span>,<span class="type">List</span>&lt;<span class="type">Shop</span>&gt;&gt; map <span class="operator">=</span> list.stream().collect(<span class="type">Collectors</span>.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">//3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">Long</span>, <span class="type">List</span>&lt;<span class="type">Shop</span>&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> typeid <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> key <span class="operator">=</span> <span class="string">&quot;shop:geo:&quot;</span><span class="operator">+</span>typeid;</span><br><span class="line">        <span class="comment">//3.2.获取同类型的店铺的集合</span></span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Shop</span>&gt; value <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">//3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">RedisGeoCommands</span>.<span class="type">GeoLocation</span>&lt;<span class="type">String</span>&gt;&gt; locations <span class="operator">=</span> new <span class="type">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Shop</span> shop : value)&#123;</span><br><span class="line"><span class="comment">//                stringRedisTemplate.opsForGeo().add(key,new Point(shop.getX(),shop.getY()),shop.getId().toString());</span></span><br><span class="line">            locations.add(new <span class="type">RedisGeoCommands</span>.<span class="type">GeoLocation</span>&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    new <span class="type">Point</span>(shop.getX(),shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key,locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤详解</strong>：</p><h4 id="1-查询商户信息："><a href="#1-查询商户信息：" class="headerlink" title="1. 查询商户信息："></a>1. <strong>查询商户信息</strong>：</h4><p>首先，从数据库中查询出所有的商户数据。</p><p><code>shopService.list()</code> 返回的是所有商户的信息，包括商户的经纬度（<code>x</code> 和 <code>y</code>）、商户类型（<code>typeId</code>）等。</p><ol><li><strong>将商户按类型分组</strong>：</li></ol><p>商户数据按 <code>typeId</code>（商户类型）进行分组，确保同类型的商户会存储在同一个 GEO 集合中。</p><p>通过 Java 8 的 <code>Collectors.groupingBy()</code> 方法，按照 <code>typeId</code> 对商户进行分组，返回一个以 <code>typeId</code> 为键的 <code>Map</code>，每个键对应一个商户类型的商户列表。</p><h4 id="3-将商户数据分批写入-Redis："><a href="#3-将商户数据分批写入-Redis：" class="headerlink" title="3. 将商户数据分批写入 Redis："></a>3. <strong>将商户数据分批写入 Redis</strong>：</h4><p>对于每一组商户，使用 Redis 的 <code>GEOADD</code> 命令将商户的经纬度数据添加到对应的 GEO 集合中。这样，我们就可以在 Redis 中为每种类型的商户创建一个单独的 GEO 集合。</p><ul><li><code>key</code>：以商户类型的 <code>typeId</code> 为键，创建一个对应的 Redis GEO 集合（如 <code>shop:geo:1</code> 对应类型为 1 的商户）。</li><li><code>locations</code>：这是一个 <code>List</code>，包含每个商户的 <code>GeoLocation</code>，每个商户的位置信息包括商户的 <code>ID</code> 和 <code>Point</code>（经纬度）。</li><li><code>stringRedisTemplate.opsForGeo().add(key, locations)</code>：通过 <code>stringRedisTemplate</code> 的 <code>Geo</code> 操作将商户的位置信息批量写入 Redis 中。</li></ul><h4 id="关于-Redis-GEO-的存储和查询："><a href="#关于-Redis-GEO-的存储和查询：" class="headerlink" title="关于 Redis GEO 的存储和查询："></a><strong>关于 Redis GEO 的存储和查询</strong>：</h4><ul><li><strong>存储数据</strong>：每个商户的 ID 作为 Redis GEO 集合的 member，商户的经纬度作为对应的 <code>Point</code> 存储在 Redis 中。</li><li><strong>查询数据</strong>：存储完成后，我们可以使用 Redis 提供的 GEO 命令来进行基于地理位置的查询。例如，可以查询给定坐标范围内的商户，或者根据用户的位置，查询附近的商户。</li></ul><p>测试：点击运行之后，在Redis中能够看到导入的数据：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-325-1024x608.png" alt="img"></p><h3 id="10-3-附近商户-实现附近商户功能"><a href="#10-3-附近商户-实现附近商户功能" class="headerlink" title="10.3 附近商户-实现附近商户功能"></a>10.3 附近商户-实现附近商户功能</h3><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>spring-data-redis</code></strong> 升级至 2.6.2 版本，以支持 Redis 6.2 新特性。</li><li><strong><code>lettuce-core</code></strong> 升级至 6.1.6 版本，确保支持 <code>GEOSEARCH</code> 命令。</li></ul><p>在ShopController中修改queryShopByType方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GetMapping</span>(<span class="string">&quot;/of/type&quot;</span>)</span><br><span class="line">public Result <span class="built_in">queryShopByType</span>(</span><br><span class="line">        <span class="variable">@RequestParam</span>(<span class="string">&quot;typeId&quot;</span>) Integer typeId,</span><br><span class="line">        <span class="variable">@RequestParam</span>(value = <span class="string">&quot;current&quot;</span>, defaultValue = <span class="string">&quot;1&quot;</span>) Integer current,</span><br><span class="line">        <span class="variable">@RequestParam</span>(value=<span class="string">&quot;x&quot;</span>,required=false) Double x,</span><br><span class="line">        <span class="variable">@RequestParam</span>(value=<span class="string">&quot;y&quot;</span>,required=false) Double y</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">shopService</span><span class="selector-class">.queryShopByType</span>(typeId,current,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>typeId</code></strong>：商户类型ID，用于区分不同的商户。</li><li><strong><code>current</code></strong>：当前页，默认为1，用于分页。</li><li><strong><code>x</code> 和 <code>y</code></strong>：可选的经纬度，用于查询附近的商户。如果为空，则不按距离查询。</li></ul><p>在IShopService接口中写入如下方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Result</span> queryShopByType(<span class="type">Integer</span> typeId, <span class="type">Integer</span> <span class="keyword">current</span>, <span class="keyword">Double</span> x, <span class="keyword">Double</span> y);</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl类中写入如下方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Result queryShopByType(Integer typeId, Integer current, <span class="keyword">Double</span> x, <span class="keyword">Double</span> y) &#123;</span><br><span class="line">    <span class="comment">//1.判断是否需要根据坐标查询</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="keyword">null</span> || y==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不需要查询坐标，按数据库查</span></span><br><span class="line">        Page&lt;Shop&gt; page = query()</span><br><span class="line">                .eq(<span class="string">&quot;type_id&quot;</span>,typeId)</span><br><span class="line">                .page(<span class="keyword">new</span> Page&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.计算分页参数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">from</span> = (current - <span class="number">1</span>)*SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="keyword">int</span> end = current*SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="comment">//3.查询redis，按照距离排序、分页。结果：shopId,distance</span></span><br><span class="line">    String key = SHOP_GEO_KEY+typeId;</span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo()</span><br><span class="line">            .search(</span><br><span class="line">                    key,</span><br><span class="line">                    GeoReference.fromCoordinate(x, y),</span><br><span class="line">                    <span class="keyword">new</span> Distance(<span class="number">5000</span>),</span><br><span class="line">                    RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">            );</span><br><span class="line">    <span class="comment">//4.解析出id</span></span><br><span class="line">    <span class="keyword">if</span>(results==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">    <span class="comment">//4.1.截取from-end的部分</span></span><br><span class="line">    List&lt;<span class="keyword">Long</span>&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;(list.<span class="keyword">size</span>());</span><br><span class="line">    Map&lt;String,Distance&gt; distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;(list.<span class="keyword">size</span>());</span><br><span class="line">    <span class="keyword">if</span>(list.<span class="keyword">size</span>()&lt;=<span class="keyword">from</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    list.stream().skip(<span class="keyword">from</span>).forEach(result-&gt;&#123; <span class="comment">//跳过可能把所有数据跳过了</span></span><br><span class="line">        <span class="comment">//4.2.获取店铺id</span></span><br><span class="line">        String shopIdStr = result.getContent().getName();</span><br><span class="line">        ids.add(<span class="keyword">Long</span>.valueOf(shopIdStr));</span><br><span class="line">        <span class="comment">//4.3.获取距离</span></span><br><span class="line">        Distance distance = result.getDistance();</span><br><span class="line">        distanceMap.put(shopIdStr,distance);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//5.根据id查询shop</span></span><br><span class="line">    String idStr = StrUtil.<span class="keyword">join</span>(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD ( id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">    <span class="keyword">for</span>(Shop shop : shops)&#123;</span><br><span class="line">        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6、返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤-1：判断是否需要根据坐标查询"><a href="#步骤-1：判断是否需要根据坐标查询" class="headerlink" title="步骤 1：判断是否需要根据坐标查询"></a><strong>步骤 1：判断是否需要根据坐标查询</strong></h4><p>首先检查 <code>x</code> 和 <code>y</code> 是否为空，如果为空，则不需要根据坐标查询，直接从数据库中查询商户信息。如果 <code>x</code> 和 <code>y</code> 不为空，则表示需要根据经纬度查询附近的商户。</p><h4 id="步骤-2：计算分页参数"><a href="#步骤-2：计算分页参数" class="headerlink" title="步骤 2：计算分页参数"></a><strong>步骤 2：计算分页参数</strong></h4><p>根据当前页数 <code>current</code>，计算分页的起始位置 <code>from</code> 和结束位置 <code>end</code>。这将用于从查询结果中提取对应的数据。</p><h4 id="步骤-3：查询-Redis-中的商户数据"><a href="#步骤-3：查询-Redis-中的商户数据" class="headerlink" title="步骤 3：查询 Redis 中的商户数据"></a><strong>步骤 3：查询 Redis 中的商户数据</strong></h4><p>使用 Redis 的 <code>GEOSEARCH</code> 命令查询商户，根据用户提供的经纬度（<code>x</code>, <code>y</code>）计算距离，筛选出距离用户位置在一定范围内的商户。</p><ul><li><code>SHOP_GEO_KEY + typeId</code>：Redis 中存储商户位置信息的键，以商户类型 <code>typeId</code> 为区分。</li><li><code>GeoReference.fromCoordinate(x, y)</code>：通过用户提供的经纬度创建 <code>GeoReference</code>。</li><li><code>new Distance(5000)</code>：设置查询的半径为 5000 米，即查询 5 公里范围内的商户。</li><li><code>limit(end)</code>：限制返回的商户数量。</li></ul><h4 id="步骤-4：解析查询结果"><a href="#步骤-4：解析查询结果" class="headerlink" title="步骤 4：解析查询结果"></a><strong>步骤 4：解析查询结果</strong></h4><p>从 Redis 返回的结果中提取商户 ID 和距离信息，并根据分页参数截取需要的数据。</p><ul><li>使用 <code>skip(from)</code> 跳过不需要的商户数据，确保从正确的起始位置开始提取商户。</li><li>提取商户的 ID 和距离信息，存入 <code>ids</code> 和 <code>distanceMap</code>。</li></ul><h4 id="步骤-5：根据商户-ID-查询商户详情"><a href="#步骤-5：根据商户-ID-查询商户详情" class="headerlink" title="步骤 5：根据商户 ID 查询商户详情"></a><strong>步骤 5：根据商户 ID 查询商户详情</strong></h4><p>根据提取到的商户 ID，从数据库中查询商户的详细信息，并将查询到的距离信息添加到商户数据中。</p><h4 id="步骤-6：返回结果"><a href="#步骤-6：返回结果" class="headerlink" title="步骤 6：返回结果"></a><strong>步骤 6：返回结果</strong></h4><p>最终返回商户的详细信息以及距离。</p><p>效果：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-326.png" alt="img"></p><h2 id="11、用户签到"><a href="#11、用户签到" class="headerlink" title="11、用户签到"></a>11、用户签到</h2><h3 id="11-1、用户签到-BitMap功能演示"><a href="#11-1、用户签到-BitMap功能演示" class="headerlink" title="11.1、用户签到-BitMap功能演示"></a>11.1、用户签到-BitMap功能演示</h3><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-327.png" alt="img"></p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>在实际场景中，可能有很多用户每月的签到记录。例如，假设每个用户每月有 30 天的签到记录，我们可以为每个用户使用一个 BitMap 来记录他们的签到情况。每位用户的签到信息会对应一个 1 或 0，1 表示签到，0 表示未签到。</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-328-1024x225.png" alt="img"></p><p>每天的签到是一个二进制位，1 表示签到，0 表示未签到。每个用户每月的签到数据就对应一个长度为 30 或 31 的二进制数。</p><p>假设一个用户的签到记录是：<br><code>1110101001001010111011001...</code><br>每个位置对应一个日期，1 表示该日期签到，0 表示未签到。</p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-329.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-330.png" alt="img"></p><p><strong>BITFIELD key GET</strong>(代表查询) <strong>u</strong>(u代表无符号，i代表有符号)<strong>截取几位作为结果 开始的位置</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-333.png" alt="img"></p><h3 id="11-2-、用户签到-实现签到功能"><a href="#11-2-、用户签到-实现签到功能" class="headerlink" title="11.2 、用户签到-实现签到功能"></a>11.2 、用户签到-实现签到功能</h3><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：</p><ul><li>将每个用户的签到数据以 <code>BitMap</code> 的形式存储。<code>BitMap</code> 通过位来表示数据，签到的位为 <code>1</code>，未签到的位为 <code>0</code>。</li><li>每次签到时，更新对应日期的位置（即每个用户的签到信息）。</li></ul><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-334-1024x510.png" alt="img"></p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">&quot;/sign&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">Result <span class="title">sign</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">return</span> userService.<span class="title">sign</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>UserServiceImpl</code> 中，具体实现签到的功能。代码执行的步骤如下：</p><ul><li><strong>获取当前用户 ID</strong>：通过 <code>UserHolder.getUser().getId()</code> 获取当前用户的 ID。</li><li><strong>获取当前日期</strong>：使用 <code>LocalDateTime.now()</code> 获取当前日期，用于计算当天的日期。</li><li><strong>构建 Redis <code>key</code></strong>：根据用户 ID 和当前年月（格式：<code>yyyyMM</code>）构建 Redis 的 <code>key</code>，即 <code>USER_SIGN_KEY + userId + keySuffix</code>，其中 <code>keySuffix</code> 为年月。</li><li><strong>计算今天是本月的第几天</strong>：通过 <code>now.getDayOfMonth()</code> 获取今天是本月的第几天（例如 1、2、3…）。</li><li><strong>更新 Redis 中的 BitMap</strong>：通过 <code>stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true)</code> 将对应日期的签到状态设置为 <code>1</code>，表示该用户已签到。</li></ul><p><code>SETBIT key offset 1</code>：将 <code>key</code> 对应的 BitMap 中的 <code>offset</code> 位置设置为 <code>1</code>，表示用户在该日期已签到。</p><ul><li><code>key</code>：用户某个月的签到记录。</li><li><code>offset</code>：签到的日期，<code>dayOfMonth - 1</code>（如 1 号签到对应的 <code>offset</code> 为 0）。</li><li><code>true</code>：表示该日期已签到（1），<code>false</code> 表示未签到（0）。</li></ul><p>用Apifox进行测试：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-335-1024x453.png" alt="img"></p><h3 id="11-3-用户签到-签到统计"><a href="#11-3-用户签到-签到统计" class="headerlink" title="11.3 用户签到-签到统计"></a>11.3 用户签到-签到统计</h3><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-337.png" alt="img"></p><p>在UserController类中写入如下代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">&quot;/sign/count&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">Result <span class="title">signCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> userService.<span class="title">signCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IUserService类中写入如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">signCount</span>()</span>;</span><br></pre></td></tr></table></figure><p>在UserServiceImpl类中写入如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">public Result signCount() &#123;</span><br><span class="line">    <span class="comment">//1.获取当前登录用户</span></span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2.获取日期</span></span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    <span class="comment">//3.拼接key</span></span><br><span class="line">    <span class="built_in">String</span> keySuffix = now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>));</span><br><span class="line">    <span class="built_in">String</span> key = USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">//4.获取今天是本月第几天</span></span><br><span class="line">    <span class="built_in">int</span> dayOfMonth = now.getDayOfMonth();</span><br><span class="line">    <span class="comment">//5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    <span class="built_in">List</span>&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key, BitFieldSubCommands.create()</span><br><span class="line">                    .<span class="keyword">get</span>(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="keyword">null</span> || result.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Long <span class="built_in">num</span> = result.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">num</span>==<span class="keyword">null</span> || <span class="built_in">num</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.循环遍历</span></span><br><span class="line">    <span class="built_in">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//6.1.让这个数字与1做与运算，得到数字的最后一个bit位</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">num</span>&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;<span class="comment">//6.2.判断这个bit位是否为0</span></span><br><span class="line">            <span class="comment">//6.3.如果为0，说明未签到结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//6.4.如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.5.把数字右移一位，抛弃最后一个bit位,继续下一个bit位</span></span><br><span class="line">        <span class="built_in">num</span> &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>步骤 1</strong>：获取当前登录用户的 ID。</li><li><strong>步骤 2</strong>：获取当前日期。</li><li><strong>步骤 3</strong>：拼接 Redis <code>key</code>，格式为 <code>USER_SIGN_KEY + userId + &quot;yyyyMM&quot;</code>，用于标识每个月的签到数据。</li><li><strong>步骤 4</strong>：获取今天是本月的第几天，即 <code>dayOfMonth</code>。</li><li><strong>步骤 5</strong>：使用 <code>BITFIELD</code> 命令获取当前月截至今天的签到数据。通过 <code>BitFieldSubCommands</code> 设置获取签到信息的位数。</li><li><strong>步骤 6</strong>：遍历签到数据，通过位操作（与运算）统计连续签到的天数。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-338-1024x449.png" alt="img"></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-339.png" alt="img"></p><p>11.4 额外补充-关于使用bitmap来解决缓存穿透的方案</p><p>回顾<strong>缓存穿透</strong>：</p><p><strong>缓存穿透问题概述</strong>：</p><ul><li>典型的解决办法是 <strong>缓存空值</strong>，即当数据库查询返回空数据时，将这个空数据也存入缓存，以防止相同的无效查询频繁访问数据库。</li><li><strong>缓存穿透</strong>指的是用户请求的数据既不在缓存中，也不在数据库中。每次用户请求的都可能是一个不存在的数据。攻击者可以通过不断请求不存在的数据来绕过缓存，直接访问数据库，造成数据库负担过重。</li></ul><p><strong>传统解决方案</strong>：</p><p>在传统解决方案中，如果数据库中没有数据，缓存中也没有，我们就会把该数据标记为空并存入缓存，这样下一次请求该数据时直接从缓存中获取。但这个方法存在的问题是：</p><ul><li>如果查询的是不同的 ID 数据，缓存会逐渐变得非常大，占用较多内存。</li><li>如果请求的是某个不存在的数据，缓存无法从一开始解决。</li></ul><p>所以我们如何解决呢？</p><p>为了更有效地解决缓存穿透问题并优化存储空间，我们可以使用 <strong>BitMap</strong> 代替 <strong>List</strong> 来存储 ID 数据。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路</strong>：</h4><ol><li><strong>数据存储方式</strong>：将所有合法的 ID 存储到一个非常大的 <strong>BitMap</strong> 中。每个 ID 的位置（即索引）对应于 BitMap 的某一位。当用户访问某个 ID 时，我们通过哈希算法（如 <code>id % bitmap.size</code>）计算出该 ID 应该存储在 BitMap 的哪个位置，并将该位置的值设置为 1，表示该数据已经存在。</li><li><strong>查询过程</strong>：当用户查询某个数据时，我们同样通过哈希算法计算该 ID 应该落在 BitMap 的哪个位置。如果该位置的值为 1，表示该数据存在；如果为 0，则表示该数据不存在，可以直接返回，不访问数据库。</li></ol><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤</strong>：</h4><ol><li><p>将 ID 数据存储到 BitMap</p><p>：例如，使用 Redis 的 </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SETBIT</span></span><br></pre></td></tr></table></figure><p> 命令将某个 ID 对应的位设置为 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>，表示该 ID 对应的数据存在。</p><ul><li><code>SETBIT key offset 1</code>：设置 <code>key</code> 对应的位（由 ID 计算得出）为 1，表示数据存在。</li></ul></li><li><p><strong>查询时通过哈希计算位置</strong>：当用户请求某个 ID 时，使用哈希算法（<code>id % bitmap.size</code>）计算出该 ID 在 BitMap 中的偏移位置。如果该位置为 1，则表示该数据存在，反之为 0，则说明该数据不存在。</p></li></ol><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点</strong>：</h4><ul><li><strong>节省内存</strong>：BitMap 只用一个比特位来表示一个数据的存在与否，相比 List 或 HashMap 等数据结构，它能够显著减少内存占用。</li><li><strong>高效查询</strong>：BitMap 的查询操作非常快速，通过直接访问对应的位来判断数据是否存在，查询复杂度为 O(1)。</li></ul><h4 id="误差率："><a href="#误差率：" class="headerlink" title="误差率："></a><strong>误差率</strong>：</h4><p>由于使用哈希算法来映射 ID 到 BitMap 中的位，因此可能会发生 <strong>哈希冲突</strong>。如果多个 ID 被映射到 BitMap 的同一位上，可能会出现误判的情况（即认为某个数据存在，但实际并不存在）。这种情况称为误差率。</p><p>误差率会随着哈希冲突的增加而增大，通常我们可以通过增加 BitMap 的大小来降低误差率。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-340-1024x260.png" alt="img"></p><ul><li>用户发起请求，查询某个数据（如 ID 为 1、2、3 的数据）。</li><li>数据被存储到 Redis 中，通过 <code>List</code> 存储 ID 数据。查询时，通过检查 <code>List</code> 是否包含对应的 ID 数据来判断缓存是否命中。</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-341-1024x432.png" alt="img"></p><ul><li>将 <code>List</code> 数据结构替换成 <code>BitMap</code>，并使用哈希算法将每个 ID 映射到 BitMap 的某一位。</li><li>使用 Redis 的 BitMap（<code>SETBIT</code> 和 <code>GETBIT</code>）操作，减少了 <code>List</code> 存储空间，并且提高了查询效率。</li></ul><h4 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a><strong>具体操作</strong>：</h4><ul><li><strong>SETBIT</strong>：设置某个位为 <code>1</code>，表示数据存在。</li><li><strong>GETBIT</strong>：获取某个位的值，判断数据是否存在。</li></ul><h2 id="12、UV统计"><a href="#12、UV统计" class="headerlink" title="12、UV统计"></a>12、UV统计</h2><h3 id="12-1-、UV统计-HyperLogLog"><a href="#12-1-、UV统计-HyperLogLog" class="headerlink" title="12.1 、UV统计-HyperLogLog"></a>12.1 、UV统计-HyperLogLog</h3><p>首先我们搞懂两个概念：</p><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a> Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-342-1024x356.png" alt="img"></p><p>不论添加几次，永远只记录一次。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-344.png" alt="img"></p><h3 id="12-2-UV统计-测试百万数据的统计"><a href="#12-2-UV统计-测试百万数据的统计" class="headerlink" title="12.2 UV统计-测试百万数据的统计"></a>12.2 UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-343-1024x506.png" alt="img"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p><p>100万数据成功写入：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-345-1024x556.png" alt="img"></p><p>测试前：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-346.png" alt="img"></p><p>测试后：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-347.png" alt="img"></p><p>大约占用11kb，确实是小于16kb。</p><h1 id="Redis-实战篇-黑马点评-完结"><a href="#Redis-实战篇-黑马点评-完结" class="headerlink" title="Redis(实战篇-黑马点评) 完结"></a>Redis(实战篇-黑马点评) 完结</h1>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础篇</title>
      <link href="/posts/5.html"/>
      <url>/posts/5.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-初识Redis"><a href="#1-初识Redis" class="headerlink" title="1.初识Redis"></a>1.初识Redis</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li>键值型</li><li>NoSql</li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-1024x416.png" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="1-1-认识NoSQL"><a href="#1-1-认识NoSQL" class="headerlink" title="1.1.认识NoSQL"></a>1.1.认识NoSQL</h3><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><ul><li>Redis</li><li>Mongo db</li><li>MemCached</li></ul><h4 id="1-1-1-结构化与非结构化"><a href="#1-1-1-结构化与非结构化" class="headerlink" title="1.1.1.结构化与非结构化"></a>1.1.1.结构化与非结构化</h4><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-2.png" alt="img"></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-3.png" alt="img"></p><p>也可以是文档型：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-4.png" alt="img"></p><p>甚至可以是图格式：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-5.png" alt="img"></p><h4 id="1-1-2-关联和非关联"><a href="#1-1-2-关联和非关联" class="headerlink" title="1.1.2.关联和非关联"></a>1.1.2.关联和非关联</h4><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-6-1024x520.png" alt="img"></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="params">id:</span> <span class="number">1</span>,</span><br><span class="line">  <span class="params">name:</span> <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="params">orders:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="params">id:</span> <span class="number">1</span>,</span><br><span class="line">       <span class="params">item:</span> &#123;</span><br><span class="line">     <span class="params">id:</span> <span class="number">10</span>, <span class="params">title:</span> <span class="string">&quot;荣耀6&quot;</span>, <span class="params">price:</span> <span class="number">4999</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="params">id:</span> <span class="number">2</span>,</span><br><span class="line">       <span class="params">item:</span> &#123;</span><br><span class="line">     <span class="params">id:</span> <span class="number">20</span>, <span class="params">title:</span> <span class="string">&quot;小米11&quot;</span>, <span class="params">price:</span> <span class="number">3999</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h4 id="1-1-3-查询方式"><a href="#1-1-3-查询方式" class="headerlink" title="1.1.3.查询方式"></a>1.1.3.查询方式</h4><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-7-1024x391.png" alt="img"></p><h4 id="1-1-4-事务"><a href="#1-1-4-事务" class="headerlink" title="1.1.4.事务"></a>1.1.4.事务</h4><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-8.png" alt="img"></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h4 id="1-1-5-总结"><a href="#1-1-5-总结" class="headerlink" title="1.1.5.总结"></a>1.1.5.总结</h4><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-9-1024x483.png" alt="img"></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h3 id="1-2-认识Redis"><a href="#1-2-认识Redis" class="headerlink" title="1.2.认识Redis"></a>1.2.认识Redis</h3><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h3 id="1-3-Redis的启动"><a href="#1-3-Redis的启动" class="headerlink" title="1.3 Redis的启动"></a>1.3 Redis的启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h4 id="1-3-1默认启动"><a href="#1-3-1默认启动" class="headerlink" title="1.3.1默认启动"></a>1.3.1默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-指定配置启动"><a href="#1-3-2-指定配置启动" class="headerlink" title="1.3.2.指定配置启动"></a>1.3.2.指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 进入redis安装目录 </span></span><br><span class="line"><span class="meta"># 启动</span></span><br><span class="line">redis-<span class="keyword">server</span>.exe redis.windows.conf</span><br><span class="line">Redis服务默认端口号为 <span class="number">6379</span> ，通过快捷键Ctrl + C 即可停止Redis服务</span><br><span class="line"></span><br><span class="line">当Redis服务启动成功后，可通过客户端进行连接。</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attribute">bind</span> <span class="number">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行 （windows不支持）</span></span><br><span class="line">daemonize <span class="literal">yes</span> </span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attribute">port</span> <span class="number">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attribute">dir</span> .</span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attribute">databases</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attribute">maxmemory</span> <span class="number">512</span>mb</span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attribute">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line"><span class="attribute">redis</span>-cli -u <span class="number">123456</span> shutdown</span><br></pre></td></tr></table></figure><h4 id="1-3-3-客户端连接命令"><a href="#1-3-3-客户端连接命令" class="headerlink" title="1.3.3 客户端连接命令"></a>1.3.3 客户端连接命令</h4><p><strong>redis-cli.exe</strong></p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-10-1024x261.png" alt="img"></p><p>通过redis-cli.exe命令默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：</p><ul><li>-h ip地址</li><li>-p 端口号</li><li>-a 密码（如果需要）</li><li></li></ul><h4 id="1-3-4Redis客户端图形工具"><a href="#1-3-4Redis客户端图形工具" class="headerlink" title="1.3.4Redis客户端图形工具"></a>1.3.4Redis客户端图形工具</h4><p>默认提供的客户端连接工具界面不太友好，同时操作也较为麻烦，需引入一个Redis客户端图形工具。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-11-1024x771.png" alt="img"></p><h2 id="2-Redis数据类型"><a href="#2-Redis数据类型" class="headerlink" title="2. Redis数据类型"></a>2. Redis数据类型</h2><h3 id="2-1-五种常用数据类型介绍"><a href="#2-1-五种常用数据类型介绍" class="headerlink" title="2.1 五种常用数据类型介绍"></a>2.1 五种常用数据类型介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set / zset</li></ul><h3 id="2-2-各种数据类型特点"><a href="#2-2-各种数据类型特点" class="headerlink" title="2.2 各种数据类型特点"></a>2.2 各种数据类型特点</h3><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-12.png" alt="img"></p><p><strong>解释说明：</strong></p><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：也叫散列，类似于Java中的HashMap结构</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(sorted set/zset)：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素</li></ul><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-13-1024x516.png" alt="img"></p><h2 id="3-Redis常用命令"><a href="#3-Redis常用命令" class="headerlink" title="3. Redis常用命令"></a>3. Redis常用命令</h2><h3 id="3-1-String字符串操作命令"><a href="#3-1-String字符串操作命令" class="headerlink" title="3.1 String字符串操作命令"></a>3.1 String字符串操作命令</h3><p>Redis 中字符串类型常用命令：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p>更多命令可以参考Redis中文网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn</a></p><h3 id="3-2-Hash哈希操作命令"><a href="#3-2-Hash哈希操作命令" class="headerlink" title="3.2 Hash哈希操作命令"></a>3.2 Hash哈希操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-14.png" alt="img"></p><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h3 id="3-3-List列表操作命令"><a href="#3-3-List列表操作命令" class="headerlink" title="3.3 List列表操作命令"></a>3.3 List列表操作命令</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-15.png" alt="img"></p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><h3 id="3-4-Set集合操作命令"><a href="#3-4-Set集合操作命令" class="headerlink" title="3.4 Set集合操作命令"></a>3.4 Set集合操作命令</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-16.png" alt="img"></p><ul><li>支持交集、并集、差集等功能</li><li>无序</li><li>元素不可重复</li><li>查找快</li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li></ul><h3 id="3-5-SortedSet有序集合操作命令"><a href="#3-5-SortedSet有序集合操作命令" class="headerlink" title="3.5 SortedSet有序集合操作命令"></a>3.5 SortedSet有序集合操作命令</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>常用命令：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li><li>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</li><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber   </li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-17.png" alt="img"></p><h3 id="3-6-通用命令"><a href="#3-6-通用命令" class="headerlink" title="3.6 通用命令"></a>3.6 通用命令</h3><p>Redis的通用命令是不分数据类型的，都可以使用的命令：</p><ul><li>KEYS pattern 查找所有符合给定模式( pattern)的 key</li><li>EXISTS key 检查给定 key 是否存在</li><li>TYPE key 返回 key 所储存的值的类型</li><li>DEL key 该命令用于在 key 存在是删除 key</li><li>EXPIRE key 给一个key设置有效期，有效期到期时key会自动删除</li><li>TTL key 查看一个key的剩余有效期(-1永久，-2被移除)</li></ul><h3 id="3-7-Key结构"><a href="#3-7-Key结构" class="headerlink" title="3.7 Key结构"></a>3.7 Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li>user相关的key：<strong>heima:user:1</strong></li><li>product相关的key：<strong>heima:product:1</strong></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><div class="table-container"><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table></div><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰。</p><h2 id="4-在Java中操作Redis"><a href="#4-在Java中操作Redis" class="headerlink" title="4.在Java中操作Redis"></a>4.在Java中操作Redis</h2><h3 id="4-1-Redis的Java客户端"><a href="#4-1-Redis的Java客户端" class="headerlink" title="4.1 Redis的Java客户端"></a>4.1 Redis的Java客户端</h3><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p><p>Redis 的 Java 客户端很多，常用的几种：</p><ul><li>Jedis</li><li>Lettuce</li><li>Spring Data Redis</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p><p>我们重点学习<strong>Spring Data Redis</strong>。</p><h4 id="4-1-1Jedis客户端"><a href="#4-1-1Jedis客户端" class="headerlink" title="4.1.1Jedis客户端"></a>4.1.1Jedis客户端</h4><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a>   （快速入门）</p><h4 id="4-1-2-SpringDataRedis客户端"><a href="#4-1-2-SpringDataRedis客户端" class="headerlink" title="4.1.2 SpringDataRedis客户端"></a>4.1.2 SpringDataRedis客户端</h4><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-18-1024x331.png" alt="img"></p><p><strong>环境搭建</strong>：</p><p><strong>1). 导入Spring Data Redis的maven坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2). 配置Redis数据源</strong></p><p>在application-dev.yml中添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sky:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure><p>database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p><p>在application.yml中添加读取application-dev.yml中的相关Redis配置</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spring:</span></span><br><span class="line"><span class="symbol">  profiles:</span></span><br><span class="line"><span class="symbol">    active:</span> dev</span><br><span class="line"><span class="symbol">  redis:</span></span><br><span class="line"><span class="symbol">    host:</span> $<span class="punctuation">&#123;</span>sky.redis.host<span class="punctuation">&#125;</span></span><br><span class="line"><span class="symbol">    port:</span> $<span class="punctuation">&#123;</span>sky.redis.port<span class="punctuation">&#125;</span></span><br><span class="line"><span class="symbol">    password:</span> $<span class="punctuation">&#123;</span>sky.redis.password<span class="punctuation">&#125;</span></span><br><span class="line"><span class="symbol">    database:</span> $<span class="punctuation">&#123;</span>sky.redis.database<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>3). 编写配置类，创建RedisTemplate对象</strong>，自定义RedisTemplate的序列化方式</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; <span class="keyword">template</span> = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        <span class="keyword">template</span>.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        GenericJackson2JsonRedisSerializer jsonRedisSerializer = </span><br><span class="line">            <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        <span class="keyword">template</span>.setKeySerializer(RedisSerializer.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">template</span>.setHashKeySerializer(RedisSerializer.<span class="built_in">string</span>());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        <span class="keyword">template</span>.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="keyword">template</span>.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">template</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-19-1024x210.png" alt="img"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-20-1024x326.png" alt="img"></p><p><strong><em>为了节省内存空间\</em></strong>，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-21-1024x352.png" alt="img"></p><p>StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：RedisTemplate 和 StringRedisTemplate</strong></p><p><code>**RedisTemplate**</code>（泛型通用）：</p><ul><li>是一个<strong>通用的 Redis 操作模板</strong>，支持任意类型的 key 和 value（通过泛型控制），例如对象、列表、哈希等。</li><li>需要自己配置序列化器（比如 <code>Jackson2JsonRedisSerializer</code>）来处理 key/value 的序列化与反序列化</li></ul><p><code>**StringRedisTemplate**</code>（专门针对字符串）</p><ul><li>是 <code>RedisTemplate&lt;String, String&gt;</code> 的一个<strong>专用子类</strong>。</li><li>内部已经默认设置好了字符串的序列化方式，适合 key 和 value 都是字符串的场景。</li><li>使用更简单直观，常用于缓存简单字符串值，如：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue().<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://www.legendkiller.xyz/wp-content/uploads/2025/05/image-22.png" alt="img"></p><h1 id="Redis基础篇完结"><a href="#Redis基础篇完结" class="headerlink" title="Redis基础篇完结"></a><strong>Redis基础篇完结</strong></h1>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
